/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/**
 * Throw a given error.
 *
 * @param {Error|null|undefined} [error]
 *   Maybe error.
 * @returns {asserts error is null|undefined}
 */
function bail(error) {
  if (error) {
    throw error
  }
}

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

var isBuffer = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
};

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject$1 = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

var extend = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject$1(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject$1(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};

function isPlainObject(value) {
	if (typeof value !== 'object' || value === null) {
		return false;
	}

	const prototype = Object.getPrototypeOf(value);
	return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

/**
 * @typedef {(error?: Error|null|undefined, ...output: Array<any>) => void} Callback
 * @typedef {(...input: Array<any>) => any} Middleware
 *
 * @typedef {(...input: Array<any>) => void} Run
 *   Call all middleware.
 * @typedef {(fn: Middleware) => Pipeline} Use
 *   Add `fn` (middleware) to the list.
 * @typedef {{run: Run, use: Use}} Pipeline
 *   Middleware.
 */

/**
 * Create new middleware.
 *
 * @returns {Pipeline}
 */
function trough() {
  /** @type {Array<Middleware>} */
  const fns = [];
  /** @type {Pipeline} */
  const pipeline = {run, use};

  return pipeline

  /** @type {Run} */
  function run(...values) {
    let middlewareIndex = -1;
    /** @type {Callback} */
    const callback = values.pop();

    if (typeof callback !== 'function') {
      throw new TypeError('Expected function as last argument, not ' + callback)
    }

    next(null, ...values);

    /**
     * Run the next `fn`, or we’re done.
     *
     * @param {Error|null|undefined} error
     * @param {Array<any>} output
     */
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index = -1;

      if (error) {
        callback(error);
        return
      }

      // Copy non-nullish input into values.
      while (++index < values.length) {
        if (output[index] === null || output[index] === undefined) {
          output[index] = values[index];
        }
      }

      // Save the newly created `output` for the next call.
      values = output;

      // Next or done.
      if (fn) {
        wrap(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }

  /** @type {Use} */
  function use(middelware) {
    if (typeof middelware !== 'function') {
      throw new TypeError(
        'Expected `middelware` to be a function, not ' + middelware
      )
    }

    fns.push(middelware);
    return pipeline
  }
}

/**
 * Wrap `middleware`.
 * Can be sync or async; return a promise, receive a callback, or return new
 * values and errors.
 *
 * @param {Middleware} middleware
 * @param {Callback} callback
 */
function wrap(middleware, callback) {
  /** @type {boolean} */
  let called;

  return wrapped

  /**
   * Call `middleware`.
   * @this {any}
   * @param {Array<any>} parameters
   * @returns {void}
   */
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    /** @type {any} */
    let result;

    if (fnExpectsCallback) {
      parameters.push(done);
    }

    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = /** @type {Error} */ (error);

      // Well, this is quite the pickle.
      // `middleware` received a callback and called it synchronously, but that
      // threw an error.
      // The only thing left to do is to throw the thing instead.
      if (fnExpectsCallback && called) {
        throw exception
      }

      return done(exception)
    }

    if (!fnExpectsCallback) {
      if (result instanceof Promise) {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }

  /**
   * Call `callback`, only once.
   * @type {Callback}
   */
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }

  /**
   * Call `done` with one value.
   *
   * @param {any} [value]
   */
  function then(value) {
    done(null, value);
  }
}

/**
 * @typedef {import('unist').Point} Point
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Position} Position
 * @typedef {object & {type: string, position?: Position|undefined}} NodeLike
 */

/**
 * Stringify one point, a position (start and end points), or a node’s
 * positional information.
 *
 * @param {Node|NodeLike|Position|Point|null} [value]
 * @returns {string}
 */
function stringifyPosition(value) {
  // Nothing.
  if (!value || typeof value !== 'object') {
    return ''
  }

  // Node.
  if ('position' in value || 'type' in value) {
    return position(value.position)
  }

  // Position.
  if ('start' in value || 'end' in value) {
    return position(value)
  }

  // Point.
  if ('line' in value || 'column' in value) {
    return point(value)
  }

  // ?
  return ''
}

/**
 * @param {Point|undefined} point
 * @returns {string}
 */
function point(point) {
  return index(point && point.line) + ':' + index(point && point.column)
}

/**
 * @param {Position|undefined} pos
 * @returns {string}
 */
function position(pos) {
  return point(pos && pos.start) + '-' + point(pos && pos.end)
}

/**
 * @param {number|undefined} value
 * @returns {number}
 */
function index(value) {
  return value && typeof value === 'number' ? value : 1
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Position} Position
 * @typedef {import('unist').Point} Point
 * @typedef {object & {type: string, position?: Position|undefined}} NodeLike
 */

class VFileMessage extends Error {
  /**
   * Constructor of a message for `reason` at `place` from `origin`.
   * When an error is passed in as `reason`, copies the `stack`.
   *
   * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.
   * @param {Node|NodeLike|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).
   * @param {string} [origin] Place in code the message originates from (`string`, optional).
   */
  constructor(reason, place, origin) {
    /** @type {[string|null, string|null]} */
    const parts = [null, null];
    /** @type {Position} */
    let position = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: {line: null, column: null},
      // @ts-expect-error: "
      end: {line: null, column: null}
    };

    super();

    if (typeof place === 'string') {
      origin = place;
      place = undefined;
    }

    if (typeof origin === 'string') {
      const index = origin.indexOf(':');

      if (index === -1) {
        parts[1] = origin;
      } else {
        parts[0] = origin.slice(0, index);
        parts[1] = origin.slice(index + 1);
      }
    }

    if (place) {
      // Node.
      if ('type' in place || 'position' in place) {
        if (place.position) {
          position = place.position;
        }
      }
      // Position.
      else if ('start' in place || 'end' in place) {
        position = place;
      }
      // Point.
      else if ('line' in place || 'column' in place) {
        position.start = place;
      }
    }

    // Fields from `Error`
    this.name = stringifyPosition(place) || '1:1';
    this.message = typeof reason === 'object' ? reason.message : reason;
    this.stack = typeof reason === 'object' ? reason.stack : '';

    /**
     * Reason for message.
     * @type {string}
     */
    this.reason = this.message;
    /**
     * If true, marks associated file as no longer processable.
     * @type {boolean?}
     */
    // eslint-disable-next-line no-unused-expressions
    this.fatal;
    /**
     * Starting line of error.
     * @type {number?}
     */
    this.line = position.start.line;
    /**
     * Starting column of error.
     * @type {number?}
     */
    this.column = position.start.column;
    /**
     * Namespace of warning.
     * @type {string?}
     */
    this.source = parts[0];
    /**
     * Category of message.
     * @type {string?}
     */
    this.ruleId = parts[1];
    /**
     * Full range information, when available.
     * Has start and end properties, both set to an object with line and column, set to number?.
     * @type {Position?}
     */
    this.position = position;

    // The following fields are “well known”.
    // Not standard.
    // Feel free to add other non-standard fields to your messages.

    /* eslint-disable no-unused-expressions */
    /**
     * You can use this to specify the source value that’s being reported, which
     * is deemed incorrect.
     * @type {string?}
     */
    this.actual;
    /**
     * You can use this to suggest values that should be used instead of
     * `actual`, one or more values that are deemed as acceptable.
     * @type {Array<string>?}
     */
    this.expected;
    /**
     * You may add a file property with a path of a file (used throughout the VFile ecosystem).
     * @type {string?}
     */
    this.file;
    /**
     * You may add a url property with a link to documentation for the message.
     * @type {string?}
     */
    this.url;
    /**
     * You may add a note property with a long form description of the message (supported by vfile-reporter).
     * @type {string?}
     */
    this.note;
    /* eslint-enable no-unused-expressions */
  }
}

VFileMessage.prototype.file = '';
VFileMessage.prototype.name = '';
VFileMessage.prototype.reason = '';
VFileMessage.prototype.message = '';
VFileMessage.prototype.stack = '';
VFileMessage.prototype.fatal = null;
VFileMessage.prototype.column = null;
VFileMessage.prototype.line = null;
VFileMessage.prototype.source = null;
VFileMessage.prototype.ruleId = null;
VFileMessage.prototype.position = null;

// A derivative work based on:
// <https://github.com/browserify/path-browserify>.
// Which is licensed:
//
// MIT License
//
// Copyright (c) 2013 James Halliday
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// A derivative work based on:
//
// Parts of that are extracted from Node’s internal `path` module:
// <https://github.com/nodejs/node/blob/master/lib/path.js>.
// Which is licensed:
//
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

const path$1 = {basename, dirname, extname, join, sep: '/'};

/* eslint-disable max-depth, complexity */

/**
 * @param {string} path
 * @param {string} [ext]
 * @returns {string}
 */
function basename(path, ext) {
  if (ext !== undefined && typeof ext !== 'string') {
    throw new TypeError('"ext" argument must be a string')
  }

  assertPath$1(path);
  let start = 0;
  let end = -1;
  let index = path.length;
  /** @type {boolean|undefined} */
  let seenNonSlash;

  if (ext === undefined || ext.length === 0 || ext.length > path.length) {
    while (index--) {
      if (path.charCodeAt(index) === 47 /* `/` */) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now.
        if (seenNonSlash) {
          start = index + 1;
          break
        }
      } else if (end < 0) {
        // We saw the first non-path separator, mark this as the end of our
        // path component.
        seenNonSlash = true;
        end = index + 1;
      }
    }

    return end < 0 ? '' : path.slice(start, end)
  }

  if (ext === path) {
    return ''
  }

  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;

  while (index--) {
    if (path.charCodeAt(index) === 47 /* `/` */) {
      // If we reached a path separator that was not part of a set of path
      // separators at the end of the string, stop now.
      if (seenNonSlash) {
        start = index + 1;
        break
      }
    } else {
      if (firstNonSlashEnd < 0) {
        // We saw the first non-path separator, remember this index in case
        // we need it if the extension ends up not matching.
        seenNonSlash = true;
        firstNonSlashEnd = index + 1;
      }

      if (extIndex > -1) {
        // Try to match the explicit extension.
        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            // We matched the extension, so mark this as the end of our path
            // component
            end = index;
          }
        } else {
          // Extension does not match, so our result is the entire path
          // component
          extIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }

  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path.length;
  }

  return path.slice(start, end)
}

/**
 * @param {string} path
 * @returns {string}
 */
function dirname(path) {
  assertPath$1(path);

  if (path.length === 0) {
    return '.'
  }

  let end = -1;
  let index = path.length;
  /** @type {boolean|undefined} */
  let unmatchedSlash;

  // Prefix `--` is important to not run on `0`.
  while (--index) {
    if (path.charCodeAt(index) === 47 /* `/` */) {
      if (unmatchedSlash) {
        end = index;
        break
      }
    } else if (!unmatchedSlash) {
      // We saw the first non-path separator
      unmatchedSlash = true;
    }
  }

  return end < 0
    ? path.charCodeAt(0) === 47 /* `/` */
      ? '/'
      : '.'
    : end === 1 && path.charCodeAt(0) === 47 /* `/` */
    ? '//'
    : path.slice(0, end)
}

/**
 * @param {string} path
 * @returns {string}
 */
function extname(path) {
  assertPath$1(path);

  let index = path.length;

  let end = -1;
  let startPart = 0;
  let startDot = -1;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find.
  let preDotState = 0;
  /** @type {boolean|undefined} */
  let unmatchedSlash;

  while (index--) {
    const code = path.charCodeAt(index);

    if (code === 47 /* `/` */) {
      // If we reached a path separator that was not part of a set of path
      // separators at the end of the string, stop now.
      if (unmatchedSlash) {
        startPart = index + 1;
        break
      }

      continue
    }

    if (end < 0) {
      // We saw the first non-path separator, mark this as the end of our
      // extension.
      unmatchedSlash = true;
      end = index + 1;
    }

    if (code === 46 /* `.` */) {
      // If this is our first dot, mark it as the start of our extension.
      if (startDot < 0) {
        startDot = index;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension.
      preDotState = -1;
    }
  }

  if (
    startDot < 0 ||
    end < 0 ||
    // We saw a non-dot character immediately before the dot.
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly `..`.
    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)
  ) {
    return ''
  }

  return path.slice(startDot, end)
}

/**
 * @param {Array<string>} segments
 * @returns {string}
 */
function join(...segments) {
  let index = -1;
  /** @type {string|undefined} */
  let joined;

  while (++index < segments.length) {
    assertPath$1(segments[index]);

    if (segments[index]) {
      joined =
        joined === undefined ? segments[index] : joined + '/' + segments[index];
    }
  }

  return joined === undefined ? '.' : normalize(joined)
}

/**
 * Note: `normalize` is not exposed as `path.normalize`, so some code is
 * manually removed from it.
 *
 * @param {string} path
 * @returns {string}
 */
function normalize(path) {
  assertPath$1(path);

  const absolute = path.charCodeAt(0) === 47; /* `/` */

  // Normalize the path according to POSIX rules.
  let value = normalizeString(path, !absolute);

  if (value.length === 0 && !absolute) {
    value = '.';
  }

  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47 /* / */) {
    value += '/';
  }

  return absolute ? '/' + value : value
}

/**
 * Resolve `.` and `..` elements in a path with directory names.
 *
 * @param {string} path
 * @param {boolean} allowAboveRoot
 * @returns {string}
 */
function normalizeString(path, allowAboveRoot) {
  let result = '';
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index = -1;
  /** @type {number|undefined} */
  let code;
  /** @type {number} */
  let lastSlashIndex;

  while (++index <= path.length) {
    if (index < path.length) {
      code = path.charCodeAt(index);
    } else if (code === 47 /* `/` */) {
      break
    } else {
      code = 47; /* `/` */
    }

    if (code === 47 /* `/` */) {
      if (lastSlash === index - 1 || dots === 1) ; else if (lastSlash !== index - 1 && dots === 2) {
        if (
          result.length < 2 ||
          lastSegmentLength !== 2 ||
          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||
          result.charCodeAt(result.length - 2) !== 46 /* `.` */
        ) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf('/');

            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = '';
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf('/');
              }

              lastSlash = index;
              dots = 0;
              continue
            }
          } else if (result.length > 0) {
            result = '';
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue
          }
        }

        if (allowAboveRoot) {
          result = result.length > 0 ? result + '/..' : '..';
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += '/' + path.slice(lastSlash + 1, index);
        } else {
          result = path.slice(lastSlash + 1, index);
        }

        lastSegmentLength = index - lastSlash - 1;
      }

      lastSlash = index;
      dots = 0;
    } else if (code === 46 /* `.` */ && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }

  return result
}

/**
 * @param {string} path
 */
function assertPath$1(path) {
  if (typeof path !== 'string') {
    throw new TypeError(
      'Path must be a string. Received ' + JSON.stringify(path)
    )
  }
}

/* eslint-enable max-depth, complexity */

// Somewhat based on:
// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.
// But I don’t think one tiny line of code can be copyrighted. 😅
const proc = {cwd};

function cwd() {
  return '/'
}

/**
 * @typedef URL
 * @property {string} hash
 * @property {string} host
 * @property {string} hostname
 * @property {string} href
 * @property {string} origin
 * @property {string} password
 * @property {string} pathname
 * @property {string} port
 * @property {string} protocol
 * @property {string} search
 * @property {any} searchParams
 * @property {string} username
 * @property {() => string} toString
 * @property {() => string} toJSON
 */

/**
 * @param {unknown} fileURLOrPath
 * @returns {fileURLOrPath is URL}
 */
// From: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js#L1501>
function isUrl(fileURLOrPath) {
  return (
    fileURLOrPath !== null &&
    typeof fileURLOrPath === 'object' &&
    // @ts-expect-error: indexable.
    fileURLOrPath.href &&
    // @ts-expect-error: indexable.
    fileURLOrPath.origin
  )
}

/// <reference lib="dom" />

// See: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js>

/**
 * @param {string|URL} path
 */
function urlToPath(path) {
  if (typeof path === 'string') {
    path = new URL(path);
  } else if (!isUrl(path)) {
    /** @type {NodeJS.ErrnoException} */
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' +
        path +
        '`'
    );
    error.code = 'ERR_INVALID_ARG_TYPE';
    throw error
  }

  if (path.protocol !== 'file:') {
    /** @type {NodeJS.ErrnoException} */
    const error = new TypeError('The URL must be of scheme file');
    error.code = 'ERR_INVALID_URL_SCHEME';
    throw error
  }

  return getPathFromURLPosix(path)
}

/**
 * @param {URL} url
 */
function getPathFromURLPosix(url) {
  if (url.hostname !== '') {
    /** @type {NodeJS.ErrnoException} */
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = 'ERR_INVALID_FILE_URL_HOST';
    throw error
  }

  const pathname = url.pathname;
  let index = -1;

  while (++index < pathname.length) {
    if (
      pathname.charCodeAt(index) === 37 /* `%` */ &&
      pathname.charCodeAt(index + 1) === 50 /* `2` */
    ) {
      const third = pathname.charCodeAt(index + 2);
      if (third === 70 /* `F` */ || third === 102 /* `f` */) {
        /** @type {NodeJS.ErrnoException} */
        const error = new TypeError(
          'File URL path must not include encoded / characters'
        );
        error.code = 'ERR_INVALID_FILE_URL_PATH';
        throw error
      }
    }
  }

  return decodeURIComponent(pathname)
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Position} Position
 * @typedef {import('unist').Point} Point
 * @typedef {Record<string, unknown> & {type: string, position?: Position|undefined}} NodeLike
 * @typedef {import('./minurl.shared.js').URL} URL
 * @typedef {import('../index.js').Data} Data
 * @typedef {import('../index.js').Value} Value
 *
 * @typedef {'ascii'|'utf8'|'utf-8'|'utf16le'|'ucs2'|'ucs-2'|'base64'|'base64url'|'latin1'|'binary'|'hex'} BufferEncoding
 *   Encodings supported by the buffer class.
 *   This is a copy of the typing from Node, copied to prevent Node globals from
 *   being needed.
 *   Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>
 *
 * @typedef {Value|Options|VFile|URL} Compatible
 *   Things that can be passed to the constructor.
 *
 * @typedef VFileCoreOptions
 * @property {Value} [value]
 * @property {string} [cwd]
 * @property {Array<string>} [history]
 * @property {string|URL} [path]
 * @property {string} [basename]
 * @property {string} [stem]
 * @property {string} [extname]
 * @property {string} [dirname]
 * @property {Data} [data]
 *
 * @typedef Map
 *   Raw source map, see:
 *   <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.
 * @property {number} version
 * @property {Array<string>} sources
 * @property {Array<string>} names
 * @property {string|undefined} [sourceRoot]
 * @property {Array<string>|undefined} [sourcesContent]
 * @property {string} mappings
 * @property {string} file
 *
 * @typedef {{[key: string]: unknown} & VFileCoreOptions} Options
 *   Configuration: a bunch of keys that will be shallow copied over to the new
 *   file.
 *
 * @typedef {Record<string, unknown>} ReporterSettings
 * @typedef {<T = ReporterSettings>(files: Array<VFile>, options: T) => string} Reporter
 */

// Order of setting (least specific to most), we need this because otherwise
// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a
// stem can be set.
const order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname'];

class VFile {
  /**
   * Create a new virtual file.
   *
   * If `options` is `string` or `Buffer`, it’s treated as `{value: options}`.
   * If `options` is a `URL`, it’s treated as `{path: options}`.
   * If `options` is a `VFile`, shallow copies its data over to the new file.
   * All fields in `options` are set on the newly created `VFile`.
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * It’s not possible to set either `dirname` or `extname` without setting
   * either `history`, `path`, `basename`, or `stem` as well.
   *
   * @param {Compatible} [value]
   */
  constructor(value) {
    /** @type {Options} */
    let options;

    if (!value) {
      options = {};
    } else if (typeof value === 'string' || isBuffer(value)) {
      // @ts-expect-error Looks like a buffer.
      options = {value};
    } else if (isUrl(value)) {
      options = {path: value};
    } else {
      // @ts-expect-error Looks like file or options.
      options = value;
    }

    /**
     * Place to store custom information (default: `{}`).
     * It’s OK to store custom data directly on the file but moving it to
     * `data` is recommended.
     * @type {Data}
     */
    this.data = {};

    /**
     * List of messages associated with the file.
     * @type {Array<VFileMessage>}
     */
    this.messages = [];

    /**
     * List of filepaths the file moved between.
     * The first is the original path and the last is the current path.
     * @type {Array<string>}
     */
    this.history = [];

    /**
     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).
     * @type {string}
     */
    this.cwd = proc.cwd();

    /* eslint-disable no-unused-expressions */
    /**
     * Raw value.
     * @type {Value}
     */
    this.value;

    // The below are non-standard, they are “well-known”.
    // As in, used in several tools.

    /**
     * Whether a file was saved to disk.
     * This is used by vfile reporters.
     * @type {boolean}
     */
    this.stored;

    /**
     * Sometimes files have a non-string, compiled, representation.
     * This can be stored in the `result` field.
     * One example is when turning markdown into React nodes.
     * This is used by unified to store non-string results.
     * @type {unknown}
     */
    this.result;

    /**
     * Sometimes files have a source map associated with them.
     * This can be stored in the `map` field.
     * This should be a `Map` type, which is equivalent to the `RawSourceMap`
     * type from the `source-map` module.
     * @type {Map|undefined}
     */
    this.map;
    /* eslint-enable no-unused-expressions */

    // Set path related properties in the correct order.
    let index = -1;

    while (++index < order.length) {
      const prop = order[index];

      // Note: we specifically use `in` instead of `hasOwnProperty` to accept
      // `vfile`s too.
      if (prop in options && options[prop] !== undefined) {
        // @ts-expect-error: TS is confused by the different types for `history`.
        this[prop] = prop === 'history' ? [...options[prop]] : options[prop];
      }
    }

    /** @type {string} */
    let prop;

    // Set non-path related properties.
    for (prop in options) {
      // @ts-expect-error: fine to set other things.
      if (!order.includes(prop)) this[prop] = options[prop];
    }
  }

  /**
   * Get the full path (example: `'~/index.min.js'`).
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1]
  }

  /**
   * Set the full path (example: `'~/index.min.js'`).
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   * @param {string|URL} path
   */
  set path(path) {
    if (isUrl(path)) {
      path = urlToPath(path);
    }

    assertNonEmpty(path, 'path');

    if (this.path !== path) {
      this.history.push(path);
    }
  }

  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path === 'string' ? path$1.dirname(this.path) : undefined
  }

  /**
   * Set the parent path (example: `'~'`).
   * Cannot be set if there’s no `path` yet.
   */
  set dirname(dirname) {
    assertPath(this.basename, 'dirname');
    this.path = path$1.join(dirname || '', this.basename);
  }

  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path === 'string' ? path$1.basename(this.path) : undefined
  }

  /**
   * Set basename (including extname) (`'index.min.js'`).
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(basename) {
    assertNonEmpty(basename, 'basename');
    assertPart(basename, 'basename');
    this.path = path$1.join(this.dirname || '', basename);
  }

  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path === 'string' ? path$1.extname(this.path) : undefined
  }

  /**
   * Set the extname (including dot) (example: `'.js'`).
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   */
  set extname(extname) {
    assertPart(extname, 'extname');
    assertPath(this.dirname, 'extname');

    if (extname) {
      if (extname.charCodeAt(0) !== 46 /* `.` */) {
        throw new Error('`extname` must start with `.`')
      }

      if (extname.includes('.', 1)) {
        throw new Error('`extname` cannot contain multiple dots')
      }
    }

    this.path = path$1.join(this.dirname, this.stem + (extname || ''));
  }

  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path === 'string'
      ? path$1.basename(this.path, this.extname)
      : undefined
  }

  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(stem) {
    assertNonEmpty(stem, 'stem');
    assertPart(stem, 'stem');
    this.path = path$1.join(this.dirname || '', stem + (this.extname || ''));
  }

  /**
   * Serialize the file.
   *
   * @param {BufferEncoding} [encoding='utf8']
   *   When `value` is a `Buffer`, `encoding` is a character encoding to
   *   understand it as (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    return (this.value || '').toString(encoding)
  }

  /**
   * Constructs a new `VFileMessage`, where `fatal` is set to `false`, and
   * associates it with the file by adding it to `vfile.messages` and setting
   * `message.file` to the current filepath.
   *
   * @param {string|Error} reason
   *   Human readable reason for the message, uses the stack and message of the error if given.
   * @param {Node|NodeLike|Position|Point} [place]
   *   Place where the message occurred in the file.
   * @param {string} [origin]
   *   Computer readable reason for the message
   * @returns {VFileMessage}
   *   Message.
   */
  message(reason, place, origin) {
    const message = new VFileMessage(reason, place, origin);

    if (this.path) {
      message.name = this.path + ':' + message.name;
      message.file = this.path;
    }

    message.fatal = false;

    this.messages.push(message);

    return message
  }

  /**
   * Like `VFile#message()`, but associates an informational message where
   * `fatal` is set to `null`.
   *
   * @param {string|Error} reason
   *   Human readable reason for the message, uses the stack and message of the error if given.
   * @param {Node|NodeLike|Position|Point} [place]
   *   Place where the message occurred in the file.
   * @param {string} [origin]
   *   Computer readable reason for the message
   * @returns {VFileMessage}
   *   Message.
   */
  info(reason, place, origin) {
    const message = this.message(reason, place, origin);

    message.fatal = null;

    return message
  }

  /**
   * Like `VFile#message()`, but associates a fatal message where `fatal` is
   * set to `true`, and then immediately throws it.
   *
   * > 👉 **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string|Error} reason
   *   Human readable reason for the message, uses the stack and message of the error if given.
   * @param {Node|NodeLike|Position|Point} [place]
   *   Place where the message occurred in the file.
   * @param {string} [origin]
   *   Computer readable reason for the message
   * @returns {never}
   *   Message.
   */
  fail(reason, place, origin) {
    const message = this.message(reason, place, origin);

    message.fatal = true;

    throw message
  }
}

/**
 * Assert that `part` is not a path (as in, does not contain `path.sep`).
 *
 * @param {string|undefined} part
 * @param {string} name
 * @returns {void}
 */
function assertPart(part, name) {
  if (part && part.includes(path$1.sep)) {
    throw new Error(
      '`' + name + '` cannot be a path: did not expect `' + path$1.sep + '`'
    )
  }
}

/**
 * Assert that `part` is not empty.
 *
 * @param {string|undefined} part
 * @param {string} name
 * @returns {asserts part is string}
 */
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error('`' + name + '` cannot be empty')
  }
}

/**
 * Assert `path` exists.
 *
 * @param {string|undefined} path
 * @param {string} name
 * @returns {asserts path is string}
 */
function assertPath(path, name) {
  if (!path) {
    throw new Error('Setting `' + name + '` requires `path` to be set too')
  }
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('vfile').VFileCompatible} VFileCompatible
 * @typedef {import('vfile').VFileValue} VFileValue
 * @typedef {import('..').Processor} Processor
 * @typedef {import('..').Plugin} Plugin
 * @typedef {import('..').Preset} Preset
 * @typedef {import('..').Pluggable} Pluggable
 * @typedef {import('..').PluggableList} PluggableList
 * @typedef {import('..').Transformer} Transformer
 * @typedef {import('..').Parser} Parser
 * @typedef {import('..').Compiler} Compiler
 * @typedef {import('..').RunCallback} RunCallback
 * @typedef {import('..').ProcessCallback} ProcessCallback
 *
 * @typedef Context
 * @property {Node} tree
 * @property {VFile} file
 */

// Expose a frozen processor.
const unified = base().freeze();

const own$5 = {}.hasOwnProperty;

// Function to create the first processor.
/**
 * @returns {Processor}
 */
function base() {
  const transformers = trough();
  /** @type {Processor['attachers']} */
  const attachers = [];
  /** @type {Record<string, unknown>} */
  let namespace = {};
  /** @type {boolean|undefined} */
  let frozen;
  let freezeIndex = -1;

  // Data management.
  // @ts-expect-error: overloads are handled.
  processor.data = data;
  processor.Parser = undefined;
  processor.Compiler = undefined;

  // Lock.
  processor.freeze = freeze;

  // Plugins.
  processor.attachers = attachers;
  // @ts-expect-error: overloads are handled.
  processor.use = use;

  // API.
  processor.parse = parse;
  processor.stringify = stringify;
  // @ts-expect-error: overloads are handled.
  processor.run = run;
  processor.runSync = runSync;
  // @ts-expect-error: overloads are handled.
  processor.process = process;
  processor.processSync = processSync;

  // Expose.
  return processor

  // Create a new processor based on the processor in the current scope.
  /** @type {Processor} */
  function processor() {
    const destination = base();
    let index = -1;

    while (++index < attachers.length) {
      destination.use(...attachers[index]);
    }

    destination.data(extend(true, {}, namespace));

    return destination
  }

  /**
   * @param {string|Record<string, unknown>} [key]
   * @param {unknown} [value]
   * @returns {unknown}
   */
  function data(key, value) {
    if (typeof key === 'string') {
      // Set `key`.
      if (arguments.length === 2) {
        assertUnfrozen('data', frozen);
        namespace[key] = value;
        return processor
      }

      // Get `key`.
      return (own$5.call(namespace, key) && namespace[key]) || null
    }

    // Set space.
    if (key) {
      assertUnfrozen('data', frozen);
      namespace = key;
      return processor
    }

    // Get space.
    return namespace
  }

  /** @type {Processor['freeze']} */
  function freeze() {
    if (frozen) {
      return processor
    }

    while (++freezeIndex < attachers.length) {
      const [attacher, ...options] = attachers[freezeIndex];

      if (options[0] === false) {
        continue
      }

      if (options[0] === true) {
        options[0] = undefined;
      }

      /** @type {Transformer|void} */
      const transformer = attacher.call(processor, ...options);

      if (typeof transformer === 'function') {
        transformers.use(transformer);
      }
    }

    frozen = true;
    freezeIndex = Number.POSITIVE_INFINITY;

    return processor
  }

  /**
   * @param {Pluggable|null|undefined} [value]
   * @param {...unknown} options
   * @returns {Processor}
   */
  function use(value, ...options) {
    /** @type {Record<string, unknown>|undefined} */
    let settings;

    assertUnfrozen('use', frozen);

    if (value === null || value === undefined) ; else if (typeof value === 'function') {
      addPlugin(value, ...options);
    } else if (typeof value === 'object') {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError('Expected usable value, not `' + value + '`')
    }

    if (settings) {
      namespace.settings = Object.assign(namespace.settings || {}, settings);
    }

    return processor

    /**
     * @param {import('..').Pluggable<unknown[]>} value
     * @returns {void}
     */
    function add(value) {
      if (typeof value === 'function') {
        addPlugin(value);
      } else if (typeof value === 'object') {
        if (Array.isArray(value)) {
          const [plugin, ...options] = value;
          addPlugin(plugin, ...options);
        } else {
          addPreset(value);
        }
      } else {
        throw new TypeError('Expected usable value, not `' + value + '`')
      }
    }

    /**
     * @param {Preset} result
     * @returns {void}
     */
    function addPreset(result) {
      addList(result.plugins);

      if (result.settings) {
        settings = Object.assign(settings || {}, result.settings);
      }
    }

    /**
     * @param {PluggableList|null|undefined} [plugins]
     * @returns {void}
     */
    function addList(plugins) {
      let index = -1;

      if (plugins === null || plugins === undefined) ; else if (Array.isArray(plugins)) {
        while (++index < plugins.length) {
          const thing = plugins[index];
          add(thing);
        }
      } else {
        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')
      }
    }

    /**
     * @param {Plugin} plugin
     * @param {...unknown} [value]
     * @returns {void}
     */
    function addPlugin(plugin, value) {
      let index = -1;
      /** @type {Processor['attachers'][number]|undefined} */
      let entry;

      while (++index < attachers.length) {
        if (attachers[index][0] === plugin) {
          entry = attachers[index];
          break
        }
      }

      if (entry) {
        if (isPlainObject(entry[1]) && isPlainObject(value)) {
          value = extend(true, entry[1], value);
        }

        entry[1] = value;
      } else {
        // @ts-expect-error: fine.
        attachers.push([...arguments]);
      }
    }
  }

  /** @type {Processor['parse']} */
  function parse(doc) {
    processor.freeze();
    const file = vfile(doc);
    const Parser = processor.Parser;
    assertParser('parse', Parser);

    if (newable(Parser, 'parse')) {
      // @ts-expect-error: `newable` checks this.
      return new Parser(String(file), file).parse()
    }

    // @ts-expect-error: `newable` checks this.
    return Parser(String(file), file) // eslint-disable-line new-cap
  }

  /** @type {Processor['stringify']} */
  function stringify(node, doc) {
    processor.freeze();
    const file = vfile(doc);
    const Compiler = processor.Compiler;
    assertCompiler('stringify', Compiler);
    assertNode(node);

    if (newable(Compiler, 'compile')) {
      // @ts-expect-error: `newable` checks this.
      return new Compiler(node, file).compile()
    }

    // @ts-expect-error: `newable` checks this.
    return Compiler(node, file) // eslint-disable-line new-cap
  }

  /**
   * @param {Node} node
   * @param {VFileCompatible|RunCallback} [doc]
   * @param {RunCallback} [callback]
   * @returns {Promise<Node>|void}
   */
  function run(node, doc, callback) {
    assertNode(node);
    processor.freeze();

    if (!callback && typeof doc === 'function') {
      callback = doc;
      doc = undefined;
    }

    if (!callback) {
      return new Promise(executor)
    }

    executor(null, callback);

    /**
     * @param {null|((node: Node) => void)} resolve
     * @param {(error: Error) => void} reject
     * @returns {void}
     */
    function executor(resolve, reject) {
      // @ts-expect-error: `doc` can’t be a callback anymore, we checked.
      transformers.run(node, vfile(doc), done);

      /**
       * @param {Error|null} error
       * @param {Node} tree
       * @param {VFile} file
       * @returns {void}
       */
      function done(error, tree, file) {
        tree = tree || node;
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(tree);
        } else {
          // @ts-expect-error: `callback` is defined if `resolve` is not.
          callback(null, tree, file);
        }
      }
    }
  }

  /** @type {Processor['runSync']} */
  function runSync(node, file) {
    /** @type {Node|undefined} */
    let result;
    /** @type {boolean|undefined} */
    let complete;

    processor.run(node, file, done);

    assertDone('runSync', 'run', complete);

    // @ts-expect-error: we either bailed on an error or have a tree.
    return result

    /**
     * @param {Error|null} [error]
     * @param {Node} [tree]
     * @returns {void}
     */
    function done(error, tree) {
      bail(error);
      result = tree;
      complete = true;
    }
  }

  /**
   * @param {VFileCompatible} doc
   * @param {ProcessCallback} [callback]
   * @returns {Promise<VFile>|undefined}
   */
  function process(doc, callback) {
    processor.freeze();
    assertParser('process', processor.Parser);
    assertCompiler('process', processor.Compiler);

    if (!callback) {
      return new Promise(executor)
    }

    executor(null, callback);

    /**
     * @param {null|((file: VFile) => void)} resolve
     * @param {(error?: Error|null|undefined) => void} reject
     * @returns {void}
     */
    function executor(resolve, reject) {
      const file = vfile(doc);

      processor.run(processor.parse(file), file, (error, tree, file) => {
        if (error || !tree || !file) {
          done(error);
        } else {
          /** @type {unknown} */
          const result = processor.stringify(tree, file);

          if (result === undefined || result === null) ; else if (looksLikeAVFileValue(result)) {
            file.value = result;
          } else {
            file.result = result;
          }

          done(error, file);
        }
      });

      /**
       * @param {Error|null|undefined} [error]
       * @param {VFile|undefined} [file]
       * @returns {void}
       */
      function done(error, file) {
        if (error || !file) {
          reject(error);
        } else if (resolve) {
          resolve(file);
        } else {
          // @ts-expect-error: `callback` is defined if `resolve` is not.
          callback(null, file);
        }
      }
    }
  }

  /** @type {Processor['processSync']} */
  function processSync(doc) {
    /** @type {boolean|undefined} */
    let complete;

    processor.freeze();
    assertParser('processSync', processor.Parser);
    assertCompiler('processSync', processor.Compiler);

    const file = vfile(doc);

    processor.process(file, done);

    assertDone('processSync', 'process', complete);

    return file

    /**
     * @param {Error|null|undefined} [error]
     * @returns {void}
     */
    function done(error) {
      complete = true;
      bail(error);
    }
  }
}

/**
 * Check if `value` is a constructor.
 *
 * @param {unknown} value
 * @param {string} name
 * @returns {boolean}
 */
function newable(value, name) {
  return (
    typeof value === 'function' &&
    // Prototypes do exist.
    // type-coverage:ignore-next-line
    value.prototype &&
    // A function with keys in its prototype is probably a constructor.
    // Classes’ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    // type-coverage:ignore-next-line
    (keys(value.prototype) || name in value.prototype)
  )
}

/**
 * Check if `value` is an object with keys.
 *
 * @param {Record<string, unknown>} value
 * @returns {boolean}
 */
function keys(value) {
  /** @type {string} */
  let key;

  for (key in value) {
    if (own$5.call(value, key)) {
      return true
    }
  }

  return false
}

/**
 * Assert a parser is available.
 *
 * @param {string} name
 * @param {unknown} value
 * @returns {asserts value is Parser}
 */
function assertParser(name, value) {
  if (typeof value !== 'function') {
    throw new TypeError('Cannot `' + name + '` without `Parser`')
  }
}

/**
 * Assert a compiler is available.
 *
 * @param {string} name
 * @param {unknown} value
 * @returns {asserts value is Compiler}
 */
function assertCompiler(name, value) {
  if (typeof value !== 'function') {
    throw new TypeError('Cannot `' + name + '` without `Compiler`')
  }
}

/**
 * Assert the processor is not frozen.
 *
 * @param {string} name
 * @param {unknown} frozen
 * @returns {asserts frozen is false}
 */
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      'Cannot call `' +
        name +
        '` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'
    )
  }
}

/**
 * Assert `node` is a unist node.
 *
 * @param {unknown} node
 * @returns {asserts node is Node}
 */
function assertNode(node) {
  // `isPlainObj` unfortunately uses `any` instead of `unknown`.
  // type-coverage:ignore-next-line
  if (!isPlainObject(node) || typeof node.type !== 'string') {
    throw new TypeError('Expected node, got `' + node + '`')
    // Fine.
  }
}

/**
 * Assert that `complete` is `true`.
 *
 * @param {string} name
 * @param {string} asyncName
 * @param {unknown} complete
 * @returns {asserts complete is true}
 */
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      '`' + name + '` finished async. Use `' + asyncName + '` instead'
    )
  }
}

/**
 * @param {VFileCompatible} [value]
 * @returns {VFile}
 */
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value)
}

/**
 * @param {VFileCompatible} [value]
 * @returns {value is VFile}
 */
function looksLikeAVFile(value) {
  return Boolean(
    value &&
      typeof value === 'object' &&
      'message' in value &&
      'messages' in value
  )
}

/**
 * @param {unknown} [value]
 * @returns {value is VFileValue}
 */
function looksLikeAVFileValue(value) {
  return typeof value === 'string' || isBuffer(value)
}

var own$4 = {}.hasOwnProperty;

/**
 * @callback Handler
 * @param {...unknown} value
 * @return {unknown}
 *
 * @typedef {Record<string, Handler>} Handlers
 *
 * @typedef {Object} Options
 * @property {Handler} [unknown]
 * @property {Handler} [invalid]
 * @property {Handlers} [handlers]
 */

/**
 * Handle values based on a property.
 *
 * @param {string} key
 * @param {Options} [options]
 */
function zwitch(key, options) {
  var settings = options || {};

  /**
   * Handle one value.
   * Based on the bound `key`, a respective handler will be called.
   * If `value` is not an object, or doesn’t have a `key` property, the special
   * “invalid” handler will be called.
   * If `value` has an unknown `key`, the special “unknown” handler will be
   * called.
   *
   * All arguments, and the context object, are passed through to the handler,
   * and it’s result is returned.
   *
   * @param {...unknown} [value]
   * @this {unknown}
   * @returns {unknown}
   * @property {Handler} invalid
   * @property {Handler} unknown
   * @property {Handlers} handlers
   */
  function one(value) {
    var fn = one.invalid;
    var handlers = one.handlers;

    if (value && own$4.call(value, key)) {
      fn = own$4.call(handlers, value[key]) ? handlers[value[key]] : one.unknown;
    }

    if (fn) {
      return fn.apply(this, arguments)
    }
  }

  one.handlers = settings.handlers || {};
  one.invalid = settings.invalid;
  one.unknown = settings.unknown;

  return one
}

/**
 * @typedef {import('./types.js').Selector} Selector
 * @typedef {import('./types.js').Selectors} Selectors
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').RuleSet} RuleSet
 * @typedef {import('./types.js').RulePseudo} RulePseudo
 * @typedef {import('./types.js').Query} Query
 * @typedef {import('./types.js').Node} Node
 * @typedef {import('./types.js').Parent} Parent
 * @typedef {import('./types.js').SelectIterator} SelectIterator
 * @typedef {import('./types.js').SelectState} SelectState
 */

/**
 * @param {Node} node
 * @returns {node is Parent}
 */
function root$1(node) {
  return (
    // Root in nlcst.
    node.type === 'RootNode' ||
    // Rest
    node.type === 'root'
  )
}

/**
 * @param {Node} node
 * @returns {node is Parent}
 */
function parent(node) {
  // @ts-expect-error: looks like a record.
  return Array.isArray(node.children)
}

/**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').Query} Query
 * @typedef {import('./types.js').Node} Node
 * @typedef {import('./types.js').Parent} Parent
 * @typedef {import('./types.js').SelectState} SelectState
 * @typedef {import('./types.js').SelectIterator} SelectIterator
 * @typedef {import('./types.js').Handler} Handler
 */

const own$3 = {}.hasOwnProperty;

const handle$2 = zwitch('nestingOperator', {
  // @ts-expect-error: hush.
  unknown: unknownNesting,
  // @ts-expect-error: hush.
  invalid: topScan, // `undefined` is the top query selector.
  handlers: {
    // @ts-expect-error: hush.
    null: descendant, // `null` is the descendant combinator.
    // @ts-expect-error: hush.
    '>': child,
    // @ts-expect-error: hush.
    '+': adjacentSibling,
    // @ts-expect-error: hush.
    '~': generalSibling
  }
});

/** @type {Handler} */
const nest = handle$2;

// Shouldn’t be invoked, parser gives correct data.
/* c8 ignore next 6 */
/**
 * @param {{[x: string]: unknown, type: string}} query
 */
function unknownNesting(query) {
  throw new Error('Unexpected nesting `' + query.nestingOperator + '`')
}

/** @type {Handler} */
function topScan(query, node, index, parent, state) {
  // Shouldn’t happen.
  /* c8 ignore next 7 */
  if (parent) {
    throw new Error('topScan is supposed to be called from the root node')
  }

  if (!state.iterator) {
    throw new Error('Expected `iterator` to be defined')
  }

  // Shouldn’t happen.
  /* c8 ignore next 3 */
  if (typeof index !== 'number') {
    throw new TypeError('Expected `index` to be defined')
  }

  state.iterator(query, node, index, parent, state);
  if (!state.shallow) descendant(query, node, index, parent, state);
}

/** @type {Handler} */
function descendant(query, node, index, parent, state) {
  // Shouldn’t happen.
  /* c8 ignore next 3 */
  if (!state.iterator) {
    throw new Error('Expected `iterator` to be defined')
  }

  const previous = state.iterator;

  state.iterator = iterator;
  child(query, node, index, parent, state);

  /** @type {SelectIterator} */
  function iterator(query, node, index, parent, state) {
    state.iterator = previous;
    previous(query, node, index, parent, state);
    state.iterator = iterator;

    if (state.one && state.found) return

    child(query, node, index, parent, state);
  }
}

/** @type {Handler} */
function child(query, node, _1, _2, state) {
  if (!parent(node)) return
  if (node.children.length === 0) return

  new WalkIterator(query, node, state).each().done();
}

/** @type {Handler} */
function adjacentSibling(query, _, index, parent, state) {
  // Shouldn’t happen.
  /* c8 ignore next 3 */
  if (typeof index !== 'number') {
    throw new TypeError('Expected `index` to be defined')
  }

  // Shouldn’t happen.
  /* c8 ignore next */
  if (!parent) return

  new WalkIterator(query, parent, state)
    .prefillTypeIndex(0, ++index)
    .each(index, ++index)
    .prefillTypeIndex(index)
    .done();
}

/** @type {Handler} */
function generalSibling(query, _, index, parent, state) {
  // Shouldn’t happen.
  /* c8 ignore next 3 */
  if (typeof index !== 'number') {
    throw new TypeError('Expected `index` to be defined')
  }

  // Shouldn’t happen.
  /* c8 ignore next */
  if (!parent) return

  new WalkIterator(query, parent, state)
    .prefillTypeIndex(0, ++index)
    .each(index)
    .done();
}

class WalkIterator {
  /**
   * Handles typeIndex and typeCount properties for every walker.
   *
   * @param {Rule} query
   * @param {Parent} parent
   * @param {SelectState} state
   */
  constructor(query, parent, state) {
    /** @type {Rule} */
    this.query = query;
    /** @type {Parent} */
    this.parent = parent;
    /** @type {SelectState} */
    this.state = state;
    /** @type {TypeIndex|undefined} */
    this.typeIndex = state.index ? new TypeIndex() : undefined;
    /** @type {Array.<Function>} */
    this.delayed = [];
  }

  /**
   * @param {number|null|undefined} [x]
   * @param {number|null|undefined} [y]
   * @returns {this}
   */
  prefillTypeIndex(x, y) {
    let [start, end] = this.defaults(x, y);

    if (this.typeIndex) {
      while (start < end) {
        this.typeIndex.index(this.parent.children[start]);
        start++;
      }
    }

    return this
  }

  /**
   * @param {number|null|undefined} [x]
   * @param {number|null|undefined} [y]
   * @returns {this}
   */
  each(x, y) {
    const [start, end] = this.defaults(x, y);
    const child = this.parent.children[start];
    /** @type {number} */
    let index;
    /** @type {number} */
    let nodeIndex;

    if (start >= end) return this

    if (this.typeIndex) {
      nodeIndex = this.typeIndex.nodes;
      index = this.typeIndex.index(child);
      this.delayed.push(delay);
    } else {
      // Shouldn’t happen.
      /* c8 ignore next 3 */
      if (!this.state.iterator) {
        throw new Error('Expected `iterator` to be defined')
      }

      this.state.iterator(this.query, child, start, this.parent, this.state);
    }

    // Stop if we’re looking for one node and it’s already found.
    if (this.state.one && this.state.found) return this

    return this.each(start + 1, end)

    /**
     * @this {WalkIterator}
     */
    function delay() {
      // Shouldn’t happen.
      /* c8 ignore next 3 */
      if (!this.typeIndex) {
        throw new TypeError('Expected `typeIndex` to be defined')
      }

      // Shouldn’t happen.
      /* c8 ignore next 3 */
      if (!this.state.iterator) {
        throw new Error('Expected `iterator` to be defined')
      }

      this.state.typeIndex = index;
      this.state.nodeIndex = nodeIndex;
      this.state.typeCount = this.typeIndex.count(child);
      this.state.nodeCount = this.typeIndex.nodes;
      this.state.iterator(this.query, child, start, this.parent, this.state);
    }
  }

  /**
   * Done!
   * @returns {this}
   */
  done() {
    let index = -1;

    while (++index < this.delayed.length) {
      this.delayed[index].call(this);
      if (this.state.one && this.state.found) break
    }

    return this
  }

  /**
   * @param {number|null|undefined} [start]
   * @param {number|null|undefined} [end]
   * @returns {[number, number]}
   */
  defaults(start, end) {
    if (start === null || start === undefined || start < 0) start = 0;
    if (end === null || end === undefined || end > this.parent.children.length)
      end = this.parent.children.length;
    return [start, end]
  }
}

class TypeIndex {
  constructor() {
    /** @type {Object.<string, number>} */
    this.counts = {};
    /** @type {number} */
    this.nodes = 0;
  }

  /**
   * @param {Node} node
   * @returns {number}
   */
  index(node) {
    const type = node.type;

    this.nodes++;

    if (!own$3.call(this.counts, type)) this.counts[type] = 0;

    // Note: `++` is intended to be postfixed!
    return this.counts[type]++
  }

  /**
   * @param {Node} node
   * @returns {number|undefined}
   */
  count(node) {
    return this.counts[node.type]
  }
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 *
 * @typedef {string} Type
 * @typedef {Object<string, unknown>} Props
 *
 * @typedef {null|undefined|Type|Props|TestFunctionAnything|Array.<Type|Props|TestFunctionAnything>} Test
 */

const convert =
  /**
   * @type {(
   *   (<T extends Node>(test: T['type']|Partial<T>|TestFunctionPredicate<T>) => AssertPredicate<T>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  (
    /**
     * Generate an assertion from a check.
     * @param {Test} [test]
     * When nullish, checks if `node` is a `Node`.
     * When `string`, works like passing `function (node) {return node.type === test}`.
     * When `function` checks if function passed the node is true.
     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
     * When `array`, checks any one of the subtests pass.
     * @returns {AssertAnything}
     */
    function (test) {
      if (test === undefined || test === null) {
        return ok
      }

      if (typeof test === 'string') {
        return typeFactory(test)
      }

      if (typeof test === 'object') {
        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)
      }

      if (typeof test === 'function') {
        return castFactory(test)
      }

      throw new Error('Expected function, string, or object as test')
    }
  );
/**
 * @param {Array.<Type|Props|TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */
function anyFactory(tests) {
  /** @type {Array.<AssertAnything>} */
  const checks = [];
  let index = -1;

  while (++index < tests.length) {
    checks[index] = convert(tests[index]);
  }

  return castFactory(any)

  /**
   * @this {unknown}
   * @param {unknown[]} parameters
   * @returns {boolean}
   */
  function any(...parameters) {
    let index = -1;

    while (++index < checks.length) {
      if (checks[index].call(this, ...parameters)) return true
    }

    return false
  }
}

/**
 * Utility to assert each property in `test` is represented in `node`, and each
 * values are strictly equal.
 *
 * @param {Props} check
 * @returns {AssertAnything}
 */
function propsFactory(check) {
  return castFactory(all)

  /**
   * @param {Node} node
   * @returns {boolean}
   */
  function all(node) {
    /** @type {string} */
    let key;

    for (key in check) {
      // @ts-expect-error: hush, it sure works as an index.
      if (node[key] !== check[key]) return false
    }

    return true
  }
}

/**
 * Utility to convert a string into a function which checks a given node’s type
 * for said string.
 *
 * @param {Type} check
 * @returns {AssertAnything}
 */
function typeFactory(check) {
  return castFactory(type)

  /**
   * @param {Node} node
   */
  function type(node) {
    return node && node.type === check
  }
}

/**
 * Utility to convert a string into a function which checks a given node’s type
 * for said string.
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */
function castFactory(check) {
  return assertion

  /**
   * @this {unknown}
   * @param {Array.<unknown>} parameters
   * @returns {boolean}
   */
  function assertion(...parameters) {
    // @ts-expect-error: spreading is fine.
    return Boolean(check.call(this, ...parameters))
  }
}

// Utility to return true.
function ok() {
  return true
}

/**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').RulePseudo} RulePseudo
 * @typedef {import('./types.js').RulePseudoNth} RulePseudoNth
 * @typedef {import('./types.js').RulePseudoSelector} RulePseudoSelector
 * @typedef {import('./types.js').Parent} Parent
 * @typedef {import('./types.js').Selector} Selector
 * @typedef {import('./types.js').Selectors} Selectors
 * @typedef {import('./types.js').SelectState} SelectState
 * @typedef {import('./types.js').Node} Node
 */

const is = convert();

const handle$1 = zwitch('name', {
  // @ts-expect-error: hush.
  unknown: unknownPseudo,
  invalid: invalidPseudo,
  handlers: {
    // @ts-expect-error: hush.
    any: matches,
    // @ts-expect-error: hush.
    blank: empty,
    // @ts-expect-error: hush.
    empty,
    // @ts-expect-error: hush.
    'first-child': firstChild,
    // @ts-expect-error: hush.
    'first-of-type': firstOfType,
    // @ts-expect-error: hush.
    has: hasSelector,
    // @ts-expect-error: hush.
    'last-child': lastChild,
    // @ts-expect-error: hush.
    'last-of-type': lastOfType,
    // @ts-expect-error: hush.
    matches,
    // @ts-expect-error: hush.
    not,
    // @ts-expect-error: hush.
    'nth-child': nthChild,
    // @ts-expect-error: hush.
    'nth-last-child': nthLastChild,
    // @ts-expect-error: hush.
    'nth-of-type': nthOfType,
    // @ts-expect-error: hush.
    'nth-last-of-type': nthLastOfType,
    // @ts-expect-error: hush.
    'only-child': onlyChild,
    // @ts-expect-error: hush.
    'only-of-type': onlyOfType,
    // @ts-expect-error: hush.
    root,
    // @ts-expect-error: hush.
    scope
  }
});

pseudo.needsIndex = [
  'first-child',
  'first-of-type',
  'last-child',
  'last-of-type',
  'nth-child',
  'nth-last-child',
  'nth-of-type',
  'nth-last-of-type',
  'only-child',
  'only-of-type'
];

/**
 * @param {Rule} query
 * @param {Node} node
 * @param {number|null} index
 * @param {Parent|null} parent
 * @param {SelectState} state
 * @returns {boolean}
 */
function pseudo(query, node, index, parent, state) {
  const pseudos = query.pseudos;
  let offset = -1;

  while (++offset < pseudos.length) {
    if (!handle$1(pseudos[offset], node, index, parent, state)) return false
  }

  return true
}

/**
 * @param {RulePseudoSelector} query
 * @param {Node} node
 * @param {number|null} _1
 * @param {Parent|null} _2
 * @param {SelectState} state
 * @returns {boolean}
 */
function matches(query, node, _1, _2, state) {
  const shallow = state.shallow;
  const one = state.one;

  state.one = true;
  state.shallow = true;

  const result = state.any(query.value, node, state)[0] === node;

  state.shallow = shallow;
  state.one = one;

  return result
}

/**
 * @param {RulePseudoSelector} query
 * @param {Node} node
 * @param {number|null} index
 * @param {Parent|null} parent
 * @param {SelectState} state
 * @returns {boolean}
 */
function not(query, node, index, parent, state) {
  return !matches(query, node, index, parent, state)
}

/**
 * @param {RulePseudo} _1
 * @param {Node} node
 * @param {number|null} _2
 * @param {Parent|null} parent
 * @returns {boolean}
 */
function root(_1, node, _2, parent) {
  return is(node) && !parent
}

/**
 * @param {RulePseudo} _1
 * @param {Node} node
 * @param {number|null} _2
 * @param {Parent|null} _3
 * @param {SelectState} state
 * @returns {boolean}
 */
function scope(_1, node, _2, _3, state) {
  return (
    is(node) &&
    state.scopeNodes !== undefined &&
    state.scopeNodes.includes(node)
  )
}

/**
 * @param {RulePseudo} _1
 * @param {Node} node
 * @returns {boolean}
 */
function empty(_1, node) {
  return parent(node) ? node.children.length === 0 : !('value' in node)
}

/**
 * @param {RulePseudo} query
 * @param {Node} _1
 * @param {number|null} _2
 * @param {Parent|null} _3
 * @param {SelectState} state
 * @returns {boolean}
 */
function firstChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.nodeIndex === 0 // Specifically `0`, not falsey.
}

/**
 * @param {RulePseudo} query
 * @param {Node} _1
 * @param {number|null} _2
 * @param {Parent|null} _3
 * @param {SelectState} state
 * @returns {boolean}
 */
function lastChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return (
    typeof state.nodeCount === 'number' &&
    state.nodeIndex === state.nodeCount - 1
  )
}

/**
 * @param {RulePseudo} query
 * @param {Node} _1
 * @param {number|null} _2
 * @param {Parent|null} _3
 * @param {SelectState} state
 * @returns {boolean}
 */
function onlyChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.nodeCount === 1
}

/**
 * @param {RulePseudoNth} query
 * @param {Node} _1
 * @param {number|null} _2
 * @param {Parent|null} _3
 * @param {SelectState} state
 * @returns {boolean}
 */
function nthChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return typeof state.nodeIndex === 'number' && query.value(state.nodeIndex)
}

/**
 * @param {RulePseudoNth} query
 * @param {Node} _1
 * @param {number|null} _2
 * @param {Parent|null} _3
 * @param {SelectState} state
 * @returns {boolean}
 */
function nthLastChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return (
    typeof state.nodeCount === 'number' &&
    typeof state.nodeIndex === 'number' &&
    query.value(state.nodeCount - state.nodeIndex - 1)
  )
}

/**
 * @param {RulePseudoNth} query
 * @param {Node} _1
 * @param {number|null} _2
 * @param {Parent|null} _3
 * @param {SelectState} state
 * @returns {boolean}
 */
function nthOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return typeof state.typeIndex === 'number' && query.value(state.typeIndex)
}

/**
 * @param {RulePseudoNth} query
 * @param {Node} _1
 * @param {number|null} _2
 * @param {Parent|null} _3
 * @param {SelectState} state
 * @returns {boolean}
 */
function nthLastOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return (
    typeof state.typeIndex === 'number' &&
    typeof state.typeCount === 'number' &&
    query.value(state.typeCount - 1 - state.typeIndex)
  )
}

/**
 * @param {RulePseudo} query
 * @param {Node} _1
 * @param {number|null} _2
 * @param {Parent|null} _3
 * @param {SelectState} state
 * @returns {boolean}
 */
function firstOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.typeIndex === 0
}

/**
 * @param {RulePseudo} query
 * @param {Node} _1
 * @param {number|null} _2
 * @param {Parent|null} _3
 * @param {SelectState} state
 * @returns {boolean}
 */
function lastOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return (
    typeof state.typeCount === 'number' &&
    state.typeIndex === state.typeCount - 1
  )
}

/**
 * @param {RulePseudo} query
 * @param {Node} _1
 * @param {number|null} _2
 * @param {Parent|null} _3
 * @param {SelectState} state
 * @returns {boolean}
 */
function onlyOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.typeCount === 1
}

// Shouldn’t be invoked, parser gives correct data.
/* c8 ignore next 3 */
function invalidPseudo() {
  throw new Error('Invalid pseudo-selector')
}

/**
 * @param {RulePseudo} query
 * @returns {boolean}
 */
function unknownPseudo(query) {
  if (query.name) {
    throw new Error('Unknown pseudo-selector `' + query.name + '`')
  }

  throw new Error('Unexpected pseudo-element or empty pseudo-class')
}

/**
 * @param {SelectState} state
 * @param {RulePseudo|RulePseudoNth} query
 */
function assertDeep(state, query) {
  if (state.shallow) {
    throw new Error('Cannot use `:' + query.name + '` without parent')
  }
}

/**
 * @param {RulePseudoSelector} query
 * @param {Node} node
 * @param {number|null} _1
 * @param {Parent|null} _2
 * @param {SelectState} state
 * @returns {boolean}
 */
function hasSelector(query, node, _1, _2, state) {
  const shallow = state.shallow;
  const one = state.one;
  const scopeNodes = state.scopeNodes;
  const value = appendScope(query.value);
  const anything = state.any;

  state.shallow = false;
  state.one = true;
  state.scopeNodes = [node];

  const result = Boolean(anything(value, node, state)[0]);

  state.shallow = shallow;
  state.one = one;
  state.scopeNodes = scopeNodes;

  return result
}

/**
 * @param {Selector} value
 */
function appendScope(value) {
  /** @type {Selectors} */
  const selector =
    value.type === 'ruleSet' ? {type: 'selectors', selectors: [value]} : value;
  let index = -1;
  /** @type {Rule} */
  let rule;

  while (++index < selector.selectors.length) {
    rule = selector.selectors[index].rule;
    rule.nestingOperator = null;

    // Needed if new pseudo’s are added that accepts commas (such as
    // `:lang(en, nl)`)
    /* c8 ignore else */
    if (
      !rule.pseudos ||
      rule.pseudos.length !== 1 ||
      rule.pseudos[0].name !== 'scope'
    ) {
      selector.selectors[index] = {
        type: 'ruleSet',
        rule: {
          type: 'rule',
          rule,
          // @ts-expect-error pseudos are fine w/ just a name!
          pseudos: [{name: 'scope'}]
        }
      };
    }
  }

  return selector
}

/**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').RuleAttr} RuleAttr
 * @typedef {import('./types.js').Node} Node
 */

const handle = zwitch('operator', {
  // @ts-expect-error: hush.
  unknown: unknownOperator,
  // @ts-expect-error: hush.
  invalid: exists,
  handlers: {
    // @ts-expect-error: hush.
    '=': exact,
    // @ts-expect-error: hush.
    '^=': begins,
    // @ts-expect-error: hush.
    '$=': ends,
    // @ts-expect-error: hush.
    '*=': containsString,
    // @ts-expect-error: hush.
    '~=': containsArray
  }
});

/**
 * @param {Rule} query
 * @param {Node} node
 */
function attribute(query, node) {
  let index = -1;

  while (++index < query.attrs.length) {
    if (!handle(query.attrs[index], node)) return false
  }

  return true
}

/**
 * `[attr]`
 *
 * @param {RuleAttr} query
 * @param {Node} node
 */
function exists(query, node) {
  // @ts-expect-error: Looks like a record.
  return node[query.name] !== null && node[query.name] !== undefined
}

/**
 * `[attr=value]`
 *
 * @param {RuleAttr} query
 * @param {Node} node
 */
function exact(query, node) {
  // @ts-expect-error: Looks like a record.
  return exists(query, node) && String(node[query.name]) === query.value
}

/**
 * `[attr~=value]`
 *
 * @param {RuleAttr} query
 * @param {Node} node
 */
function containsArray(query, node) {
  /** @type {unknown} */
  // @ts-expect-error: Looks like a record.
  const value = node[query.name];

  if (value === null || value === undefined) return false

  // If this is an array, and the query is contained in it, return true.
  // Coverage comment in place because TS turns `Array.isArray(unknown)`
  // into `Array.<any>` instead of `Array.<unknown>`.
  // type-coverage:ignore-next-line
  if (Array.isArray(value) && value.includes(query.value)) {
    return true
  }

  // For all other values, return whether this is an exact match.
  return String(value) === query.value
}

/**
 * `[attr^=value]`
 *
 * @param {RuleAttr} query
 * @param {Node} node
 */
function begins(query, node) {
  /** @type {unknown} */
  // @ts-expect-error: Looks like a record.
  const value = node[query.name];

  return (
    query.value &&
    typeof value === 'string' &&
    value.slice(0, query.value.length) === query.value
  )
}

/**
 * `[attr$=value]`
 *
 * @param {RuleAttr} query
 * @param {Node} node
 */
function ends(query, node) {
  /** @type {unknown} */
  // @ts-expect-error: Looks like a record.
  const value = node[query.name];

  return (
    query.value &&
    typeof value === 'string' &&
    value.slice(-query.value.length) === query.value
  )
}

/**
 * `[attr*=value]`
 *
 * @param {RuleAttr} query
 * @param {Node} node
 */
function containsString(query, node) {
  /** @type {unknown} */
  // @ts-expect-error: Looks like a record.
  const value = node[query.name];
  return query.value && typeof value === 'string' && value.includes(query.value)
}

// Shouldn’t be invoked, Parser throws an error instead.
/* c8 ignore next 6 */
/**
 * @param {{[x: string]: unknown, type: string}} query
 */
function unknownOperator(query) {
  throw new Error('Unknown operator `' + query.operator + '`')
}

/**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').Node} Node
 */

/**
 * @param {Rule} query
 * @param {Node} node
 */
function name(query, node) {
  return query.tagName === '*' || query.tagName === node.type
}

/**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').Node} Node
 * @typedef {import('./types.js').Parent} Parent
 * @typedef {import('./types.js').SelectState} SelectState
 */

/**
 * @param {Rule} query
 * @param {Node} node
 * @param {number|null} index
 * @param {Parent|null} parent
 * @param {SelectState} state
 * @returns {boolean}
 */
function test(query, node, index, parent, state) {
  if (query.id) throw new Error('Invalid selector: id')
  if (query.classNames) throw new Error('Invalid selector: class')

  return Boolean(
    node &&
      (!query.tagName || name(query, node)) &&
      (!query.attrs || attribute(query, node)) &&
      (!query.pseudos || pseudo(query, node, index, parent, state))
  )
}

/**
 * @typedef {import('./types.js').Selector} Selector
 * @typedef {import('./types.js').Selectors} Selectors
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').RuleSet} RuleSet
 * @typedef {import('./types.js').RulePseudo} RulePseudo
 * @typedef {import('./types.js').Query} Query
 * @typedef {import('./types.js').Node} Node
 * @typedef {import('./types.js').Parent} Parent
 * @typedef {import('./types.js').SelectIterator} SelectIterator
 * @typedef {import('./types.js').SelectState} SelectState
 */

const type = zwitch('type', {
  // @ts-expect-error: hush.
  unknown: unknownType,
  invalid: invalidType,
  // @ts-expect-error: hush.
  handlers: {selectors: selectors$1, ruleSet: ruleSet$1, rule: rule$1}
});

/**
 * @param {Selectors|RuleSet|Rule} query
 * @param {Node|undefined} node
 * @param {SelectState} state
 * @returns {Array.<Node>}
 */
function any(query, node, state) {
  // @ts-expect-error: fine.
  return query && node ? type(query, node, state) : []
}

/**
 * @param {Selectors} query
 * @param {Node} node
 * @param {SelectState} state
 */
function selectors$1(query, node, state) {
  const collect = collector(state.one);
  let index = -1;

  while (++index < query.selectors.length) {
    collect(ruleSet$1(query.selectors[index], node, state));
  }

  return collect.result
}

/**
 * @param {RuleSet} query
 * @param {Node} node
 * @param {SelectState} state
 */
function ruleSet$1(query, node, state) {
  return rule$1(query.rule, node, state)
}

/**
 * @param {Rule} query
 * @param {Node} tree
 * @param {SelectState} state
 */
function rule$1(query, tree, state) {
  const collect = collector(state.one);

  if (state.shallow && query.rule) {
    throw new Error('Expected selector without nesting')
  }

  nest(
    query,
    tree,
    0,
    null,
    configure$1(query, {
      scopeNodes: root$1(tree) ? tree.children : [tree],
      index: false,
      iterator,
      one: state.one,
      shallow: state.shallow,
      any: state.any
    })
  );

  return collect.result

  /** @type {SelectIterator} */
  function iterator(query, node, index, parent, state) {
    if (test(query, node, index, parent, state)) {
      if (query.rule) {
        nest(query.rule, node, index, parent, configure$1(query.rule, state));
      } else {
        collect(node);
        state.found = true;
      }
    }
  }
}

/**
 * @template {SelectState} S
 * @param {Rule} query
 * @param {S} state
 * @returns {S}
 */
function configure$1(query, state) {
  const pseudos = query.pseudos || [];
  let index = -1;

  while (++index < pseudos.length) {
    if (pseudo.needsIndex.includes(pseudos[index].name)) {
      state.index = true;
      break
    }
  }

  return state
}

// Shouldn’t be invoked, all data is handled.
/* c8 ignore next 6 */
/**
 * @param {{[x: string]: unknown, type: string}} query
 */
function unknownType(query) {
  throw new Error('Unknown type `' + query.type + '`')
}

// Shouldn’t be invoked, parser gives correct data.
/* c8 ignore next 3 */
function invalidType() {
  throw new Error('Invalid type')
}

/**
 * @param {boolean|undefined} one
 */
function collector(one) {
  /** @type {Array.<Node>} */
  const result = [];
  /** @type {boolean} */
  let found;

  collect.result = result;

  return collect

  /**
   * Append nodes to array, filtering out duplicates.
   *
   * @param {Node|Array.<Node>} node
   */
  function collect(node) {
    let index = -1;

    if ('length' in node) {
      while (++index < node.length) {
        collectOne(node[index]);
      }
    } else {
      collectOne(node);
    }
  }

  /**
   * @param {Node} node
   */
  function collectOne(node) {
    if (one) {
      /* Shouldn’t happen, safeguards performance problems. */
      /* c8 ignore next */
      if (found) throw new Error('Cannot collect multiple nodes')

      found = true;
    }

    if (!result.includes(node)) result.push(node);
  }
}

var lib = {};

var parserContext = {};

var utils = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
function isIdentStart(c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c === '-') || (c === '_');
}
exports.isIdentStart = isIdentStart;
function isIdent(c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c === '-' || c === '_';
}
exports.isIdent = isIdent;
function isHex(c) {
    return (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F') || (c >= '0' && c <= '9');
}
exports.isHex = isHex;
function escapeIdentifier(s) {
    var len = s.length;
    var result = '';
    var i = 0;
    while (i < len) {
        var chr = s.charAt(i);
        if (exports.identSpecialChars[chr]) {
            result += '\\' + chr;
        }
        else {
            if (!(chr === '_' || chr === '-' ||
                (chr >= 'A' && chr <= 'Z') ||
                (chr >= 'a' && chr <= 'z') ||
                (i !== 0 && chr >= '0' && chr <= '9'))) {
                var charCode = chr.charCodeAt(0);
                if ((charCode & 0xF800) === 0xD800) {
                    var extraCharCode = s.charCodeAt(i++);
                    if ((charCode & 0xFC00) !== 0xD800 || (extraCharCode & 0xFC00) !== 0xDC00) {
                        throw Error('UCS-2(decode): illegal sequence');
                    }
                    charCode = ((charCode & 0x3FF) << 10) + (extraCharCode & 0x3FF) + 0x10000;
                }
                result += '\\' + charCode.toString(16) + ' ';
            }
            else {
                result += chr;
            }
        }
        i++;
    }
    return result;
}
exports.escapeIdentifier = escapeIdentifier;
function escapeStr(s) {
    var len = s.length;
    var result = '';
    var i = 0;
    var replacement;
    while (i < len) {
        var chr = s.charAt(i);
        if (chr === '"') {
            chr = '\\"';
        }
        else if (chr === '\\') {
            chr = '\\\\';
        }
        else if ((replacement = exports.strReplacementsRev[chr]) !== undefined) {
            chr = replacement;
        }
        result += chr;
        i++;
    }
    return "\"" + result + "\"";
}
exports.escapeStr = escapeStr;
exports.identSpecialChars = {
    '!': true,
    '"': true,
    '#': true,
    '$': true,
    '%': true,
    '&': true,
    '\'': true,
    '(': true,
    ')': true,
    '*': true,
    '+': true,
    ',': true,
    '.': true,
    '/': true,
    ';': true,
    '<': true,
    '=': true,
    '>': true,
    '?': true,
    '@': true,
    '[': true,
    '\\': true,
    ']': true,
    '^': true,
    '`': true,
    '{': true,
    '|': true,
    '}': true,
    '~': true
};
exports.strReplacementsRev = {
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t',
    '\f': '\\f',
    '\v': '\\v'
};
exports.singleQuoteEscapeChars = {
    n: '\n',
    r: '\r',
    t: '\t',
    f: '\f',
    '\\': '\\',
    '\'': '\''
};
exports.doubleQuotesEscapeChars = {
    n: '\n',
    r: '\r',
    t: '\t',
    f: '\f',
    '\\': '\\',
    '"': '"'
};
}(utils));

Object.defineProperty(parserContext, "__esModule", { value: true });
var utils_1$1 = utils;
function parseCssSelector(str, pos, pseudos, attrEqualityMods, ruleNestingOperators, substitutesEnabled) {
    var l = str.length;
    var chr = '';
    function getStr(quote, escapeTable) {
        var result = '';
        pos++;
        chr = str.charAt(pos);
        while (pos < l) {
            if (chr === quote) {
                pos++;
                return result;
            }
            else if (chr === '\\') {
                pos++;
                chr = str.charAt(pos);
                var esc = void 0;
                if (chr === quote) {
                    result += quote;
                }
                else if ((esc = escapeTable[chr]) !== undefined) {
                    result += esc;
                }
                else if (utils_1$1.isHex(chr)) {
                    var hex = chr;
                    pos++;
                    chr = str.charAt(pos);
                    while (utils_1$1.isHex(chr)) {
                        hex += chr;
                        pos++;
                        chr = str.charAt(pos);
                    }
                    if (chr === ' ') {
                        pos++;
                        chr = str.charAt(pos);
                    }
                    result += String.fromCharCode(parseInt(hex, 16));
                    continue;
                }
                else {
                    result += chr;
                }
            }
            else {
                result += chr;
            }
            pos++;
            chr = str.charAt(pos);
        }
        return result;
    }
    function getIdent() {
        var result = '';
        chr = str.charAt(pos);
        while (pos < l) {
            if (utils_1$1.isIdent(chr)) {
                result += chr;
            }
            else if (chr === '\\') {
                pos++;
                if (pos >= l) {
                    throw Error('Expected symbol but end of file reached.');
                }
                chr = str.charAt(pos);
                if (utils_1$1.identSpecialChars[chr]) {
                    result += chr;
                }
                else if (utils_1$1.isHex(chr)) {
                    var hex = chr;
                    pos++;
                    chr = str.charAt(pos);
                    while (utils_1$1.isHex(chr)) {
                        hex += chr;
                        pos++;
                        chr = str.charAt(pos);
                    }
                    if (chr === ' ') {
                        pos++;
                        chr = str.charAt(pos);
                    }
                    result += String.fromCharCode(parseInt(hex, 16));
                    continue;
                }
                else {
                    result += chr;
                }
            }
            else {
                return result;
            }
            pos++;
            chr = str.charAt(pos);
        }
        return result;
    }
    function skipWhitespace() {
        chr = str.charAt(pos);
        var result = false;
        while (chr === ' ' || chr === "\t" || chr === "\n" || chr === "\r" || chr === "\f") {
            result = true;
            pos++;
            chr = str.charAt(pos);
        }
        return result;
    }
    function parse() {
        var res = parseSelector();
        if (pos < l) {
            throw Error('Rule expected but "' + str.charAt(pos) + '" found.');
        }
        return res;
    }
    function parseSelector() {
        var selector = parseSingleSelector();
        if (!selector) {
            return null;
        }
        var res = selector;
        chr = str.charAt(pos);
        while (chr === ',') {
            pos++;
            skipWhitespace();
            if (res.type !== 'selectors') {
                res = {
                    type: 'selectors',
                    selectors: [selector]
                };
            }
            selector = parseSingleSelector();
            if (!selector) {
                throw Error('Rule expected after ",".');
            }
            res.selectors.push(selector);
        }
        return res;
    }
    function parseSingleSelector() {
        skipWhitespace();
        var selector = {
            type: 'ruleSet'
        };
        var rule = parseRule();
        if (!rule) {
            return null;
        }
        var currentRule = selector;
        while (rule) {
            rule.type = 'rule';
            currentRule.rule = rule;
            currentRule = rule;
            skipWhitespace();
            chr = str.charAt(pos);
            if (pos >= l || chr === ',' || chr === ')') {
                break;
            }
            if (ruleNestingOperators[chr]) {
                var op = chr;
                pos++;
                skipWhitespace();
                rule = parseRule();
                if (!rule) {
                    throw Error('Rule expected after "' + op + '".');
                }
                rule.nestingOperator = op;
            }
            else {
                rule = parseRule();
                if (rule) {
                    rule.nestingOperator = null;
                }
            }
        }
        return selector;
    }
    // @ts-ignore no-overlap
    function parseRule() {
        var rule = null;
        while (pos < l) {
            chr = str.charAt(pos);
            if (chr === '*') {
                pos++;
                (rule = rule || {}).tagName = '*';
            }
            else if (utils_1$1.isIdentStart(chr) || chr === '\\') {
                (rule = rule || {}).tagName = getIdent();
            }
            else if (chr === '.') {
                pos++;
                rule = rule || {};
                (rule.classNames = rule.classNames || []).push(getIdent());
            }
            else if (chr === '#') {
                pos++;
                (rule = rule || {}).id = getIdent();
            }
            else if (chr === '[') {
                pos++;
                skipWhitespace();
                var attr = {
                    name: getIdent()
                };
                skipWhitespace();
                // @ts-ignore
                if (chr === ']') {
                    pos++;
                }
                else {
                    var operator = '';
                    if (attrEqualityMods[chr]) {
                        operator = chr;
                        pos++;
                        chr = str.charAt(pos);
                    }
                    if (pos >= l) {
                        throw Error('Expected "=" but end of file reached.');
                    }
                    if (chr !== '=') {
                        throw Error('Expected "=" but "' + chr + '" found.');
                    }
                    attr.operator = operator + '=';
                    pos++;
                    skipWhitespace();
                    var attrValue = '';
                    attr.valueType = 'string';
                    // @ts-ignore
                    if (chr === '"') {
                        attrValue = getStr('"', utils_1$1.doubleQuotesEscapeChars);
                        // @ts-ignore
                    }
                    else if (chr === '\'') {
                        attrValue = getStr('\'', utils_1$1.singleQuoteEscapeChars);
                        // @ts-ignore
                    }
                    else if (substitutesEnabled && chr === '$') {
                        pos++;
                        attrValue = getIdent();
                        attr.valueType = 'substitute';
                    }
                    else {
                        while (pos < l) {
                            if (chr === ']') {
                                break;
                            }
                            attrValue += chr;
                            pos++;
                            chr = str.charAt(pos);
                        }
                        attrValue = attrValue.trim();
                    }
                    skipWhitespace();
                    if (pos >= l) {
                        throw Error('Expected "]" but end of file reached.');
                    }
                    if (chr !== ']') {
                        throw Error('Expected "]" but "' + chr + '" found.');
                    }
                    pos++;
                    attr.value = attrValue;
                }
                rule = rule || {};
                (rule.attrs = rule.attrs || []).push(attr);
            }
            else if (chr === ':') {
                pos++;
                var pseudoName = getIdent();
                var pseudo = {
                    name: pseudoName
                };
                // @ts-ignore
                if (chr === '(') {
                    pos++;
                    var value = '';
                    skipWhitespace();
                    if (pseudos[pseudoName] === 'selector') {
                        pseudo.valueType = 'selector';
                        value = parseSelector();
                    }
                    else {
                        pseudo.valueType = pseudos[pseudoName] || 'string';
                        // @ts-ignore
                        if (chr === '"') {
                            value = getStr('"', utils_1$1.doubleQuotesEscapeChars);
                            // @ts-ignore
                        }
                        else if (chr === '\'') {
                            value = getStr('\'', utils_1$1.singleQuoteEscapeChars);
                            // @ts-ignore
                        }
                        else if (substitutesEnabled && chr === '$') {
                            pos++;
                            value = getIdent();
                            pseudo.valueType = 'substitute';
                        }
                        else {
                            while (pos < l) {
                                if (chr === ')') {
                                    break;
                                }
                                value += chr;
                                pos++;
                                chr = str.charAt(pos);
                            }
                            value = value.trim();
                        }
                        skipWhitespace();
                    }
                    if (pos >= l) {
                        throw Error('Expected ")" but end of file reached.');
                    }
                    if (chr !== ')') {
                        throw Error('Expected ")" but "' + chr + '" found.');
                    }
                    pos++;
                    pseudo.value = value;
                }
                rule = rule || {};
                (rule.pseudos = rule.pseudos || []).push(pseudo);
            }
            else {
                break;
            }
        }
        return rule;
    }
    return parse();
}
parserContext.parseCssSelector = parseCssSelector;

var render = {};

Object.defineProperty(render, "__esModule", { value: true });
var utils_1 = utils;
function renderEntity(entity) {
    var res = '';
    switch (entity.type) {
        case 'ruleSet':
            var currentEntity = entity.rule;
            var parts = [];
            while (currentEntity) {
                if (currentEntity.nestingOperator) {
                    parts.push(currentEntity.nestingOperator);
                }
                parts.push(renderEntity(currentEntity));
                currentEntity = currentEntity.rule;
            }
            res = parts.join(' ');
            break;
        case 'selectors':
            res = entity.selectors.map(renderEntity).join(', ');
            break;
        case 'rule':
            if (entity.tagName) {
                if (entity.tagName === '*') {
                    res = '*';
                }
                else {
                    res = utils_1.escapeIdentifier(entity.tagName);
                }
            }
            if (entity.id) {
                res += "#" + utils_1.escapeIdentifier(entity.id);
            }
            if (entity.classNames) {
                res += entity.classNames.map(function (cn) {
                    return "." + (utils_1.escapeIdentifier(cn));
                }).join('');
            }
            if (entity.attrs) {
                res += entity.attrs.map(function (attr) {
                    if ('operator' in attr) {
                        if (attr.valueType === 'substitute') {
                            return "[" + utils_1.escapeIdentifier(attr.name) + attr.operator + "$" + attr.value + "]";
                        }
                        else {
                            return "[" + utils_1.escapeIdentifier(attr.name) + attr.operator + utils_1.escapeStr(attr.value) + "]";
                        }
                    }
                    else {
                        return "[" + utils_1.escapeIdentifier(attr.name) + "]";
                    }
                }).join('');
            }
            if (entity.pseudos) {
                res += entity.pseudos.map(function (pseudo) {
                    if (pseudo.valueType) {
                        if (pseudo.valueType === 'selector') {
                            return ":" + utils_1.escapeIdentifier(pseudo.name) + "(" + renderEntity(pseudo.value) + ")";
                        }
                        else if (pseudo.valueType === 'substitute') {
                            return ":" + utils_1.escapeIdentifier(pseudo.name) + "($" + pseudo.value + ")";
                        }
                        else if (pseudo.valueType === 'numeric') {
                            return ":" + utils_1.escapeIdentifier(pseudo.name) + "(" + pseudo.value + ")";
                        }
                        else {
                            return (":" + utils_1.escapeIdentifier(pseudo.name) +
                                "(" + utils_1.escapeIdentifier(pseudo.value) + ")");
                        }
                    }
                    else {
                        return ":" + utils_1.escapeIdentifier(pseudo.name);
                    }
                }).join('');
            }
            break;
        default:
            throw Error('Unknown entity type: "' + entity.type + '".');
    }
    return res;
}
render.renderEntity = renderEntity;

Object.defineProperty(lib, "__esModule", { value: true });
var parser_context_1 = parserContext;
var render_1 = render;
var CssSelectorParser = /** @class */ (function () {
    function CssSelectorParser() {
        this.pseudos = {};
        this.attrEqualityMods = {};
        this.ruleNestingOperators = {};
        this.substitutesEnabled = false;
    }
    CssSelectorParser.prototype.registerSelectorPseudos = function () {
        var pseudos = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pseudos[_i] = arguments[_i];
        }
        for (var _a = 0, pseudos_1 = pseudos; _a < pseudos_1.length; _a++) {
            var pseudo = pseudos_1[_a];
            this.pseudos[pseudo] = 'selector';
        }
        return this;
    };
    CssSelectorParser.prototype.unregisterSelectorPseudos = function () {
        var pseudos = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pseudos[_i] = arguments[_i];
        }
        for (var _a = 0, pseudos_2 = pseudos; _a < pseudos_2.length; _a++) {
            var pseudo = pseudos_2[_a];
            delete this.pseudos[pseudo];
        }
        return this;
    };
    CssSelectorParser.prototype.registerNumericPseudos = function () {
        var pseudos = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pseudos[_i] = arguments[_i];
        }
        for (var _a = 0, pseudos_3 = pseudos; _a < pseudos_3.length; _a++) {
            var pseudo = pseudos_3[_a];
            this.pseudos[pseudo] = 'numeric';
        }
        return this;
    };
    CssSelectorParser.prototype.unregisterNumericPseudos = function () {
        var pseudos = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pseudos[_i] = arguments[_i];
        }
        for (var _a = 0, pseudos_4 = pseudos; _a < pseudos_4.length; _a++) {
            var pseudo = pseudos_4[_a];
            delete this.pseudos[pseudo];
        }
        return this;
    };
    CssSelectorParser.prototype.registerNestingOperators = function () {
        var operators = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operators[_i] = arguments[_i];
        }
        for (var _a = 0, operators_1 = operators; _a < operators_1.length; _a++) {
            var operator = operators_1[_a];
            this.ruleNestingOperators[operator] = true;
        }
        return this;
    };
    CssSelectorParser.prototype.unregisterNestingOperators = function () {
        var operators = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operators[_i] = arguments[_i];
        }
        for (var _a = 0, operators_2 = operators; _a < operators_2.length; _a++) {
            var operator = operators_2[_a];
            delete this.ruleNestingOperators[operator];
        }
        return this;
    };
    CssSelectorParser.prototype.registerAttrEqualityMods = function () {
        var mods = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            mods[_i] = arguments[_i];
        }
        for (var _a = 0, mods_1 = mods; _a < mods_1.length; _a++) {
            var mod = mods_1[_a];
            this.attrEqualityMods[mod] = true;
        }
        return this;
    };
    CssSelectorParser.prototype.unregisterAttrEqualityMods = function () {
        var mods = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            mods[_i] = arguments[_i];
        }
        for (var _a = 0, mods_2 = mods; _a < mods_2.length; _a++) {
            var mod = mods_2[_a];
            delete this.attrEqualityMods[mod];
        }
        return this;
    };
    CssSelectorParser.prototype.enableSubstitutes = function () {
        this.substitutesEnabled = true;
        return this;
    };
    CssSelectorParser.prototype.disableSubstitutes = function () {
        this.substitutesEnabled = false;
        return this;
    };
    CssSelectorParser.prototype.parse = function (str) {
        return parser_context_1.parseCssSelector(str, 0, this.pseudos, this.attrEqualityMods, this.ruleNestingOperators, this.substitutesEnabled);
    };
    CssSelectorParser.prototype.render = function (path) {
        return render_1.renderEntity(path).trim();
    };
    return CssSelectorParser;
}());
var CssSelectorParser_1 = lib.CssSelectorParser = CssSelectorParser;

// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
// Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
const whitespace = new Set([9, 10, 12, 13, 32]);
const ZERO = "0".charCodeAt(0);
const NINE = "9".charCodeAt(0);
/**
 * Parses an expression.
 *
 * @throws An `Error` if parsing fails.
 * @returns An array containing the integer step size and the integer offset of the nth rule.
 * @example nthCheck.parse("2n+3"); // returns [2, 3]
 */
function parse$3(formula) {
    formula = formula.trim().toLowerCase();
    if (formula === "even") {
        return [2, 0];
    }
    else if (formula === "odd") {
        return [2, 1];
    }
    // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
    let idx = 0;
    let a = 0;
    let sign = readSign();
    let number = readNumber();
    if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a = sign * (number !== null && number !== void 0 ? number : 1);
        skipWhitespace();
        if (idx < formula.length) {
            sign = readSign();
            skipWhitespace();
            number = readNumber();
        }
        else {
            sign = number = 0;
        }
    }
    // Throw if there is anything else
    if (number === null || idx < formula.length) {
        throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
    }
    return [a, sign * number];
    function readSign() {
        if (formula.charAt(idx) === "-") {
            idx++;
            return -1;
        }
        if (formula.charAt(idx) === "+") {
            idx++;
        }
        return 1;
    }
    function readNumber() {
        const start = idx;
        let value = 0;
        while (idx < formula.length &&
            formula.charCodeAt(idx) >= ZERO &&
            formula.charCodeAt(idx) <= NINE) {
            value = value * 10 + (formula.charCodeAt(idx) - ZERO);
            idx++;
        }
        // Return `null` if we didn't read anything.
        return idx === start ? null : value;
    }
    function skipWhitespace() {
        while (idx < formula.length &&
            whitespace.has(formula.charCodeAt(idx))) {
            idx++;
        }
    }
}

var boolbase = {
	trueFunc: function trueFunc(){
		return true;
	},
	falseFunc: function falseFunc(){
		return false;
	}
};

/**
 * Returns a function that checks if an elements index matches the given rule
 * highly optimized to return the fastest solution.
 *
 * @param parsed A tuple [a, b], as returned by `parse`.
 * @returns A highly optimized function that returns whether an index matches the nth-check.
 * @example
 *
 * ```js
 * const check = nthCheck.compile([2, 3]);
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 * ```
 */
function compile$1(parsed) {
    const a = parsed[0];
    // Subtract 1 from `b`, to convert from one- to zero-indexed.
    const b = parsed[1] - 1;
    /*
     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
     * Besides, the specification states that no elements are
     * matched when `a` and `b` are 0.
     *
     * `b < 0` here as we subtracted 1 from `b` above.
     */
    if (b < 0 && a <= 0)
        return boolbase.falseFunc;
    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
    if (a === -1)
        return (index) => index <= b;
    if (a === 0)
        return (index) => index === b;
    // When `b <= 0` and `a === 1`, they match any element.
    if (a === 1)
        return b < 0 ? boolbase.trueFunc : (index) => index >= b;
    /*
     * Otherwise, modulo can be used to check if there is a match.
     *
     * Modulo doesn't care about the sign, so let's use `a`s absolute value.
     */
    const absA = Math.abs(a);
    // Get `b mod a`, + a if this is negative.
    const bMod = ((b % absA) + absA) % absA;
    return a > 1
        ? (index) => index >= b && index % absA === bMod
        : (index) => index <= b && index % absA === bMod;
}

/**
 * Parses and compiles a formula to a highly optimized function.
 * Combination of {@link parse} and {@link compile}.
 *
 * If the formula doesn't match any elements,
 * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
 * Otherwise, a function accepting an _index_ is returned, which returns
 * whether or not the passed _index_ matches the formula.
 *
 * Note: The nth-rule starts counting at `1`, the returned function at `0`.
 *
 * @param formula The formula to compile.
 * @example
 * const check = nthCheck("2n+3");
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 */
function nthCheck$1(formula) {
    return compile$1(parse$3(formula));
}

/**
 * @typedef {import('./types.js').Selector} Selector
 * @typedef {import('./types.js').Selectors} Selectors
 * @typedef {import('./types.js').RuleSet} RuleSet
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').RulePseudo} RulePseudo
 * @typedef {import('./types.js').RulePseudoNth} RulePseudoNth
 */

/** @type {import('nth-check').default} */
// @ts-expect-error
const nthCheck = nthCheck$1.default;

const nth = new Set([
  'nth-child',
  'nth-last-child',
  'nth-of-type',
  'nth-last-of-type'
]);

const parser = new CssSelectorParser_1();

parser.registerAttrEqualityMods('~', '^', '$', '*');
parser.registerSelectorPseudos('any', 'matches', 'not', 'has');
parser.registerNestingOperators('>', '+', '~');

// @ts-expect-error: hush.
const compile = zwitch('type', {handlers: {selectors, ruleSet, rule}});

/**
 * @param {string} selector
 * @returns {Selector}
 */
function parse$2(selector) {
  if (typeof selector !== 'string') {
    throw new TypeError('Expected `string` as selector, not `' + selector + '`')
  }

  // @ts-expect-error types are wrong.
  return compile(parser.parse(selector))
}

/**
 * @param {Selectors} query
 */
function selectors(query) {
  const selectors = query.selectors;
  let index = -1;

  while (++index < selectors.length) {
    compile(selectors[index]);
  }

  return query
}

/**
 * @param {RuleSet} query
 */
function ruleSet(query) {
  return rule(query.rule)
}

/**
 * @param {Rule} query
 */
function rule(query) {
  const pseudos = query.pseudos || [];
  let index = -1;
  /** @type {RulePseudo|RulePseudoNth} */
  let pseudo;

  while (++index < pseudos.length) {
    pseudo = pseudos[index];

    if (nth.has(pseudo.name)) {
      // @ts-expect-error Patch a non-primitive type.
      pseudo.value = nthCheck(pseudo.value);
      // @ts-expect-error Patch a non-primitive type.
      pseudo.valueType = 'function';
    }
  }

  compile(query.rule);

  return query
}

/**
 * @typedef {import('unist').Node} Node
 */

/**
 * @param {string} selector
 * @param {Node} [node]
 * @returns {Array.<Node>}
 */
function selectAll(selector, node) {
  return any(parse$2(selector), node, {any})
}

/**
 * @typedef Options
 * @property {boolean} [includeImageAlt=true]
 */

/**
 * Get the text content of a node.
 * Prefer the node’s plain-text fields, otherwise serialize its children,
 * and if the given value is an array, serialize the nodes in it.
 *
 * @param {unknown} node
 * @param {Options} [options]
 * @returns {string}
 */
function toString(node, options) {
  var {includeImageAlt = true} = options || {};
  return one(node, includeImageAlt)
}

/**
 * @param {unknown} node
 * @param {boolean} includeImageAlt
 * @returns {string}
 */
function one(node, includeImageAlt) {
  return (
    (node &&
      typeof node === 'object' &&
      // @ts-ignore looks like a literal.
      (node.value ||
        // @ts-ignore looks like an image.
        (includeImageAlt ? node.alt : '') ||
        // @ts-ignore looks like a parent.
        ('children' in node && all(node.children, includeImageAlt)) ||
        (Array.isArray(node) && all(node, includeImageAlt)))) ||
    ''
  )
}

/**
 * @param {Array.<unknown>} values
 * @param {boolean} includeImageAlt
 * @returns {string}
 */
function all(values, includeImageAlt) {
  /** @type {Array.<string>} */
  var result = [];
  var index = -1;

  while (++index < values.length) {
    result[index] = one(values[index], includeImageAlt);
  }

  return result.join('')
}

/**
 * Like `Array#splice`, but smarter for giant arrays.
 *
 * `Array#splice` takes all items to be inserted as individual argument which
 * causes a stack overflow in V8 when trying to insert 100k items for instance.
 *
 * Otherwise, this does not return the removed items, and takes `items` as an
 * array instead of rest parameters.
 *
 * @template {unknown} T
 * @param {T[]} list
 * @param {number} start
 * @param {number} remove
 * @param {T[]} items
 * @returns {void}
 */
function splice(list, start, remove, items) {
  const end = list.length;
  let chunkStart = 0;
  /** @type {unknown[]} */

  let parameters; // Make start between zero and `end` (included).

  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }

  remove = remove > 0 ? remove : 0; // No need to chunk the items if there’s only a couple (10k) items.

  if (items.length < 10000) {
    parameters = Array.from(items);
    parameters.unshift(start, remove) // @ts-expect-error Hush, it’s fine.
    ;[].splice.apply(list, parameters);
  } else {
    // Delete `remove` items starting from `start`
    if (remove) [].splice.apply(list, [start, remove]); // Insert the items in chunks to not cause stack overflows.

    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 10000);
      parameters.unshift(start, 0) // @ts-expect-error Hush, it’s fine.
      ;[].splice.apply(list, parameters);
      chunkStart += 10000;
      start += 10000;
    }
  }
}
/**
 * Append `items` (an array) at the end of `list` (another array).
 * When `list` was empty, returns `items` instead.
 *
 * This prevents a potentially expensive operation when `list` is empty,
 * and adds items in batches to prevent V8 from hanging.
 *
 * @template {unknown} T
 * @param {T[]} list
 * @param {T[]} items
 * @returns {T[]}
 */

function push(list, items) {
  if (list.length > 0) {
    splice(list, list.length, 0, items);
    return list
  }

  return items
}

/**
 * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
 */

const hasOwnProperty = {}.hasOwnProperty;

/**
 * Combine several syntax extensions into one.
 *
 * @param {Extension[]} extensions List of syntax extensions.
 * @returns {NormalizedExtension} A single combined extension.
 */
function combineExtensions(extensions) {
  /** @type {NormalizedExtension} */
  const all = {};
  let index = -1;

  while (++index < extensions.length) {
    syntaxExtension(all, extensions[index]);
  }

  return all
}

/**
 * Merge `extension` into `all`.
 *
 * @param {NormalizedExtension} all Extension to merge into.
 * @param {Extension} extension Extension to merge.
 * @returns {void}
 */
function syntaxExtension(all, extension) {
  /** @type {string} */
  let hook;

  for (hook in extension) {
    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined;
    const left = maybe || (all[hook] = {});
    const right = extension[hook];
    /** @type {string} */
    let code;

    for (code in right) {
      if (!hasOwnProperty.call(left, code)) left[code] = [];
      const value = right[code];
      constructs(
        // @ts-expect-error Looks like a list.
        left[code],
        Array.isArray(value) ? value : value ? [value] : []
      );
    }
  }
}

/**
 * Merge `list` into `existing` (both lists of constructs).
 * Mutates `existing`.
 *
 * @param {unknown[]} existing
 * @param {unknown[]} list
 * @returns {void}
 */
function constructs(existing, list) {
  let index = -1;
  /** @type {unknown[]} */
  const before = [];

  while (++index < list.length) {
(list[index].add === 'after' ? existing : before).push(list[index]);
  }

  splice(existing, 0, 0, before);
}

// This module is generated by `script/`.
//
// CommonMark handles attention (emphasis, strong) markers based on what comes
// before or after them.
// One such difference is if those characters are Unicode punctuation.
// This script is generated from the Unicode data.
const unicodePunctuationRegex =
  /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;

/**
 * @typedef {import('micromark-util-types').Code} Code
 */
/**
 * Check whether the character code represents an ASCII alpha (`a` through `z`,
 * case insensitive).
 *
 * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.
 *
 * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)
 * to U+005A (`Z`).
 *
 * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)
 * to U+007A (`z`).
 */

const asciiAlpha = regexCheck(/[A-Za-z]/);
/**
 * Check whether the character code represents an ASCII digit (`0` through `9`).
 *
 * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to
 * U+0039 (`9`).
 */

const asciiDigit = regexCheck(/\d/);
/**
 * Check whether the character code represents an ASCII hex digit (`a` through
 * `f`, case insensitive, or `0` through `9`).
 *
 * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex
 * digit, or an ASCII lower hex digit.
 *
 * An **ASCII upper hex digit** is a character in the inclusive range U+0041
 * (`A`) to U+0046 (`F`).
 *
 * An **ASCII lower hex digit** is a character in the inclusive range U+0061
 * (`a`) to U+0066 (`f`).
 */

const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
/**
 * Check whether the character code represents an ASCII alphanumeric (`a`
 * through `z`, case insensitive, or `0` through `9`).
 *
 * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha
 * (see `asciiAlpha`).
 */

const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
/**
 * Check whether the character code represents ASCII punctuation.
 *
 * An **ASCII punctuation** is a character in the inclusive ranges U+0021
 * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT
 * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT
 * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).
 */

const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
/**
 * Check whether the character code represents an ASCII atext.
 *
 * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in
 * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),
 * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F
 * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E
 * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE
 * (`{`) to U+007E TILDE (`~`).
 *
 * See:
 * **\[RFC5322]**:
 * [Internet Message Format](https://tools.ietf.org/html/rfc5322).
 * P. Resnick.
 * IETF.
 */

const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
/**
 * Check whether a character code is an ASCII control character.
 *
 * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)
 * to U+001F (US), or U+007F (DEL).
 *
 * @param {Code} code
 * @returns {code is number}
 */

function asciiControl(code) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code !== null && (code < 32 || code === 127)
  )
}
/**
 * Check whether a character code is a markdown line ending (see
 * `markdownLineEnding`) or markdown space (see `markdownSpace`).
 *
 * @param {Code} code
 * @returns {code is number}
 */

function markdownLineEndingOrSpace(code) {
  return code !== null && (code < 0 || code === 32)
}
/**
 * Check whether a character code is a markdown line ending.
 *
 * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN
 * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).
 *
 * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE
 * RETURN (CR) are replaced by these virtual characters depending on whether
 * they occurred together.
 *
 * @param {Code} code
 * @returns {code is number}
 */

function markdownLineEnding(code) {
  return code !== null && code < -2
}
/**
 * Check whether a character code is a markdown space.
 *
 * A **markdown space** is the concrete character U+0020 SPACE (SP) and the
 * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).
 *
 * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is
 * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL
 * SPACE (VS) characters, depending on the column at which the tab occurred.
 *
 * @param {Code} code
 * @returns {code is number}
 */

function markdownSpace(code) {
  return code === -2 || code === -1 || code === 32
}
/**
 * Check whether the character code represents Unicode whitespace.
 *
 * Note that this does handle micromark specific markdown whitespace characters.
 * See `markdownLineEndingOrSpace` to check that.
 *
 * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,
 * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),
 * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\[UNICODE]**).
 *
 * See:
 * **\[UNICODE]**:
 * [The Unicode Standard](https://www.unicode.org/versions/).
 * Unicode Consortium.
 */

const unicodeWhitespace = regexCheck(/\s/);
/**
 * Check whether the character code represents Unicode punctuation.
 *
 * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,
 * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`
 * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`
 * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII
 * punctuation (see `asciiPunctuation`).
 *
 * See:
 * **\[UNICODE]**:
 * [The Unicode Standard](https://www.unicode.org/versions/).
 * Unicode Consortium.
 */
// Size note: removing ASCII from the regex and using `asciiPunctuation` here
// In fact adds to the bundle size.

const unicodePunctuation = regexCheck(unicodePunctuationRegex);
/**
 * Create a code check from a regex.
 *
 * @param {RegExp} regex
 * @returns {(code: Code) => code is number}
 */

function regexCheck(regex) {
  return check
  /**
   * Check whether a code matches the bound regex.
   *
   * @param {Code} code Character code
   * @returns {code is number} Whether the character code matches the bound regex
   */

  function check(code) {
    return code !== null && regex.test(String.fromCharCode(code))
  }
}

/**
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 */
/**
 * @param {Effects} effects
 * @param {State} ok
 * @param {string} type
 * @param {number} [max=Infinity]
 * @returns {State}
 */

function factorySpace(effects, ok, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start
  /** @type {State} */

  function start(code) {
    if (markdownSpace(code)) {
      effects.enter(type);
      return prefix(code)
    }

    return ok(code)
  }
  /** @type {State} */

  function prefix(code) {
    if (markdownSpace(code) && size++ < limit) {
      effects.consume(code);
      return prefix
    }

    effects.exit(type);
    return ok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').Initializer} Initializer
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').State} State
 */

/** @type {InitialConstruct} */
const content$1 = {
  tokenize: initializeContent
};
/** @type {Initializer} */

function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  /** @type {Token} */

  let previous;
  return contentStart
  /** @type {State} */

  function afterContentStartConstruct(code) {
    if (code === null) {
      effects.consume(code);
      return
    }

    effects.enter('lineEnding');
    effects.consume(code);
    effects.exit('lineEnding');
    return factorySpace(effects, contentStart, 'linePrefix')
  }
  /** @type {State} */

  function paragraphInitial(code) {
    effects.enter('paragraph');
    return lineStart(code)
  }
  /** @type {State} */

  function lineStart(code) {
    const token = effects.enter('chunkText', {
      contentType: 'text',
      previous
    });

    if (previous) {
      previous.next = token;
    }

    previous = token;
    return data(code)
  }
  /** @type {State} */

  function data(code) {
    if (code === null) {
      effects.exit('chunkText');
      effects.exit('paragraph');
      effects.consume(code);
      return
    }

    if (markdownLineEnding(code)) {
      effects.consume(code);
      effects.exit('chunkText');
      return lineStart
    } // Data.

    effects.consume(code);
    return data
  }
}

/**
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').Initializer} Initializer
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Point} Point
 */
/** @type {InitialConstruct} */

const document$2 = {
  tokenize: initializeDocument
};
/** @type {Construct} */

const containerConstruct = {
  tokenize: tokenizeContainer
};
/** @type {Initializer} */

function initializeDocument(effects) {
  const self = this;
  /** @type {StackItem[]} */

  const stack = [];
  let continued = 0;
  /** @type {TokenizeContext|undefined} */

  let childFlow;
  /** @type {Token|undefined} */

  let childToken;
  /** @type {number} */

  let lineStartOffset;
  return start
  /** @type {State} */

  function start(code) {
    // First we iterate through the open blocks, starting with the root
    // document, and descending through last children down to the last open
    // block.
    // Each block imposes a condition that the line must satisfy if the block is
    // to remain open.
    // For example, a block quote requires a `>` character.
    // A paragraph requires a non-blank line.
    // In this phase we may match all or just some of the open blocks.
    // But we cannot close unmatched blocks yet, because we may have a lazy
    // continuation line.
    if (continued < stack.length) {
      const item = stack[continued];
      self.containerState = item[1];
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code)
    } // Done.

    return checkNewContainers(code)
  }
  /** @type {State} */

  function documentContinue(code) {
    continued++; // Note: this field is called `_closeFlow` but it also closes containers.
    // Perhaps a good idea to rename it but it’s already used in the wild by
    // extensions.

    if (self.containerState._closeFlow) {
      self.containerState._closeFlow = undefined;

      if (childFlow) {
        closeFlow();
      } // Note: this algorithm for moving events around is similar to the
      // algorithm when dealing with lazy lines in `writeToChild`.

      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      /** @type {Point|undefined} */

      let point; // Find the flow chunk.

      while (indexBeforeFlow--) {
        if (
          self.events[indexBeforeFlow][0] === 'exit' &&
          self.events[indexBeforeFlow][1].type === 'chunkFlow'
        ) {
          point = self.events[indexBeforeFlow][1].end;
          break
        }
      }

      exitContainers(continued); // Fix positions.

      let index = indexBeforeExits;

      while (index < self.events.length) {
        self.events[index][1].end = Object.assign({}, point);
        index++;
      } // Inject the exits earlier (they’re still also at the end).

      splice(
        self.events,
        indexBeforeFlow + 1,
        0,
        self.events.slice(indexBeforeExits)
      ); // Discard the duplicate exits.

      self.events.length = index;
      return checkNewContainers(code)
    }

    return start(code)
  }
  /** @type {State} */

  function checkNewContainers(code) {
    // Next, after consuming the continuation markers for existing blocks, we
    // look for new block starts (e.g. `>` for a block quote).
    // If we encounter a new block start, we close any blocks unmatched in
    // step 1 before creating the new block as a child of the last matched
    // block.
    if (continued === stack.length) {
      // No need to `check` whether there’s a container, of `exitContainers`
      // would be moot.
      // We can instead immediately `attempt` to parse one.
      if (!childFlow) {
        return documentContinued(code)
      } // If we have concrete content, such as block HTML or fenced code,
      // we can’t have containers “pierce” into them, so we can immediately
      // start.

      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code)
      } // If we do have flow, it could still be a blank line,
      // but we’d be interrupting it w/ a new container if there’s a current
      // construct.

      self.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    } // Check if there is a new container.

    self.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code)
  }
  /** @type {State} */

  function thereIsANewContainer(code) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code)
  }
  /** @type {State} */

  function thereIsNoNewContainer(code) {
    self.parser.lazy[self.now().line] = continued !== stack.length;
    lineStartOffset = self.now().offset;
    return flowStart(code)
  }
  /** @type {State} */

  function documentContinued(code) {
    // Try new containers.
    self.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code)
  }
  /** @type {State} */

  function containerContinue(code) {
    continued++;
    stack.push([self.currentConstruct, self.containerState]); // Try another.

    return documentContinued(code)
  }
  /** @type {State} */

  function flowStart(code) {
    if (code === null) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code);
      return
    }

    childFlow = childFlow || self.parser.flow(self.now());
    effects.enter('chunkFlow', {
      contentType: 'flow',
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code)
  }
  /** @type {State} */

  function flowContinue(code) {
    if (code === null) {
      writeToChild(effects.exit('chunkFlow'), true);
      exitContainers(0);
      effects.consume(code);
      return
    }

    if (markdownLineEnding(code)) {
      effects.consume(code);
      writeToChild(effects.exit('chunkFlow')); // Get ready for the next line.

      continued = 0;
      self.interrupt = undefined;
      return start
    }

    effects.consume(code);
    return flowContinue
  }
  /**
   * @param {Token} token
   * @param {boolean} [eof]
   * @returns {void}
   */

  function writeToChild(token, eof) {
    const stream = self.sliceStream(token);
    if (eof) stream.push(null);
    token.previous = childToken;
    if (childToken) childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream); // Alright, so we just added a lazy line:
    //
    // ```markdown
    // > a
    // b.
    //
    // Or:
    //
    // > ~~~c
    // d
    //
    // Or:
    //
    // > | e |
    // f
    // ```
    //
    // The construct in the second example (fenced code) does not accept lazy
    // lines, so it marked itself as done at the end of its first line, and
    // then the content construct parses `d`.
    // Most constructs in markdown match on the first line: if the first line
    // forms a construct, a non-lazy line can’t “unmake” it.
    //
    // The construct in the third example is potentially a GFM table, and
    // those are *weird*.
    // It *could* be a table, from the first line, if the following line
    // matches a condition.
    // In this case, that second line is lazy, which “unmakes” the first line
    // and turns the whole into one content block.
    //
    // We’ve now parsed the non-lazy and the lazy line, and can figure out
    // whether the lazy line started a new flow block.
    // If it did, we exit the current containers between the two flow blocks.

    if (self.parser.lazy[token.start.line]) {
      let index = childFlow.events.length;

      while (index--) {
        if (
          // The token starts before the line ending…
          childFlow.events[index][1].start.offset < lineStartOffset && // …and either is not ended yet…
          (!childFlow.events[index][1].end || // …or ends after it.
            childFlow.events[index][1].end.offset > lineStartOffset)
        ) {
          // Exit: there’s still something open, which means it’s a lazy line
          // part of something.
          return
        }
      } // Note: this algorithm for moving events around is similar to the
      // algorithm when closing flow in `documentContinue`.

      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      /** @type {boolean|undefined} */

      let seen;
      /** @type {Point|undefined} */

      let point; // Find the previous chunk (the one before the lazy line).

      while (indexBeforeFlow--) {
        if (
          self.events[indexBeforeFlow][0] === 'exit' &&
          self.events[indexBeforeFlow][1].type === 'chunkFlow'
        ) {
          if (seen) {
            point = self.events[indexBeforeFlow][1].end;
            break
          }

          seen = true;
        }
      }

      exitContainers(continued); // Fix positions.

      index = indexBeforeExits;

      while (index < self.events.length) {
        self.events[index][1].end = Object.assign({}, point);
        index++;
      } // Inject the exits earlier (they’re still also at the end).

      splice(
        self.events,
        indexBeforeFlow + 1,
        0,
        self.events.slice(indexBeforeExits)
      ); // Discard the duplicate exits.

      self.events.length = index;
    }
  }
  /**
   * @param {number} size
   * @returns {void}
   */

  function exitContainers(size) {
    let index = stack.length; // Exit open containers.

    while (index-- > size) {
      const entry = stack[index];
      self.containerState = entry[1];
      entry[0].exit.call(self, effects);
    }

    stack.length = size;
  }

  function closeFlow() {
    childFlow.write([null]);
    childToken = undefined;
    childFlow = undefined;
    self.containerState._closeFlow = undefined;
  }
}
/** @type {Tokenizer} */

function tokenizeContainer(effects, ok, nok) {
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok, nok),
    'linePrefix',
    this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4
  )
}

/**
 * @typedef {import('micromark-util-types').Code} Code
 */

/**
 * Classify whether a character code represents whitespace, punctuation, or
 * something else.
 *
 * Used for attention (emphasis, strong), whose sequences can open or close
 * based on the class of surrounding characters.
 *
 * Note that eof (`null`) is seen as whitespace.
 *
 * @param {Code} code
 * @returns {number|undefined}
 */
function classifyCharacter(code) {
  if (
    code === null ||
    markdownLineEndingOrSpace(code) ||
    unicodeWhitespace(code)
  ) {
    return 1
  }

  if (unicodePunctuation(code)) {
    return 2
  }
}

/**
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Resolver} Resolver
 */

/**
 * Call all `resolveAll`s.
 *
 * @param {{resolveAll?: Resolver}[]} constructs
 * @param {Event[]} events
 * @param {TokenizeContext} context
 * @returns {Event[]}
 */
function resolveAll(constructs, events, context) {
  /** @type {Resolver[]} */
  const called = [];
  let index = -1;

  while (++index < constructs.length) {
    const resolve = constructs[index].resolveAll;

    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }

  return events
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Point} Point
 */

/** @type {Construct} */
const attention = {
  name: 'attention',
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
/**
 * Take all events and resolve attention to emphasis or strong.
 *
 * @type {Resolver}
 */

function resolveAllAttention(events, context) {
  let index = -1;
  /** @type {number} */

  let open;
  /** @type {Token} */

  let group;
  /** @type {Token} */

  let text;
  /** @type {Token} */

  let openingSequence;
  /** @type {Token} */

  let closingSequence;
  /** @type {number} */

  let use;
  /** @type {Event[]} */

  let nextEvents;
  /** @type {number} */

  let offset; // Walk through all events.
  //
  // Note: performance of this is fine on an mb of normal markdown, but it’s
  // a bottleneck for malicious stuff.

  while (++index < events.length) {
    // Find a token that can close.
    if (
      events[index][0] === 'enter' &&
      events[index][1].type === 'attentionSequence' &&
      events[index][1]._close
    ) {
      open = index; // Now walk back to find an opener.

      while (open--) {
        // Find a token that can open the closer.
        if (
          events[open][0] === 'exit' &&
          events[open][1].type === 'attentionSequence' &&
          events[open][1]._open && // If the markers are the same:
          context.sliceSerialize(events[open][1]).charCodeAt(0) ===
            context.sliceSerialize(events[index][1]).charCodeAt(0)
        ) {
          // If the opening can close or the closing can open,
          // and the close size *is not* a multiple of three,
          // but the sum of the opening and closing size *is* multiple of three,
          // then don’t match.
          if (
            (events[open][1]._close || events[index][1]._open) &&
            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&
            !(
              (events[open][1].end.offset -
                events[open][1].start.offset +
                events[index][1].end.offset -
                events[index][1].start.offset) %
              3
            )
          ) {
            continue
          } // Number of markers to use from the sequence.

          use =
            events[open][1].end.offset - events[open][1].start.offset > 1 &&
            events[index][1].end.offset - events[index][1].start.offset > 1
              ? 2
              : 1;
          const start = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index][1].start);
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? 'strongSequence' : 'emphasisSequence',
            start,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? 'strongSequence' : 'emphasisSequence',
            start: Object.assign({}, events[index][1].start),
            end
          };
          text = {
            type: use > 1 ? 'strongText' : 'emphasisText',
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index][1].start)
          };
          group = {
            type: use > 1 ? 'strong' : 'emphasis',
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index][1].start = Object.assign({}, closingSequence.end);
          nextEvents = []; // If there are more markers in the opening, add them before.

          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ['enter', events[open][1], context],
              ['exit', events[open][1], context]
            ]);
          } // Opening.

          nextEvents = push(nextEvents, [
            ['enter', group, context],
            ['enter', openingSequence, context],
            ['exit', openingSequence, context],
            ['enter', text, context]
          ]); // Between.

          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index),
              context
            )
          ); // Closing.

          nextEvents = push(nextEvents, [
            ['exit', text, context],
            ['enter', closingSequence, context],
            ['exit', closingSequence, context],
            ['exit', group, context]
          ]); // If there are more markers in the closing, add them after.

          if (events[index][1].end.offset - events[index][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ['enter', events[index][1], context],
              ['exit', events[index][1], context]
            ]);
          } else {
            offset = 0;
          }

          splice(events, open - 1, index - open + 3, nextEvents);
          index = open + nextEvents.length - offset - 2;
          break
        }
      }
    }
  } // Remove remaining sequences.

  index = -1;

  while (++index < events.length) {
    if (events[index][1].type === 'attentionSequence') {
      events[index][1].type = 'data';
    }
  }

  return events
}
/** @type {Tokenizer} */

function tokenizeAttention(effects, ok) {
  const attentionMarkers = this.parser.constructs.attentionMarkers.null;
  const previous = this.previous;
  const before = classifyCharacter(previous);
  /** @type {NonNullable<Code>} */

  let marker;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('attentionSequence');
    marker = code;
    return sequence(code)
  }
  /** @type {State} */

  function sequence(code) {
    if (code === marker) {
      effects.consume(code);
      return sequence
    }

    const token = effects.exit('attentionSequence');
    const after = classifyCharacter(code);
    const open =
      !after || (after === 2 && before) || attentionMarkers.includes(code);
    const close =
      !before || (before === 2 && after) || attentionMarkers.includes(previous);
    token._open = Boolean(marker === 42 ? open : open && (before || !close));
    token._close = Boolean(marker === 42 ? close : close && (after || !open));
    return ok(code)
  }
}
/**
 * Move a point a bit.
 *
 * Note: `move` only works inside lines! It’s not possible to move past other
 * chunks (replacement characters, tabs, or line endings).
 *
 * @param {Point} point
 * @param {number} offset
 * @returns {void}
 */

function movePoint(point, offset) {
  point.column += offset;
  point.offset += offset;
  point._bufferIndex += offset;
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 */

/** @type {Construct} */
const autolink = {
  name: 'autolink',
  tokenize: tokenizeAutolink
};
/** @type {Tokenizer} */

function tokenizeAutolink(effects, ok, nok) {
  let size = 1;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('autolink');
    effects.enter('autolinkMarker');
    effects.consume(code);
    effects.exit('autolinkMarker');
    effects.enter('autolinkProtocol');
    return open
  }
  /** @type {State} */

  function open(code) {
    if (asciiAlpha(code)) {
      effects.consume(code);
      return schemeOrEmailAtext
    }

    return asciiAtext(code) ? emailAtext(code) : nok(code)
  }
  /** @type {State} */

  function schemeOrEmailAtext(code) {
    return code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)
      ? schemeInsideOrEmailAtext(code)
      : emailAtext(code)
  }
  /** @type {State} */

  function schemeInsideOrEmailAtext(code) {
    if (code === 58) {
      effects.consume(code);
      return urlInside
    }

    if (
      (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) &&
      size++ < 32
    ) {
      effects.consume(code);
      return schemeInsideOrEmailAtext
    }

    return emailAtext(code)
  }
  /** @type {State} */

  function urlInside(code) {
    if (code === 62) {
      effects.exit('autolinkProtocol');
      return end(code)
    }

    if (code === null || code === 32 || code === 60 || asciiControl(code)) {
      return nok(code)
    }

    effects.consume(code);
    return urlInside
  }
  /** @type {State} */

  function emailAtext(code) {
    if (code === 64) {
      effects.consume(code);
      size = 0;
      return emailAtSignOrDot
    }

    if (asciiAtext(code)) {
      effects.consume(code);
      return emailAtext
    }

    return nok(code)
  }
  /** @type {State} */

  function emailAtSignOrDot(code) {
    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)
  }
  /** @type {State} */

  function emailLabel(code) {
    if (code === 46) {
      effects.consume(code);
      size = 0;
      return emailAtSignOrDot
    }

    if (code === 62) {
      // Exit, then change the type.
      effects.exit('autolinkProtocol').type = 'autolinkEmail';
      return end(code)
    }

    return emailValue(code)
  }
  /** @type {State} */

  function emailValue(code) {
    if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {
      effects.consume(code);
      return code === 45 ? emailValue : emailLabel
    }

    return nok(code)
  }
  /** @type {State} */

  function end(code) {
    effects.enter('autolinkMarker');
    effects.consume(code);
    effects.exit('autolinkMarker');
    effects.exit('autolink');
    return ok
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 */

/** @type {Construct} */
const blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
/** @type {Tokenizer} */

function tokenizeBlankLine(effects, ok, nok) {
  return factorySpace(effects, afterWhitespace, 'linePrefix')
  /** @type {State} */

  function afterWhitespace(code) {
    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').Exiter} Exiter
 * @typedef {import('micromark-util-types').State} State
 */

/** @type {Construct} */
const blockQuote = {
  name: 'blockQuote',
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit: exit$1
};
/** @type {Tokenizer} */

function tokenizeBlockQuoteStart(effects, ok, nok) {
  const self = this;
  return start
  /** @type {State} */

  function start(code) {
    if (code === 62) {
      const state = self.containerState;

      if (!state.open) {
        effects.enter('blockQuote', {
          _container: true
        });
        state.open = true;
      }

      effects.enter('blockQuotePrefix');
      effects.enter('blockQuoteMarker');
      effects.consume(code);
      effects.exit('blockQuoteMarker');
      return after
    }

    return nok(code)
  }
  /** @type {State} */

  function after(code) {
    if (markdownSpace(code)) {
      effects.enter('blockQuotePrefixWhitespace');
      effects.consume(code);
      effects.exit('blockQuotePrefixWhitespace');
      effects.exit('blockQuotePrefix');
      return ok
    }

    effects.exit('blockQuotePrefix');
    return ok(code)
  }
}
/** @type {Tokenizer} */

function tokenizeBlockQuoteContinuation(effects, ok, nok) {
  return factorySpace(
    effects,
    effects.attempt(blockQuote, ok, nok),
    'linePrefix',
    this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4
  )
}
/** @type {Exiter} */

function exit$1(effects) {
  effects.exit('blockQuote');
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 */

/** @type {Construct} */
const characterEscape = {
  name: 'characterEscape',
  tokenize: tokenizeCharacterEscape
};
/** @type {Tokenizer} */

function tokenizeCharacterEscape(effects, ok, nok) {
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('characterEscape');
    effects.enter('escapeMarker');
    effects.consume(code);
    effects.exit('escapeMarker');
    return open
  }
  /** @type {State} */

  function open(code) {
    if (asciiPunctuation(code)) {
      effects.enter('characterEscapeValue');
      effects.consume(code);
      effects.exit('characterEscapeValue');
      effects.exit('characterEscape');
      return ok
    }

    return nok(code)
  }
}

/// <reference lib="dom" />

/* eslint-env browser */

const element = document.createElement('i');

/**
 * @param {string} value
 * @returns {string|false}
 */
function decodeNamedCharacterReference(value) {
  const characterReference = '&' + value + ';';
  element.innerHTML = characterReference;
  const char = element.textContent;

  // Some named character references do not require the closing semicolon
  // (`&not`, for instance), which leads to situations where parsing the assumed
  // named reference of `&notit;` will result in the string `¬it;`.
  // When we encounter a trailing semicolon after parsing, and the character
  // reference to decode was not a semicolon (`&semi;`), we can assume that the
  // matching was not complete.
  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
  // yield `null`.
  if (char.charCodeAt(char.length - 1) === 59 /* `;` */ && value !== 'semi') {
    return false
  }

  // If the decoded string is equal to the input, the character reference was
  // not valid.
  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
  // yield `null`.
  return char === characterReference ? false : char
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Code} Code
 */

/** @type {Construct} */
const characterReference = {
  name: 'characterReference',
  tokenize: tokenizeCharacterReference
};
/** @type {Tokenizer} */

function tokenizeCharacterReference(effects, ok, nok) {
  const self = this;
  let size = 0;
  /** @type {number} */

  let max;
  /** @type {(code: Code) => code is number} */

  let test;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('characterReference');
    effects.enter('characterReferenceMarker');
    effects.consume(code);
    effects.exit('characterReferenceMarker');
    return open
  }
  /** @type {State} */

  function open(code) {
    if (code === 35) {
      effects.enter('characterReferenceMarkerNumeric');
      effects.consume(code);
      effects.exit('characterReferenceMarkerNumeric');
      return numeric
    }

    effects.enter('characterReferenceValue');
    max = 31;
    test = asciiAlphanumeric;
    return value(code)
  }
  /** @type {State} */

  function numeric(code) {
    if (code === 88 || code === 120) {
      effects.enter('characterReferenceMarkerHexadecimal');
      effects.consume(code);
      effects.exit('characterReferenceMarkerHexadecimal');
      effects.enter('characterReferenceValue');
      max = 6;
      test = asciiHexDigit;
      return value
    }

    effects.enter('characterReferenceValue');
    max = 7;
    test = asciiDigit;
    return value(code)
  }
  /** @type {State} */

  function value(code) {
    /** @type {Token} */
    let token;

    if (code === 59 && size) {
      token = effects.exit('characterReferenceValue');

      if (
        test === asciiAlphanumeric &&
        !decodeNamedCharacterReference(self.sliceSerialize(token))
      ) {
        return nok(code)
      }

      effects.enter('characterReferenceMarker');
      effects.consume(code);
      effects.exit('characterReferenceMarker');
      effects.exit('characterReference');
      return ok
    }

    if (test(code) && size++ < max) {
      effects.consume(code);
      return value
    }

    return nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Code} Code
 */

/** @type {Construct} */
const codeFenced = {
  name: 'codeFenced',
  tokenize: tokenizeCodeFenced,
  concrete: true
};
/** @type {Tokenizer} */

function tokenizeCodeFenced(effects, ok, nok) {
  const self = this;
  /** @type {Construct} */

  const closingFenceConstruct = {
    tokenize: tokenizeClosingFence,
    partial: true
  };
  /** @type {Construct} */

  const nonLazyLine = {
    tokenize: tokenizeNonLazyLine,
    partial: true
  };
  const tail = this.events[this.events.length - 1];
  const initialPrefix =
    tail && tail[1].type === 'linePrefix'
      ? tail[2].sliceSerialize(tail[1], true).length
      : 0;
  let sizeOpen = 0;
  /** @type {NonNullable<Code>} */

  let marker;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('codeFenced');
    effects.enter('codeFencedFence');
    effects.enter('codeFencedFenceSequence');
    marker = code;
    return sequenceOpen(code)
  }
  /** @type {State} */

  function sequenceOpen(code) {
    if (code === marker) {
      effects.consume(code);
      sizeOpen++;
      return sequenceOpen
    }

    effects.exit('codeFencedFenceSequence');
    return sizeOpen < 3
      ? nok(code)
      : factorySpace(effects, infoOpen, 'whitespace')(code)
  }
  /** @type {State} */

  function infoOpen(code) {
    if (code === null || markdownLineEnding(code)) {
      return openAfter(code)
    }

    effects.enter('codeFencedFenceInfo');
    effects.enter('chunkString', {
      contentType: 'string'
    });
    return info(code)
  }
  /** @type {State} */

  function info(code) {
    if (code === null || markdownLineEndingOrSpace(code)) {
      effects.exit('chunkString');
      effects.exit('codeFencedFenceInfo');
      return factorySpace(effects, infoAfter, 'whitespace')(code)
    }

    if (code === 96 && code === marker) return nok(code)
    effects.consume(code);
    return info
  }
  /** @type {State} */

  function infoAfter(code) {
    if (code === null || markdownLineEnding(code)) {
      return openAfter(code)
    }

    effects.enter('codeFencedFenceMeta');
    effects.enter('chunkString', {
      contentType: 'string'
    });
    return meta(code)
  }
  /** @type {State} */

  function meta(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('chunkString');
      effects.exit('codeFencedFenceMeta');
      return openAfter(code)
    }

    if (code === 96 && code === marker) return nok(code)
    effects.consume(code);
    return meta
  }
  /** @type {State} */

  function openAfter(code) {
    effects.exit('codeFencedFence');
    return self.interrupt ? ok(code) : contentStart(code)
  }
  /** @type {State} */

  function contentStart(code) {
    if (code === null) {
      return after(code)
    }

    if (markdownLineEnding(code)) {
      return effects.attempt(
        nonLazyLine,
        effects.attempt(
          closingFenceConstruct,
          after,
          initialPrefix
            ? factorySpace(
                effects,
                contentStart,
                'linePrefix',
                initialPrefix + 1
              )
            : contentStart
        ),
        after
      )(code)
    }

    effects.enter('codeFlowValue');
    return contentContinue(code)
  }
  /** @type {State} */

  function contentContinue(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('codeFlowValue');
      return contentStart(code)
    }

    effects.consume(code);
    return contentContinue
  }
  /** @type {State} */

  function after(code) {
    effects.exit('codeFenced');
    return ok(code)
  }
  /** @type {Tokenizer} */

  function tokenizeNonLazyLine(effects, ok, nok) {
    const self = this;
    return start
    /** @type {State} */

    function start(code) {
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      return lineStart
    }
    /** @type {State} */

    function lineStart(code) {
      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)
    }
  }
  /** @type {Tokenizer} */

  function tokenizeClosingFence(effects, ok, nok) {
    let size = 0;
    return factorySpace(
      effects,
      closingSequenceStart,
      'linePrefix',
      this.parser.constructs.disable.null.includes('codeIndented')
        ? undefined
        : 4
    )
    /** @type {State} */

    function closingSequenceStart(code) {
      effects.enter('codeFencedFence');
      effects.enter('codeFencedFenceSequence');
      return closingSequence(code)
    }
    /** @type {State} */

    function closingSequence(code) {
      if (code === marker) {
        effects.consume(code);
        size++;
        return closingSequence
      }

      if (size < sizeOpen) return nok(code)
      effects.exit('codeFencedFenceSequence');
      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code)
    }
    /** @type {State} */

    function closingSequenceEnd(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit('codeFencedFence');
        return ok(code)
      }

      return nok(code)
    }
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').State} State
 */

/** @type {Construct} */
const codeIndented = {
  name: 'codeIndented',
  tokenize: tokenizeCodeIndented
};
/** @type {Construct} */

const indentedContent = {
  tokenize: tokenizeIndentedContent,
  partial: true
};
/** @type {Tokenizer} */

function tokenizeCodeIndented(effects, ok, nok) {
  const self = this;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('codeIndented');
    return factorySpace(effects, afterStartPrefix, 'linePrefix', 4 + 1)(code)
  }
  /** @type {State} */

  function afterStartPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return tail &&
      tail[1].type === 'linePrefix' &&
      tail[2].sliceSerialize(tail[1], true).length >= 4
      ? afterPrefix(code)
      : nok(code)
  }
  /** @type {State} */

  function afterPrefix(code) {
    if (code === null) {
      return after(code)
    }

    if (markdownLineEnding(code)) {
      return effects.attempt(indentedContent, afterPrefix, after)(code)
    }

    effects.enter('codeFlowValue');
    return content(code)
  }
  /** @type {State} */

  function content(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('codeFlowValue');
      return afterPrefix(code)
    }

    effects.consume(code);
    return content
  }
  /** @type {State} */

  function after(code) {
    effects.exit('codeIndented');
    return ok(code)
  }
}
/** @type {Tokenizer} */

function tokenizeIndentedContent(effects, ok, nok) {
  const self = this;
  return start
  /** @type {State} */

  function start(code) {
    // If this is a lazy line, it can’t be code.
    if (self.parser.lazy[self.now().line]) {
      return nok(code)
    }

    if (markdownLineEnding(code)) {
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      return start
    }

    return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)(code)
  }
  /** @type {State} */

  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return tail &&
      tail[1].type === 'linePrefix' &&
      tail[2].sliceSerialize(tail[1], true).length >= 4
      ? ok(code)
      : markdownLineEnding(code)
      ? start(code)
      : nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').Previous} Previous
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').State} State
 */

/** @type {Construct} */
const codeText = {
  name: 'codeText',
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous: previous$1
};
/** @type {Resolver} */

function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  /** @type {number} */

  let index;
  /** @type {number|undefined} */

  let enter; // If we start and end with an EOL or a space.

  if (
    (events[headEnterIndex][1].type === 'lineEnding' ||
      events[headEnterIndex][1].type === 'space') &&
    (events[tailExitIndex][1].type === 'lineEnding' ||
      events[tailExitIndex][1].type === 'space')
  ) {
    index = headEnterIndex; // And we have data.

    while (++index < tailExitIndex) {
      if (events[index][1].type === 'codeTextData') {
        // Then we have padding.
        events[headEnterIndex][1].type = 'codeTextPadding';
        events[tailExitIndex][1].type = 'codeTextPadding';
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break
      }
    }
  } // Merge adjacent spaces and data.

  index = headEnterIndex - 1;
  tailExitIndex++;

  while (++index <= tailExitIndex) {
    if (enter === undefined) {
      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {
        enter = index;
      }
    } else if (
      index === tailExitIndex ||
      events[index][1].type === 'lineEnding'
    ) {
      events[enter][1].type = 'codeTextData';

      if (index !== enter + 2) {
        events[enter][1].end = events[index - 1][1].end;
        events.splice(enter + 2, index - enter - 2);
        tailExitIndex -= index - enter - 2;
        index = enter + 2;
      }

      enter = undefined;
    }
  }

  return events
}
/** @type {Previous} */

function previous$1(code) {
  // If there is a previous code, there will always be a tail.
  return (
    code !== 96 ||
    this.events[this.events.length - 1][1].type === 'characterEscape'
  )
}
/** @type {Tokenizer} */

function tokenizeCodeText(effects, ok, nok) {
  let sizeOpen = 0;
  /** @type {number} */

  let size;
  /** @type {Token} */

  let token;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('codeText');
    effects.enter('codeTextSequence');
    return openingSequence(code)
  }
  /** @type {State} */

  function openingSequence(code) {
    if (code === 96) {
      effects.consume(code);
      sizeOpen++;
      return openingSequence
    }

    effects.exit('codeTextSequence');
    return gap(code)
  }
  /** @type {State} */

  function gap(code) {
    // EOF.
    if (code === null) {
      return nok(code)
    } // Closing fence?
    // Could also be data.

    if (code === 96) {
      token = effects.enter('codeTextSequence');
      size = 0;
      return closingSequence(code)
    } // Tabs don’t work, and virtual spaces don’t make sense.

    if (code === 32) {
      effects.enter('space');
      effects.consume(code);
      effects.exit('space');
      return gap
    }

    if (markdownLineEnding(code)) {
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      return gap
    } // Data.

    effects.enter('codeTextData');
    return data(code)
  } // In code.

  /** @type {State} */

  function data(code) {
    if (
      code === null ||
      code === 32 ||
      code === 96 ||
      markdownLineEnding(code)
    ) {
      effects.exit('codeTextData');
      return gap(code)
    }

    effects.consume(code);
    return data
  } // Closing fence.

  /** @type {State} */

  function closingSequence(code) {
    // More.
    if (code === 96) {
      effects.consume(code);
      size++;
      return closingSequence
    } // Done!

    if (size === sizeOpen) {
      effects.exit('codeTextSequence');
      effects.exit('codeText');
      return ok(code)
    } // More or less accents: mark as data.

    token.type = 'codeTextData';
    return data(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').Chunk} Chunk
 * @typedef {import('micromark-util-types').Event} Event
 */

/**
 * Tokenize subcontent.
 *
 * @param {Event[]} events
 * @returns {boolean}
 */
function subtokenize(events) {
  /** @type {Record<string, number>} */
  const jumps = {};
  let index = -1;
  /** @type {Event} */

  let event;
  /** @type {number|undefined} */

  let lineIndex;
  /** @type {number} */

  let otherIndex;
  /** @type {Event} */

  let otherEvent;
  /** @type {Event[]} */

  let parameters;
  /** @type {Event[]} */

  let subevents;
  /** @type {boolean|undefined} */

  let more;

  while (++index < events.length) {
    while (index in jumps) {
      index = jumps[index];
    }

    event = events[index]; // Add a hook for the GFM tasklist extension, which needs to know if text
    // is in the first content of a list item.

    if (
      index &&
      event[1].type === 'chunkFlow' &&
      events[index - 1][1].type === 'listItemPrefix'
    ) {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;

      if (
        otherIndex < subevents.length &&
        subevents[otherIndex][1].type === 'lineEndingBlank'
      ) {
        otherIndex += 2;
      }

      if (
        otherIndex < subevents.length &&
        subevents[otherIndex][1].type === 'content'
      ) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === 'content') {
            break
          }

          if (subevents[otherIndex][1].type === 'chunkText') {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    } // Enter.

    if (event[0] === 'enter') {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index));
        index = jumps[index];
        more = true;
      }
    } // Exit.
    else if (event[1]._container) {
      otherIndex = index;
      lineIndex = undefined;

      while (otherIndex--) {
        otherEvent = events[otherIndex];

        if (
          otherEvent[1].type === 'lineEnding' ||
          otherEvent[1].type === 'lineEndingBlank'
        ) {
          if (otherEvent[0] === 'enter') {
            if (lineIndex) {
              events[lineIndex][1].type = 'lineEndingBlank';
            }

            otherEvent[1].type = 'lineEnding';
            lineIndex = otherIndex;
          }
        } else {
          break
        }
      }

      if (lineIndex) {
        // Fix position.
        event[1].end = Object.assign({}, events[lineIndex][1].start); // Switch container exit w/ line endings.

        parameters = events.slice(lineIndex, index);
        parameters.unshift(event);
        splice(events, lineIndex, index - lineIndex + 1, parameters);
      }
    }
  }

  return !more
}
/**
 * Tokenize embedded tokens.
 *
 * @param {Event[]} events
 * @param {number} eventIndex
 * @returns {Record<string, number>}
 */

function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  /** @type {number[]} */

  const startPositions = [];
  const tokenizer =
    token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  /** @type {[number, number][]} */

  const jumps = [];
  /** @type {Record<string, number>} */

  const gaps = {};
  /** @type {Chunk[]} */

  let stream;
  /** @type {Token|undefined} */

  let previous;
  let index = -1;
  /** @type {Token|undefined} */

  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start]; // Loop forward through the linked tokens to pass them in order to the
  // subtokenizer.

  while (current) {
    // Find the position of the event for this token.
    while (events[++startPosition][1] !== current) {
      // Empty.
    }

    startPositions.push(startPosition);

    if (!current._tokenizer) {
      stream = context.sliceStream(current);

      if (!current.next) {
        stream.push(null);
      }

      if (previous) {
        tokenizer.defineSkip(current.start);
      }

      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }

      tokenizer.write(stream);

      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = undefined;
      }
    } // Unravel the next token.

    previous = current;
    current = current.next;
  } // Now, loop back through all events (and linked tokens), to figure out which
  // parts belong where.

  current = token;

  while (++index < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index][0] === 'exit' &&
      childEvents[index - 1][0] === 'enter' &&
      childEvents[index][1].type === childEvents[index - 1][1].type &&
      childEvents[index][1].start.line !== childEvents[index][1].end.line
    ) {
      start = index + 1;
      breaks.push(start); // Help GC.

      current._tokenizer = undefined;
      current.previous = undefined;
      current = current.next;
    }
  } // Help GC.

  tokenizer.events = []; // If there’s one more token (which is the cases for lines that end in an
  // EOF), that’s perfect: the last point we found starts it.
  // If there isn’t then make sure any remaining content is added to it.

  if (current) {
    // Help GC.
    current._tokenizer = undefined;
    current.previous = undefined;
  } else {
    breaks.pop();
  } // Now splice the events from the subtokenizer into the current events,
  // moving back to front so that splice indices aren’t affected.

  index = breaks.length;

  while (index--) {
    const slice = childEvents.slice(breaks[index], breaks[index + 1]);
    const start = startPositions.pop();
    jumps.unshift([start, start + slice.length - 1]);
    splice(events, start, 2, slice);
  }

  index = -1;

  while (++index < jumps.length) {
    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];
    adjust += jumps[index][1] - jumps[index][0] - 1;
  }

  return gaps
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').State} State
 */

/**
 * No name because it must not be turned off.
 * @type {Construct}
 */
const content = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
/** @type {Construct} */

const continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
/**
 * Content is transparent: it’s parsed right now. That way, definitions are also
 * parsed right now: before text in paragraphs (specifically, media) are parsed.
 *
 * @type {Resolver}
 */

function resolveContent(events) {
  subtokenize(events);
  return events
}
/** @type {Tokenizer} */

function tokenizeContent(effects, ok) {
  /** @type {Token} */
  let previous;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('content');
    previous = effects.enter('chunkContent', {
      contentType: 'content'
    });
    return data(code)
  }
  /** @type {State} */

  function data(code) {
    if (code === null) {
      return contentEnd(code)
    }

    if (markdownLineEnding(code)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code)
    } // Data.

    effects.consume(code);
    return data
  }
  /** @type {State} */

  function contentEnd(code) {
    effects.exit('chunkContent');
    effects.exit('content');
    return ok(code)
  }
  /** @type {State} */

  function contentContinue(code) {
    effects.consume(code);
    effects.exit('chunkContent');
    previous.next = effects.enter('chunkContent', {
      contentType: 'content',
      previous
    });
    previous = previous.next;
    return data
  }
}
/** @type {Tokenizer} */

function tokenizeContinuation(effects, ok, nok) {
  const self = this;
  return startLookahead
  /** @type {State} */

  function startLookahead(code) {
    effects.exit('chunkContent');
    effects.enter('lineEnding');
    effects.consume(code);
    effects.exit('lineEnding');
    return factorySpace(effects, prefixed, 'linePrefix')
  }
  /** @type {State} */

  function prefixed(code) {
    if (code === null || markdownLineEnding(code)) {
      return nok(code)
    }

    const tail = self.events[self.events.length - 1];

    if (
      !self.parser.constructs.disable.null.includes('codeIndented') &&
      tail &&
      tail[1].type === 'linePrefix' &&
      tail[2].sliceSerialize(tail[1], true).length >= 4
    ) {
      return ok(code)
    }

    return effects.interrupt(self.parser.constructs.flow, nok, ok)(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 */

/**
 * @param {Effects} effects
 * @param {State} ok
 * @param {State} nok
 * @param {string} type
 * @param {string} literalType
 * @param {string} literalMarkerType
 * @param {string} rawType
 * @param {string} stringType
 * @param {number} [max=Infinity]
 * @returns {State}
 */
// eslint-disable-next-line max-params
function factoryDestination(
  effects,
  ok,
  nok,
  type,
  literalType,
  literalMarkerType,
  rawType,
  stringType,
  max
) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start
  /** @type {State} */

  function start(code) {
    if (code === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code);
      effects.exit(literalMarkerType);
      return destinationEnclosedBefore
    }

    if (code === null || code === 41 || asciiControl(code)) {
      return nok(code)
    }

    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter('chunkString', {
      contentType: 'string'
    });
    return destinationRaw(code)
  }
  /** @type {State} */

  function destinationEnclosedBefore(code) {
    if (code === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok
    }

    effects.enter(stringType);
    effects.enter('chunkString', {
      contentType: 'string'
    });
    return destinationEnclosed(code)
  }
  /** @type {State} */

  function destinationEnclosed(code) {
    if (code === 62) {
      effects.exit('chunkString');
      effects.exit(stringType);
      return destinationEnclosedBefore(code)
    }

    if (code === null || code === 60 || markdownLineEnding(code)) {
      return nok(code)
    }

    effects.consume(code);
    return code === 92 ? destinationEnclosedEscape : destinationEnclosed
  }
  /** @type {State} */

  function destinationEnclosedEscape(code) {
    if (code === 60 || code === 62 || code === 92) {
      effects.consume(code);
      return destinationEnclosed
    }

    return destinationEnclosed(code)
  }
  /** @type {State} */

  function destinationRaw(code) {
    if (code === 40) {
      if (++balance > limit) return nok(code)
      effects.consume(code);
      return destinationRaw
    }

    if (code === 41) {
      if (!balance--) {
        effects.exit('chunkString');
        effects.exit(stringType);
        effects.exit(rawType);
        effects.exit(type);
        return ok(code)
      }

      effects.consume(code);
      return destinationRaw
    }

    if (code === null || markdownLineEndingOrSpace(code)) {
      if (balance) return nok(code)
      effects.exit('chunkString');
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok(code)
    }

    if (asciiControl(code)) return nok(code)
    effects.consume(code);
    return code === 92 ? destinationRawEscape : destinationRaw
  }
  /** @type {State} */

  function destinationRawEscape(code) {
    if (code === 40 || code === 41 || code === 92) {
      effects.consume(code);
      return destinationRaw
    }

    return destinationRaw(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').State} State
 */

/**
 * @this {TokenizeContext}
 * @param {Effects} effects
 * @param {State} ok
 * @param {State} nok
 * @param {string} type
 * @param {string} markerType
 * @param {string} stringType
 * @returns {State}
 */
// eslint-disable-next-line max-params
function factoryLabel(effects, ok, nok, type, markerType, stringType) {
  const self = this;
  let size = 0;
  /** @type {boolean} */

  let data;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak
  }
  /** @type {State} */

  function atBreak(code) {
    if (
      code === null ||
      code === 91 ||
      (code === 93 && !data) ||
      /* To do: remove in the future once we’ve switched from
       * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
       * which doesn’t need this */

      /* Hidden footnotes hook */

      /* c8 ignore next 3 */
      (code === 94 &&
        !size &&
        '_hiddenFootnoteSupport' in self.parser.constructs) ||
      size > 999
    ) {
      return nok(code)
    }

    if (code === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type);
      return ok
    }

    if (markdownLineEnding(code)) {
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      return atBreak
    }

    effects.enter('chunkString', {
      contentType: 'string'
    });
    return label(code)
  }
  /** @type {State} */

  function label(code) {
    if (
      code === null ||
      code === 91 ||
      code === 93 ||
      markdownLineEnding(code) ||
      size++ > 999
    ) {
      effects.exit('chunkString');
      return atBreak(code)
    }

    effects.consume(code);
    data = data || !markdownSpace(code);
    return code === 92 ? labelEscape : label
  }
  /** @type {State} */

  function labelEscape(code) {
    if (code === 91 || code === 92 || code === 93) {
      effects.consume(code);
      size++;
      return label
    }

    return label(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Code} Code
 */

/**
 * @param {Effects} effects
 * @param {State} ok
 * @param {State} nok
 * @param {string} type
 * @param {string} markerType
 * @param {string} stringType
 * @returns {State}
 */
// eslint-disable-next-line max-params
function factoryTitle(effects, ok, nok, type, markerType, stringType) {
  /** @type {NonNullable<Code>} */
  let marker;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code);
    effects.exit(markerType);
    marker = code === 40 ? 41 : code;
    return atFirstTitleBreak
  }
  /** @type {State} */

  function atFirstTitleBreak(code) {
    if (code === marker) {
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type);
      return ok
    }

    effects.enter(stringType);
    return atTitleBreak(code)
  }
  /** @type {State} */

  function atTitleBreak(code) {
    if (code === marker) {
      effects.exit(stringType);
      return atFirstTitleBreak(marker)
    }

    if (code === null) {
      return nok(code)
    } // Note: blank lines can’t exist in content.

    if (markdownLineEnding(code)) {
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      return factorySpace(effects, atTitleBreak, 'linePrefix')
    }

    effects.enter('chunkString', {
      contentType: 'string'
    });
    return title(code)
  }
  /** @type {State} */

  function title(code) {
    if (code === marker || code === null || markdownLineEnding(code)) {
      effects.exit('chunkString');
      return atTitleBreak(code)
    }

    effects.consume(code);
    return code === 92 ? titleEscape : title
  }
  /** @type {State} */

  function titleEscape(code) {
    if (code === marker || code === 92) {
      effects.consume(code);
      return title
    }

    return title(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 */

/**
 * @param {Effects} effects
 * @param {State} ok
 */
function factoryWhitespace(effects, ok) {
  /** @type {boolean} */
  let seen;
  return start
  /** @type {State} */

  function start(code) {
    if (markdownLineEnding(code)) {
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      seen = true;
      return start
    }

    if (markdownSpace(code)) {
      return factorySpace(
        effects,
        start,
        seen ? 'linePrefix' : 'lineSuffix'
      )(code)
    }

    return ok(code)
  }
}

/**
 * Normalize an identifier (such as used in definitions).
 *
 * @param {string} value
 * @returns {string}
 */
function normalizeIdentifier(value) {
  return (
    value // Collapse Markdown whitespace.
      .replace(/[\t\n\r ]+/g, ' ') // Trim.
      .replace(/^ | $/g, '') // Some characters are considered “uppercase”, but if their lowercase
      // counterpart is uppercased will result in a different uppercase
      // character.
      // Hence, to get that form, we perform both lower- and uppercase.
      // Upper case makes sure keys will not interact with default prototypal
      // methods: no method is uppercase.
      .toLowerCase()
      .toUpperCase()
  )
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 */

/** @type {Construct} */
const definition = {
  name: 'definition',
  tokenize: tokenizeDefinition
};
/** @type {Construct} */

const titleConstruct = {
  tokenize: tokenizeTitle,
  partial: true
};
/** @type {Tokenizer} */

function tokenizeDefinition(effects, ok, nok) {
  const self = this;
  /** @type {string} */

  let identifier;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('definition');
    return factoryLabel.call(
      self,
      effects,
      labelAfter,
      nok,
      'definitionLabel',
      'definitionLabelMarker',
      'definitionLabelString'
    )(code)
  }
  /** @type {State} */

  function labelAfter(code) {
    identifier = normalizeIdentifier(
      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
    );

    if (code === 58) {
      effects.enter('definitionMarker');
      effects.consume(code);
      effects.exit('definitionMarker'); // Note: blank lines can’t exist in content.

      return factoryWhitespace(
        effects,
        factoryDestination(
          effects,
          effects.attempt(
            titleConstruct,
            factorySpace(effects, after, 'whitespace'),
            factorySpace(effects, after, 'whitespace')
          ),
          nok,
          'definitionDestination',
          'definitionDestinationLiteral',
          'definitionDestinationLiteralMarker',
          'definitionDestinationRaw',
          'definitionDestinationString'
        )
      )
    }

    return nok(code)
  }
  /** @type {State} */

  function after(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('definition');

      if (!self.parser.defined.includes(identifier)) {
        self.parser.defined.push(identifier);
      }

      return ok(code)
    }

    return nok(code)
  }
}
/** @type {Tokenizer} */

function tokenizeTitle(effects, ok, nok) {
  return start
  /** @type {State} */

  function start(code) {
    return markdownLineEndingOrSpace(code)
      ? factoryWhitespace(effects, before)(code)
      : nok(code)
  }
  /** @type {State} */

  function before(code) {
    if (code === 34 || code === 39 || code === 40) {
      return factoryTitle(
        effects,
        factorySpace(effects, after, 'whitespace'),
        nok,
        'definitionTitle',
        'definitionTitleMarker',
        'definitionTitleString'
      )(code)
    }

    return nok(code)
  }
  /** @type {State} */

  function after(code) {
    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 */

/** @type {Construct} */
const hardBreakEscape = {
  name: 'hardBreakEscape',
  tokenize: tokenizeHardBreakEscape
};
/** @type {Tokenizer} */

function tokenizeHardBreakEscape(effects, ok, nok) {
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('hardBreakEscape');
    effects.enter('escapeMarker');
    effects.consume(code);
    return open
  }
  /** @type {State} */

  function open(code) {
    if (markdownLineEnding(code)) {
      effects.exit('escapeMarker');
      effects.exit('hardBreakEscape');
      return ok(code)
    }

    return nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').State} State
 */

/** @type {Construct} */
const headingAtx = {
  name: 'headingAtx',
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
/** @type {Resolver} */

function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  /** @type {Token} */

  let content;
  /** @type {Token} */

  let text; // Prefix whitespace, part of the opening.

  if (events[contentStart][1].type === 'whitespace') {
    contentStart += 2;
  } // Suffix whitespace, part of the closing.

  if (
    contentEnd - 2 > contentStart &&
    events[contentEnd][1].type === 'whitespace'
  ) {
    contentEnd -= 2;
  }

  if (
    events[contentEnd][1].type === 'atxHeadingSequence' &&
    (contentStart === contentEnd - 1 ||
      (contentEnd - 4 > contentStart &&
        events[contentEnd - 2][1].type === 'whitespace'))
  ) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }

  if (contentEnd > contentStart) {
    content = {
      type: 'atxHeadingText',
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text = {
      type: 'chunkText',
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      // @ts-expect-error Constants are fine to assign.
      contentType: 'text'
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ['enter', content, context],
      ['enter', text, context],
      ['exit', text, context],
      ['exit', content, context]
    ]);
  }

  return events
}
/** @type {Tokenizer} */

function tokenizeHeadingAtx(effects, ok, nok) {
  const self = this;
  let size = 0;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('atxHeading');
    effects.enter('atxHeadingSequence');
    return fenceOpenInside(code)
  }
  /** @type {State} */

  function fenceOpenInside(code) {
    if (code === 35 && size++ < 6) {
      effects.consume(code);
      return fenceOpenInside
    }

    if (code === null || markdownLineEndingOrSpace(code)) {
      effects.exit('atxHeadingSequence');
      return self.interrupt ? ok(code) : headingBreak(code)
    }

    return nok(code)
  }
  /** @type {State} */

  function headingBreak(code) {
    if (code === 35) {
      effects.enter('atxHeadingSequence');
      return sequence(code)
    }

    if (code === null || markdownLineEnding(code)) {
      effects.exit('atxHeading');
      return ok(code)
    }

    if (markdownSpace(code)) {
      return factorySpace(effects, headingBreak, 'whitespace')(code)
    }

    effects.enter('atxHeadingText');
    return data(code)
  }
  /** @type {State} */

  function sequence(code) {
    if (code === 35) {
      effects.consume(code);
      return sequence
    }

    effects.exit('atxHeadingSequence');
    return headingBreak(code)
  }
  /** @type {State} */

  function data(code) {
    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {
      effects.exit('atxHeadingText');
      return headingBreak(code)
    }

    effects.consume(code);
    return data
  }
}

/**
 * List of lowercase HTML tag names which when parsing HTML (flow), result
 * in more relaxed rules (condition 6): because they are known blocks, the
 * HTML-like syntax doesn’t have to be strictly parsed.
 * For tag names not in this list, a more strict algorithm (condition 7) is used
 * to detect whether the HTML-like syntax is seen as HTML (flow) or not.
 *
 * This is copied from:
 * <https://spec.commonmark.org/0.30/#html-blocks>.
 */
const htmlBlockNames = [
  'address',
  'article',
  'aside',
  'base',
  'basefont',
  'blockquote',
  'body',
  'caption',
  'center',
  'col',
  'colgroup',
  'dd',
  'details',
  'dialog',
  'dir',
  'div',
  'dl',
  'dt',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'frame',
  'frameset',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'head',
  'header',
  'hr',
  'html',
  'iframe',
  'legend',
  'li',
  'link',
  'main',
  'menu',
  'menuitem',
  'nav',
  'noframes',
  'ol',
  'optgroup',
  'option',
  'p',
  'param',
  'section',
  'summary',
  'table',
  'tbody',
  'td',
  'tfoot',
  'th',
  'thead',
  'title',
  'tr',
  'track',
  'ul'
];

/**
 * List of lowercase HTML tag names which when parsing HTML (flow), result in
 * HTML that can include lines w/o exiting, until a closing tag also in this
 * list is found (condition 1).
 *
 * This module is copied from:
 * <https://spec.commonmark.org/0.30/#html-blocks>.
 *
 * Note that `textarea` was added in `CommonMark@0.30`.
 */
const htmlRawNames = ['pre', 'script', 'style', 'textarea'];

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Code} Code
 */
/** @type {Construct} */

const htmlFlow = {
  name: 'htmlFlow',
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
/** @type {Construct} */

const nextBlankConstruct = {
  tokenize: tokenizeNextBlank,
  partial: true
};
/** @type {Resolver} */

function resolveToHtmlFlow(events) {
  let index = events.length;

  while (index--) {
    if (events[index][0] === 'enter' && events[index][1].type === 'htmlFlow') {
      break
    }
  }

  if (index > 1 && events[index - 2][1].type === 'linePrefix') {
    // Add the prefix start to the HTML token.
    events[index][1].start = events[index - 2][1].start; // Add the prefix start to the HTML line token.

    events[index + 1][1].start = events[index - 2][1].start; // Remove the line prefix.

    events.splice(index - 2, 2);
  }

  return events
}
/** @type {Tokenizer} */

function tokenizeHtmlFlow(effects, ok, nok) {
  const self = this;
  /** @type {number} */

  let kind;
  /** @type {boolean} */

  let startTag;
  /** @type {string} */

  let buffer;
  /** @type {number} */

  let index;
  /** @type {Code} */

  let marker;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('htmlFlow');
    effects.enter('htmlFlowData');
    effects.consume(code);
    return open
  }
  /** @type {State} */

  function open(code) {
    if (code === 33) {
      effects.consume(code);
      return declarationStart
    }

    if (code === 47) {
      effects.consume(code);
      return tagCloseStart
    }

    if (code === 63) {
      effects.consume(code);
      kind = 3; // While we’re in an instruction instead of a declaration, we’re on a `?`
      // right now, so we do need to search for `>`, similar to declarations.

      return self.interrupt ? ok : continuationDeclarationInside
    }

    if (asciiAlpha(code)) {
      effects.consume(code);
      buffer = String.fromCharCode(code);
      startTag = true;
      return tagName
    }

    return nok(code)
  }
  /** @type {State} */

  function declarationStart(code) {
    if (code === 45) {
      effects.consume(code);
      kind = 2;
      return commentOpenInside
    }

    if (code === 91) {
      effects.consume(code);
      kind = 5;
      buffer = 'CDATA[';
      index = 0;
      return cdataOpenInside
    }

    if (asciiAlpha(code)) {
      effects.consume(code);
      kind = 4;
      return self.interrupt ? ok : continuationDeclarationInside
    }

    return nok(code)
  }
  /** @type {State} */

  function commentOpenInside(code) {
    if (code === 45) {
      effects.consume(code);
      return self.interrupt ? ok : continuationDeclarationInside
    }

    return nok(code)
  }
  /** @type {State} */

  function cdataOpenInside(code) {
    if (code === buffer.charCodeAt(index++)) {
      effects.consume(code);
      return index === buffer.length
        ? self.interrupt
          ? ok
          : continuation
        : cdataOpenInside
    }

    return nok(code)
  }
  /** @type {State} */

  function tagCloseStart(code) {
    if (asciiAlpha(code)) {
      effects.consume(code);
      buffer = String.fromCharCode(code);
      return tagName
    }

    return nok(code)
  }
  /** @type {State} */

  function tagName(code) {
    if (
      code === null ||
      code === 47 ||
      code === 62 ||
      markdownLineEndingOrSpace(code)
    ) {
      if (
        code !== 47 &&
        startTag &&
        htmlRawNames.includes(buffer.toLowerCase())
      ) {
        kind = 1;
        return self.interrupt ? ok(code) : continuation(code)
      }

      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        kind = 6;

        if (code === 47) {
          effects.consume(code);
          return basicSelfClosing
        }

        return self.interrupt ? ok(code) : continuation(code)
      }

      kind = 7; // Do not support complete HTML when interrupting

      return self.interrupt && !self.parser.lazy[self.now().line]
        ? nok(code)
        : startTag
        ? completeAttributeNameBefore(code)
        : completeClosingTagAfter(code)
    }

    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code);
      buffer += String.fromCharCode(code);
      return tagName
    }

    return nok(code)
  }
  /** @type {State} */

  function basicSelfClosing(code) {
    if (code === 62) {
      effects.consume(code);
      return self.interrupt ? ok : continuation
    }

    return nok(code)
  }
  /** @type {State} */

  function completeClosingTagAfter(code) {
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeClosingTagAfter
    }

    return completeEnd(code)
  }
  /** @type {State} */

  function completeAttributeNameBefore(code) {
    if (code === 47) {
      effects.consume(code);
      return completeEnd
    }

    if (code === 58 || code === 95 || asciiAlpha(code)) {
      effects.consume(code);
      return completeAttributeName
    }

    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAttributeNameBefore
    }

    return completeEnd(code)
  }
  /** @type {State} */

  function completeAttributeName(code) {
    if (
      code === 45 ||
      code === 46 ||
      code === 58 ||
      code === 95 ||
      asciiAlphanumeric(code)
    ) {
      effects.consume(code);
      return completeAttributeName
    }

    return completeAttributeNameAfter(code)
  }
  /** @type {State} */

  function completeAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code);
      return completeAttributeValueBefore
    }

    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAttributeNameAfter
    }

    return completeAttributeNameBefore(code)
  }
  /** @type {State} */

  function completeAttributeValueBefore(code) {
    if (
      code === null ||
      code === 60 ||
      code === 61 ||
      code === 62 ||
      code === 96
    ) {
      return nok(code)
    }

    if (code === 34 || code === 39) {
      effects.consume(code);
      marker = code;
      return completeAttributeValueQuoted
    }

    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAttributeValueBefore
    }

    marker = null;
    return completeAttributeValueUnquoted(code)
  }
  /** @type {State} */

  function completeAttributeValueQuoted(code) {
    if (code === null || markdownLineEnding(code)) {
      return nok(code)
    }

    if (code === marker) {
      effects.consume(code);
      return completeAttributeValueQuotedAfter
    }

    effects.consume(code);
    return completeAttributeValueQuoted
  }
  /** @type {State} */

  function completeAttributeValueUnquoted(code) {
    if (
      code === null ||
      code === 34 ||
      code === 39 ||
      code === 60 ||
      code === 61 ||
      code === 62 ||
      code === 96 ||
      markdownLineEndingOrSpace(code)
    ) {
      return completeAttributeNameAfter(code)
    }

    effects.consume(code);
    return completeAttributeValueUnquoted
  }
  /** @type {State} */

  function completeAttributeValueQuotedAfter(code) {
    if (code === 47 || code === 62 || markdownSpace(code)) {
      return completeAttributeNameBefore(code)
    }

    return nok(code)
  }
  /** @type {State} */

  function completeEnd(code) {
    if (code === 62) {
      effects.consume(code);
      return completeAfter
    }

    return nok(code)
  }
  /** @type {State} */

  function completeAfter(code) {
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAfter
    }

    return code === null || markdownLineEnding(code)
      ? continuation(code)
      : nok(code)
  }
  /** @type {State} */

  function continuation(code) {
    if (code === 45 && kind === 2) {
      effects.consume(code);
      return continuationCommentInside
    }

    if (code === 60 && kind === 1) {
      effects.consume(code);
      return continuationRawTagOpen
    }

    if (code === 62 && kind === 4) {
      effects.consume(code);
      return continuationClose
    }

    if (code === 63 && kind === 3) {
      effects.consume(code);
      return continuationDeclarationInside
    }

    if (code === 93 && kind === 5) {
      effects.consume(code);
      return continuationCharacterDataInside
    }

    if (markdownLineEnding(code) && (kind === 6 || kind === 7)) {
      return effects.check(
        nextBlankConstruct,
        continuationClose,
        continuationAtLineEnding
      )(code)
    }

    if (code === null || markdownLineEnding(code)) {
      return continuationAtLineEnding(code)
    }

    effects.consume(code);
    return continuation
  }
  /** @type {State} */

  function continuationAtLineEnding(code) {
    effects.exit('htmlFlowData');
    return htmlContinueStart(code)
  }
  /** @type {State} */

  function htmlContinueStart(code) {
    if (code === null) {
      return done(code)
    }

    if (markdownLineEnding(code)) {
      return effects.attempt(
        {
          tokenize: htmlLineEnd,
          partial: true
        },
        htmlContinueStart,
        done
      )(code)
    }

    effects.enter('htmlFlowData');
    return continuation(code)
  }
  /** @type {Tokenizer} */

  function htmlLineEnd(effects, ok, nok) {
    return start
    /** @type {State} */

    function start(code) {
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      return lineStart
    }
    /** @type {State} */

    function lineStart(code) {
      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)
    }
  }
  /** @type {State} */

  function continuationCommentInside(code) {
    if (code === 45) {
      effects.consume(code);
      return continuationDeclarationInside
    }

    return continuation(code)
  }
  /** @type {State} */

  function continuationRawTagOpen(code) {
    if (code === 47) {
      effects.consume(code);
      buffer = '';
      return continuationRawEndTag
    }

    return continuation(code)
  }
  /** @type {State} */

  function continuationRawEndTag(code) {
    if (code === 62 && htmlRawNames.includes(buffer.toLowerCase())) {
      effects.consume(code);
      return continuationClose
    }

    if (asciiAlpha(code) && buffer.length < 8) {
      effects.consume(code);
      buffer += String.fromCharCode(code);
      return continuationRawEndTag
    }

    return continuation(code)
  }
  /** @type {State} */

  function continuationCharacterDataInside(code) {
    if (code === 93) {
      effects.consume(code);
      return continuationDeclarationInside
    }

    return continuation(code)
  }
  /** @type {State} */

  function continuationDeclarationInside(code) {
    if (code === 62) {
      effects.consume(code);
      return continuationClose
    } // More dashes.

    if (code === 45 && kind === 2) {
      effects.consume(code);
      return continuationDeclarationInside
    }

    return continuation(code)
  }
  /** @type {State} */

  function continuationClose(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('htmlFlowData');
      return done(code)
    }

    effects.consume(code);
    return continuationClose
  }
  /** @type {State} */

  function done(code) {
    effects.exit('htmlFlow');
    return ok(code)
  }
}
/** @type {Tokenizer} */

function tokenizeNextBlank(effects, ok, nok) {
  return start
  /** @type {State} */

  function start(code) {
    effects.exit('htmlFlowData');
    effects.enter('lineEndingBlank');
    effects.consume(code);
    effects.exit('lineEndingBlank');
    return effects.attempt(blankLine, ok, nok)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Code} Code
 */

/** @type {Construct} */
const htmlText = {
  name: 'htmlText',
  tokenize: tokenizeHtmlText
};
/** @type {Tokenizer} */

function tokenizeHtmlText(effects, ok, nok) {
  const self = this;
  /** @type {NonNullable<Code>|undefined} */

  let marker;
  /** @type {string} */

  let buffer;
  /** @type {number} */

  let index;
  /** @type {State} */

  let returnState;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('htmlText');
    effects.enter('htmlTextData');
    effects.consume(code);
    return open
  }
  /** @type {State} */

  function open(code) {
    if (code === 33) {
      effects.consume(code);
      return declarationOpen
    }

    if (code === 47) {
      effects.consume(code);
      return tagCloseStart
    }

    if (code === 63) {
      effects.consume(code);
      return instruction
    }

    if (asciiAlpha(code)) {
      effects.consume(code);
      return tagOpen
    }

    return nok(code)
  }
  /** @type {State} */

  function declarationOpen(code) {
    if (code === 45) {
      effects.consume(code);
      return commentOpen
    }

    if (code === 91) {
      effects.consume(code);
      buffer = 'CDATA[';
      index = 0;
      return cdataOpen
    }

    if (asciiAlpha(code)) {
      effects.consume(code);
      return declaration
    }

    return nok(code)
  }
  /** @type {State} */

  function commentOpen(code) {
    if (code === 45) {
      effects.consume(code);
      return commentStart
    }

    return nok(code)
  }
  /** @type {State} */

  function commentStart(code) {
    if (code === null || code === 62) {
      return nok(code)
    }

    if (code === 45) {
      effects.consume(code);
      return commentStartDash
    }

    return comment(code)
  }
  /** @type {State} */

  function commentStartDash(code) {
    if (code === null || code === 62) {
      return nok(code)
    }

    return comment(code)
  }
  /** @type {State} */

  function comment(code) {
    if (code === null) {
      return nok(code)
    }

    if (code === 45) {
      effects.consume(code);
      return commentClose
    }

    if (markdownLineEnding(code)) {
      returnState = comment;
      return atLineEnding(code)
    }

    effects.consume(code);
    return comment
  }
  /** @type {State} */

  function commentClose(code) {
    if (code === 45) {
      effects.consume(code);
      return end
    }

    return comment(code)
  }
  /** @type {State} */

  function cdataOpen(code) {
    if (code === buffer.charCodeAt(index++)) {
      effects.consume(code);
      return index === buffer.length ? cdata : cdataOpen
    }

    return nok(code)
  }
  /** @type {State} */

  function cdata(code) {
    if (code === null) {
      return nok(code)
    }

    if (code === 93) {
      effects.consume(code);
      return cdataClose
    }

    if (markdownLineEnding(code)) {
      returnState = cdata;
      return atLineEnding(code)
    }

    effects.consume(code);
    return cdata
  }
  /** @type {State} */

  function cdataClose(code) {
    if (code === 93) {
      effects.consume(code);
      return cdataEnd
    }

    return cdata(code)
  }
  /** @type {State} */

  function cdataEnd(code) {
    if (code === 62) {
      return end(code)
    }

    if (code === 93) {
      effects.consume(code);
      return cdataEnd
    }

    return cdata(code)
  }
  /** @type {State} */

  function declaration(code) {
    if (code === null || code === 62) {
      return end(code)
    }

    if (markdownLineEnding(code)) {
      returnState = declaration;
      return atLineEnding(code)
    }

    effects.consume(code);
    return declaration
  }
  /** @type {State} */

  function instruction(code) {
    if (code === null) {
      return nok(code)
    }

    if (code === 63) {
      effects.consume(code);
      return instructionClose
    }

    if (markdownLineEnding(code)) {
      returnState = instruction;
      return atLineEnding(code)
    }

    effects.consume(code);
    return instruction
  }
  /** @type {State} */

  function instructionClose(code) {
    return code === 62 ? end(code) : instruction(code)
  }
  /** @type {State} */

  function tagCloseStart(code) {
    if (asciiAlpha(code)) {
      effects.consume(code);
      return tagClose
    }

    return nok(code)
  }
  /** @type {State} */

  function tagClose(code) {
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagClose
    }

    return tagCloseBetween(code)
  }
  /** @type {State} */

  function tagCloseBetween(code) {
    if (markdownLineEnding(code)) {
      returnState = tagCloseBetween;
      return atLineEnding(code)
    }

    if (markdownSpace(code)) {
      effects.consume(code);
      return tagCloseBetween
    }

    return end(code)
  }
  /** @type {State} */

  function tagOpen(code) {
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagOpen
    }

    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code)
    }

    return nok(code)
  }
  /** @type {State} */

  function tagOpenBetween(code) {
    if (code === 47) {
      effects.consume(code);
      return end
    }

    if (code === 58 || code === 95 || asciiAlpha(code)) {
      effects.consume(code);
      return tagOpenAttributeName
    }

    if (markdownLineEnding(code)) {
      returnState = tagOpenBetween;
      return atLineEnding(code)
    }

    if (markdownSpace(code)) {
      effects.consume(code);
      return tagOpenBetween
    }

    return end(code)
  }
  /** @type {State} */

  function tagOpenAttributeName(code) {
    if (
      code === 45 ||
      code === 46 ||
      code === 58 ||
      code === 95 ||
      asciiAlphanumeric(code)
    ) {
      effects.consume(code);
      return tagOpenAttributeName
    }

    return tagOpenAttributeNameAfter(code)
  }
  /** @type {State} */

  function tagOpenAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code);
      return tagOpenAttributeValueBefore
    }

    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeNameAfter;
      return atLineEnding(code)
    }

    if (markdownSpace(code)) {
      effects.consume(code);
      return tagOpenAttributeNameAfter
    }

    return tagOpenBetween(code)
  }
  /** @type {State} */

  function tagOpenAttributeValueBefore(code) {
    if (
      code === null ||
      code === 60 ||
      code === 61 ||
      code === 62 ||
      code === 96
    ) {
      return nok(code)
    }

    if (code === 34 || code === 39) {
      effects.consume(code);
      marker = code;
      return tagOpenAttributeValueQuoted
    }

    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeValueBefore;
      return atLineEnding(code)
    }

    if (markdownSpace(code)) {
      effects.consume(code);
      return tagOpenAttributeValueBefore
    }

    effects.consume(code);
    marker = undefined;
    return tagOpenAttributeValueUnquoted
  }
  /** @type {State} */

  function tagOpenAttributeValueQuoted(code) {
    if (code === marker) {
      effects.consume(code);
      return tagOpenAttributeValueQuotedAfter
    }

    if (code === null) {
      return nok(code)
    }

    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeValueQuoted;
      return atLineEnding(code)
    }

    effects.consume(code);
    return tagOpenAttributeValueQuoted
  }
  /** @type {State} */

  function tagOpenAttributeValueQuotedAfter(code) {
    if (code === 62 || code === 47 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code)
    }

    return nok(code)
  }
  /** @type {State} */

  function tagOpenAttributeValueUnquoted(code) {
    if (
      code === null ||
      code === 34 ||
      code === 39 ||
      code === 60 ||
      code === 61 ||
      code === 96
    ) {
      return nok(code)
    }

    if (code === 62 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code)
    }

    effects.consume(code);
    return tagOpenAttributeValueUnquoted
  } // We can’t have blank lines in content, so no need to worry about empty
  // tokens.

  /** @type {State} */

  function atLineEnding(code) {
    effects.exit('htmlTextData');
    effects.enter('lineEnding');
    effects.consume(code);
    effects.exit('lineEnding');
    return factorySpace(
      effects,
      afterPrefix,
      'linePrefix',
      self.parser.constructs.disable.null.includes('codeIndented')
        ? undefined
        : 4
    )
  }
  /** @type {State} */

  function afterPrefix(code) {
    effects.enter('htmlTextData');
    return returnState(code)
  }
  /** @type {State} */

  function end(code) {
    if (code === 62) {
      effects.consume(code);
      effects.exit('htmlTextData');
      effects.exit('htmlText');
      return ok
    }

    return nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Code} Code
 */

/** @type {Construct} */
const labelEnd = {
  name: 'labelEnd',
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
/** @type {Construct} */

const resourceConstruct = {
  tokenize: tokenizeResource
};
/** @type {Construct} */

const fullReferenceConstruct = {
  tokenize: tokenizeFullReference
};
/** @type {Construct} */

const collapsedReferenceConstruct = {
  tokenize: tokenizeCollapsedReference
};
/** @type {Resolver} */

function resolveAllLabelEnd(events) {
  let index = -1;
  /** @type {Token} */

  let token;

  while (++index < events.length) {
    token = events[index][1];

    if (
      token.type === 'labelImage' ||
      token.type === 'labelLink' ||
      token.type === 'labelEnd'
    ) {
      // Remove the marker.
      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2);
      token.type = 'data';
      index++;
    }
  }

  return events
}
/** @type {Resolver} */

function resolveToLabelEnd(events, context) {
  let index = events.length;
  let offset = 0;
  /** @type {Token} */

  let token;
  /** @type {number|undefined} */

  let open;
  /** @type {number|undefined} */

  let close;
  /** @type {Event[]} */

  let media; // Find an opening.

  while (index--) {
    token = events[index][1];

    if (open) {
      // If we see another link, or inactive link label, we’ve been here before.
      if (
        token.type === 'link' ||
        (token.type === 'labelLink' && token._inactive)
      ) {
        break
      } // Mark other link openings as inactive, as we can’t have links in
      // links.

      if (events[index][0] === 'enter' && token.type === 'labelLink') {
        token._inactive = true;
      }
    } else if (close) {
      if (
        events[index][0] === 'enter' &&
        (token.type === 'labelImage' || token.type === 'labelLink') &&
        !token._balanced
      ) {
        open = index;

        if (token.type !== 'labelLink') {
          offset = 2;
          break
        }
      }
    } else if (token.type === 'labelEnd') {
      close = index;
    }
  }

  const group = {
    type: events[open][1].type === 'labelLink' ? 'link' : 'image',
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: 'label',
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text = {
    type: 'labelText',
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [
    ['enter', group, context],
    ['enter', label, context]
  ]; // Opening marker.

  media = push(media, events.slice(open + 1, open + offset + 3)); // Text open.

  media = push(media, [['enter', text, context]]); // Between.

  media = push(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset + 4, close - 3),
      context
    )
  ); // Text close, marker close, label close.

  media = push(media, [
    ['exit', text, context],
    events[close - 2],
    events[close - 1],
    ['exit', label, context]
  ]); // Reference, resource, or so.

  media = push(media, events.slice(close + 1)); // Media close.

  media = push(media, [['exit', group, context]]);
  splice(events, open, events.length, media);
  return events
}
/** @type {Tokenizer} */

function tokenizeLabelEnd(effects, ok, nok) {
  const self = this;
  let index = self.events.length;
  /** @type {Token} */

  let labelStart;
  /** @type {boolean} */

  let defined; // Find an opening.

  while (index--) {
    if (
      (self.events[index][1].type === 'labelImage' ||
        self.events[index][1].type === 'labelLink') &&
      !self.events[index][1]._balanced
    ) {
      labelStart = self.events[index][1];
      break
    }
  }

  return start
  /** @type {State} */

  function start(code) {
    if (!labelStart) {
      return nok(code)
    } // It’s a balanced bracket, but contains a link.

    if (labelStart._inactive) return balanced(code)
    defined = self.parser.defined.includes(
      normalizeIdentifier(
        self.sliceSerialize({
          start: labelStart.end,
          end: self.now()
        })
      )
    );
    effects.enter('labelEnd');
    effects.enter('labelMarker');
    effects.consume(code);
    effects.exit('labelMarker');
    effects.exit('labelEnd');
    return afterLabelEnd
  }
  /** @type {State} */

  function afterLabelEnd(code) {
    // Resource: `[asd](fgh)`.
    if (code === 40) {
      return effects.attempt(
        resourceConstruct,
        ok,
        defined ? ok : balanced
      )(code)
    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?

    if (code === 91) {
      return effects.attempt(
        fullReferenceConstruct,
        ok,
        defined
          ? effects.attempt(collapsedReferenceConstruct, ok, balanced)
          : balanced
      )(code)
    } // Shortcut reference: `[asd]`?

    return defined ? ok(code) : balanced(code)
  }
  /** @type {State} */

  function balanced(code) {
    labelStart._balanced = true;
    return nok(code)
  }
}
/** @type {Tokenizer} */

function tokenizeResource(effects, ok, nok) {
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('resource');
    effects.enter('resourceMarker');
    effects.consume(code);
    effects.exit('resourceMarker');
    return factoryWhitespace(effects, open)
  }
  /** @type {State} */

  function open(code) {
    if (code === 41) {
      return end(code)
    }

    return factoryDestination(
      effects,
      destinationAfter,
      nok,
      'resourceDestination',
      'resourceDestinationLiteral',
      'resourceDestinationLiteralMarker',
      'resourceDestinationRaw',
      'resourceDestinationString',
      32
    )(code)
  }
  /** @type {State} */

  function destinationAfter(code) {
    return markdownLineEndingOrSpace(code)
      ? factoryWhitespace(effects, between)(code)
      : end(code)
  }
  /** @type {State} */

  function between(code) {
    if (code === 34 || code === 39 || code === 40) {
      return factoryTitle(
        effects,
        factoryWhitespace(effects, end),
        nok,
        'resourceTitle',
        'resourceTitleMarker',
        'resourceTitleString'
      )(code)
    }

    return end(code)
  }
  /** @type {State} */

  function end(code) {
    if (code === 41) {
      effects.enter('resourceMarker');
      effects.consume(code);
      effects.exit('resourceMarker');
      effects.exit('resource');
      return ok
    }

    return nok(code)
  }
}
/** @type {Tokenizer} */

function tokenizeFullReference(effects, ok, nok) {
  const self = this;
  return start
  /** @type {State} */

  function start(code) {
    return factoryLabel.call(
      self,
      effects,
      afterLabel,
      nok,
      'reference',
      'referenceMarker',
      'referenceString'
    )(code)
  }
  /** @type {State} */

  function afterLabel(code) {
    return self.parser.defined.includes(
      normalizeIdentifier(
        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
      )
    )
      ? ok(code)
      : nok(code)
  }
}
/** @type {Tokenizer} */

function tokenizeCollapsedReference(effects, ok, nok) {
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('reference');
    effects.enter('referenceMarker');
    effects.consume(code);
    effects.exit('referenceMarker');
    return open
  }
  /** @type {State} */

  function open(code) {
    if (code === 93) {
      effects.enter('referenceMarker');
      effects.consume(code);
      effects.exit('referenceMarker');
      effects.exit('reference');
      return ok
    }

    return nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 */
/** @type {Construct} */

const labelStartImage = {
  name: 'labelStartImage',
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
/** @type {Tokenizer} */

function tokenizeLabelStartImage(effects, ok, nok) {
  const self = this;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('labelImage');
    effects.enter('labelImageMarker');
    effects.consume(code);
    effects.exit('labelImageMarker');
    return open
  }
  /** @type {State} */

  function open(code) {
    if (code === 91) {
      effects.enter('labelMarker');
      effects.consume(code);
      effects.exit('labelMarker');
      effects.exit('labelImage');
      return after
    }

    return nok(code)
  }
  /** @type {State} */

  function after(code) {
    /* To do: remove in the future once we’ve switched from
     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
     * which doesn’t need this */

    /* Hidden footnotes hook */

    /* c8 ignore next 3 */
    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs
      ? nok(code)
      : ok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 */
/** @type {Construct} */

const labelStartLink = {
  name: 'labelStartLink',
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
/** @type {Tokenizer} */

function tokenizeLabelStartLink(effects, ok, nok) {
  const self = this;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('labelLink');
    effects.enter('labelMarker');
    effects.consume(code);
    effects.exit('labelMarker');
    effects.exit('labelLink');
    return after
  }
  /** @type {State} */

  function after(code) {
    /* To do: remove in the future once we’ve switched from
     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
     * which doesn’t need this */

    /* Hidden footnotes hook. */

    /* c8 ignore next 3 */
    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs
      ? nok(code)
      : ok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 */

/** @type {Construct} */
const lineEnding = {
  name: 'lineEnding',
  tokenize: tokenizeLineEnding
};
/** @type {Tokenizer} */

function tokenizeLineEnding(effects, ok) {
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('lineEnding');
    effects.consume(code);
    effects.exit('lineEnding');
    return factorySpace(effects, ok, 'linePrefix')
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Code} Code
 */

/** @type {Construct} */
const thematicBreak = {
  name: 'thematicBreak',
  tokenize: tokenizeThematicBreak
};
/** @type {Tokenizer} */

function tokenizeThematicBreak(effects, ok, nok) {
  let size = 0;
  /** @type {NonNullable<Code>} */

  let marker;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('thematicBreak');
    marker = code;
    return atBreak(code)
  }
  /** @type {State} */

  function atBreak(code) {
    if (code === marker) {
      effects.enter('thematicBreakSequence');
      return sequence(code)
    }

    if (markdownSpace(code)) {
      return factorySpace(effects, atBreak, 'whitespace')(code)
    }

    if (size < 3 || (code !== null && !markdownLineEnding(code))) {
      return nok(code)
    }

    effects.exit('thematicBreak');
    return ok(code)
  }
  /** @type {State} */

  function sequence(code) {
    if (code === marker) {
      effects.consume(code);
      size++;
      return sequence
    }

    effects.exit('thematicBreakSequence');
    return atBreak(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Exiter} Exiter
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Code} Code
 */
/** @type {Construct} */

const list = {
  name: 'list',
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
/** @type {Construct} */

const listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
/** @type {Construct} */

const indentConstruct = {
  tokenize: tokenizeIndent$1,
  partial: true
};
/**
 * @type {Tokenizer}
 * @this {TokenizeContextWithState}
 */

function tokenizeListStart(effects, ok, nok) {
  const self = this;
  const tail = self.events[self.events.length - 1];
  let initialSize =
    tail && tail[1].type === 'linePrefix'
      ? tail[2].sliceSerialize(tail[1], true).length
      : 0;
  let size = 0;
  return start
  /** @type {State} */

  function start(code) {
    const kind =
      self.containerState.type ||
      (code === 42 || code === 43 || code === 45
        ? 'listUnordered'
        : 'listOrdered');

    if (
      kind === 'listUnordered'
        ? !self.containerState.marker || code === self.containerState.marker
        : asciiDigit(code)
    ) {
      if (!self.containerState.type) {
        self.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }

      if (kind === 'listUnordered') {
        effects.enter('listItemPrefix');
        return code === 42 || code === 45
          ? effects.check(thematicBreak, nok, atMarker)(code)
          : atMarker(code)
      }

      if (!self.interrupt || code === 49) {
        effects.enter('listItemPrefix');
        effects.enter('listItemValue');
        return inside(code)
      }
    }

    return nok(code)
  }
  /** @type {State} */

  function inside(code) {
    if (asciiDigit(code) && ++size < 10) {
      effects.consume(code);
      return inside
    }

    if (
      (!self.interrupt || size < 2) &&
      (self.containerState.marker
        ? code === self.containerState.marker
        : code === 41 || code === 46)
    ) {
      effects.exit('listItemValue');
      return atMarker(code)
    }

    return nok(code)
  }
  /**
   * @type {State}
   **/

  function atMarker(code) {
    effects.enter('listItemMarker');
    effects.consume(code);
    effects.exit('listItemMarker');
    self.containerState.marker = self.containerState.marker || code;
    return effects.check(
      blankLine, // Can’t be empty when interrupting.
      self.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    )
  }
  /** @type {State} */

  function onBlank(code) {
    self.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code)
  }
  /** @type {State} */

  function otherPrefix(code) {
    if (markdownSpace(code)) {
      effects.enter('listItemPrefixWhitespace');
      effects.consume(code);
      effects.exit('listItemPrefixWhitespace');
      return endOfPrefix
    }

    return nok(code)
  }
  /** @type {State} */

  function endOfPrefix(code) {
    self.containerState.size =
      initialSize +
      self.sliceSerialize(effects.exit('listItemPrefix'), true).length;
    return ok(code)
  }
}
/**
 * @type {Tokenizer}
 * @this {TokenizeContextWithState}
 */

function tokenizeListContinuation(effects, ok, nok) {
  const self = this;
  self.containerState._closeFlow = undefined;
  return effects.check(blankLine, onBlank, notBlank)
  /** @type {State} */

  function onBlank(code) {
    self.containerState.furtherBlankLines =
      self.containerState.furtherBlankLines ||
      self.containerState.initialBlankLine; // We have a blank line.
    // Still, try to consume at most the items size.

    return factorySpace(
      effects,
      ok,
      'listItemIndent',
      self.containerState.size + 1
    )(code)
  }
  /** @type {State} */

  function notBlank(code) {
    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {
      self.containerState.furtherBlankLines = undefined;
      self.containerState.initialBlankLine = undefined;
      return notInCurrentItem(code)
    }

    self.containerState.furtherBlankLines = undefined;
    self.containerState.initialBlankLine = undefined;
    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)
  }
  /** @type {State} */

  function notInCurrentItem(code) {
    // While we do continue, we signal that the flow should be closed.
    self.containerState._closeFlow = true; // As we’re closing flow, we’re no longer interrupting.

    self.interrupt = undefined;
    return factorySpace(
      effects,
      effects.attempt(list, ok, nok),
      'linePrefix',
      self.parser.constructs.disable.null.includes('codeIndented')
        ? undefined
        : 4
    )(code)
  }
}
/**
 * @type {Tokenizer}
 * @this {TokenizeContextWithState}
 */

function tokenizeIndent$1(effects, ok, nok) {
  const self = this;
  return factorySpace(
    effects,
    afterPrefix,
    'listItemIndent',
    self.containerState.size + 1
  )
  /** @type {State} */

  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return tail &&
      tail[1].type === 'listItemIndent' &&
      tail[2].sliceSerialize(tail[1], true).length === self.containerState.size
      ? ok(code)
      : nok(code)
  }
}
/**
 * @type {Exiter}
 * @this {TokenizeContextWithState}
 */

function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
/**
 * @type {Tokenizer}
 * @this {TokenizeContextWithState}
 */

function tokenizeListItemPrefixWhitespace(effects, ok, nok) {
  const self = this;
  return factorySpace(
    effects,
    afterPrefix,
    'listItemPrefixWhitespace',
    self.parser.constructs.disable.null.includes('codeIndented')
      ? undefined
      : 4 + 1
  )
  /** @type {State} */

  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return !markdownSpace(code) &&
      tail &&
      tail[1].type === 'listItemPrefixWhitespace'
      ? ok(code)
      : nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Code} Code
 */

/** @type {Construct} */
const setextUnderline = {
  name: 'setextUnderline',
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
/** @type {Resolver} */

function resolveToSetextUnderline(events, context) {
  let index = events.length;
  /** @type {number|undefined} */

  let content;
  /** @type {number|undefined} */

  let text;
  /** @type {number|undefined} */

  let definition; // Find the opening of the content.
  // It’ll always exist: we don’t tokenize if it isn’t there.

  while (index--) {
    if (events[index][0] === 'enter') {
      if (events[index][1].type === 'content') {
        content = index;
        break
      }

      if (events[index][1].type === 'paragraph') {
        text = index;
      }
    } // Exit
    else {
      if (events[index][1].type === 'content') {
        // Remove the content end (if needed we’ll add it later)
        events.splice(index, 1);
      }

      if (!definition && events[index][1].type === 'definition') {
        definition = index;
      }
    }
  }

  const heading = {
    type: 'setextHeading',
    start: Object.assign({}, events[text][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  }; // Change the paragraph to setext heading text.

  events[text][1].type = 'setextHeadingText'; // If we have definitions in the content, we’ll keep on having content,
  // but we need move it.

  if (definition) {
    events.splice(text, 0, ['enter', heading, context]);
    events.splice(definition + 1, 0, ['exit', events[content][1], context]);
    events[content][1].end = Object.assign({}, events[definition][1].end);
  } else {
    events[content][1] = heading;
  } // Add the heading exit at the end.

  events.push(['exit', heading, context]);
  return events
}
/** @type {Tokenizer} */

function tokenizeSetextUnderline(effects, ok, nok) {
  const self = this;
  let index = self.events.length;
  /** @type {NonNullable<Code>} */

  let marker;
  /** @type {boolean} */

  let paragraph; // Find an opening.

  while (index--) {
    // Skip enter/exit of line ending, line prefix, and content.
    // We can now either have a definition or a paragraph.
    if (
      self.events[index][1].type !== 'lineEnding' &&
      self.events[index][1].type !== 'linePrefix' &&
      self.events[index][1].type !== 'content'
    ) {
      paragraph = self.events[index][1].type === 'paragraph';
      break
    }
  }

  return start
  /** @type {State} */

  function start(code) {
    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {
      effects.enter('setextHeadingLine');
      effects.enter('setextHeadingLineSequence');
      marker = code;
      return closingSequence(code)
    }

    return nok(code)
  }
  /** @type {State} */

  function closingSequence(code) {
    if (code === marker) {
      effects.consume(code);
      return closingSequence
    }

    effects.exit('setextHeadingLineSequence');
    return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code)
  }
  /** @type {State} */

  function closingSequenceEnd(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('setextHeadingLine');
      return ok(code)
    }

    return nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').Initializer} Initializer
 * @typedef {import('micromark-util-types').State} State
 */

/** @type {InitialConstruct} */
const flow$1 = {
  tokenize: initializeFlow
};
/** @type {Initializer} */

function initializeFlow(effects) {
  const self = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding, // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content, afterConstruct)
        ),
        'linePrefix'
      )
    )
  );
  return initial
  /** @type {State} */

  function atBlankEnding(code) {
    if (code === null) {
      effects.consume(code);
      return
    }

    effects.enter('lineEndingBlank');
    effects.consume(code);
    effects.exit('lineEndingBlank');
    self.currentConstruct = undefined;
    return initial
  }
  /** @type {State} */

  function afterConstruct(code) {
    if (code === null) {
      effects.consume(code);
      return
    }

    effects.enter('lineEnding');
    effects.consume(code);
    effects.exit('lineEnding');
    self.currentConstruct = undefined;
    return initial
  }
}

/**
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').Initializer} Initializer
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Code} Code
 */
const resolver = {
  resolveAll: createResolver()
};
const string$1 = initializeFactory('string');
const text$2 = initializeFactory('text');
/**
 * @param {'string'|'text'} field
 * @returns {InitialConstruct}
 */

function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === 'text' ? resolveAllLineSuffixes : undefined
    )
  }
  /** @type {Initializer} */

  function initializeText(effects) {
    const self = this;
    const constructs = this.parser.constructs[field];
    const text = effects.attempt(constructs, start, notText);
    return start
    /** @type {State} */

    function start(code) {
      return atBreak(code) ? text(code) : notText(code)
    }
    /** @type {State} */

    function notText(code) {
      if (code === null) {
        effects.consume(code);
        return
      }

      effects.enter('data');
      effects.consume(code);
      return data
    }
    /** @type {State} */

    function data(code) {
      if (atBreak(code)) {
        effects.exit('data');
        return text(code)
      } // Data.

      effects.consume(code);
      return data
    }
    /**
     * @param {Code} code
     * @returns {boolean}
     */

    function atBreak(code) {
      if (code === null) {
        return true
      }

      const list = constructs[code];
      let index = -1;

      if (list) {
        while (++index < list.length) {
          const item = list[index];

          if (!item.previous || item.previous.call(self, self.previous)) {
            return true
          }
        }
      }

      return false
    }
  }
}
/**
 * @param {Resolver} [extraResolver]
 * @returns {Resolver}
 */

function createResolver(extraResolver) {
  return resolveAllText
  /** @type {Resolver} */

  function resolveAllText(events, context) {
    let index = -1;
    /** @type {number|undefined} */

    let enter; // A rather boring computation (to merge adjacent `data` events) which
    // improves mm performance by 29%.

    while (++index <= events.length) {
      if (enter === undefined) {
        if (events[index] && events[index][1].type === 'data') {
          enter = index;
          index++;
        }
      } else if (!events[index] || events[index][1].type !== 'data') {
        // Don’t do anything if there is one data token.
        if (index !== enter + 2) {
          events[enter][1].end = events[index - 1][1].end;
          events.splice(enter + 2, index - enter - 2);
          index = enter + 2;
        }

        enter = undefined;
      }
    }

    return extraResolver ? extraResolver(events, context) : events
  }
}
/**
 * A rather ugly set of instructions which again looks at chunks in the input
 * stream.
 * The reason to do this here is that it is *much* faster to parse in reverse.
 * And that we can’t hook into `null` to split the line suffix before an EOF.
 * To do: figure out if we can make this into a clean utility, or even in core.
 * As it will be useful for GFMs literal autolink extension (and maybe even
 * tables?)
 *
 * @type {Resolver}
 */

function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0; // Skip first.

  while (++eventIndex <= events.length) {
    if (
      (eventIndex === events.length ||
        events[eventIndex][1].type === 'lineEnding') &&
      events[eventIndex - 1][1].type === 'data'
    ) {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      /** @type {boolean|undefined} */

      let tabs;

      while (index--) {
        const chunk = chunks[index];

        if (typeof chunk === 'string') {
          bufferIndex = chunk.length;

          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }

          if (bufferIndex) break
          bufferIndex = -1;
        } // Number
        else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1) ; else {
          // Replacement character, exit.
          index++;
          break
        }
      }

      if (size) {
        const token = {
          type:
            eventIndex === events.length || tabs || size < 2
              ? 'lineSuffix'
              : 'hardBreakTrailing',
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index,
            _bufferIndex: index
              ? bufferIndex
              : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token.start);

        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ['enter', token, context],
            ['exit', token, context]
          );
          eventIndex += 2;
        }
      }

      eventIndex++;
    }
  }

  return events
}

/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Chunk} Chunk
 * @typedef {import('micromark-util-types').Point} Point
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').ParseContext} ParseContext
 */

/**
 * Create a tokenizer.
 * Tokenizers deal with one type of data (e.g., containers, flow, text).
 * The parser is the object dealing with it all.
 * `initialize` works like other constructs, except that only its `tokenize`
 * function is used, in which case it doesn’t receive an `ok` or `nok`.
 * `from` can be given to set the point before the first character, although
 * when further lines are indented, they must be set with `defineSkip`.
 *
 * @param {ParseContext} parser
 * @param {InitialConstruct} initialize
 * @param {Omit<Point, '_index'|'_bufferIndex'>} [from]
 * @returns {TokenizeContext}
 */
function createTokenizer(parser, initialize, from) {
  /** @type {Point} */
  let point = Object.assign(
    from
      ? Object.assign({}, from)
      : {
          line: 1,
          column: 1,
          offset: 0
        },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  /** @type {Record<string, number>} */

  const columnStart = {};
  /** @type {Construct[]} */

  const resolveAllConstructs = [];
  /** @type {Chunk[]} */

  let chunks = [];
  /** @type {Token[]} */

  let stack = [];
  /**
   * Tools used for tokenizing.
   *
   * @type {Effects}
   */

  const effects = {
    consume,
    enter,
    exit,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  /**
   * State and tools for resolving and serializing.
   *
   * @type {TokenizeContext}
   */

  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  /**
   * The state function.
   *
   * @type {State|void}
   */

  let state = initialize.tokenize.call(context, effects);

  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }

  return context
  /** @type {TokenizeContext['write']} */

  function write(slice) {
    chunks = push(chunks, slice);
    main(); // Exit if we’re not done, resolve might change stuff.

    if (chunks[chunks.length - 1] !== null) {
      return []
    }

    addResult(initialize, 0); // Otherwise, resolve, and exit.

    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events
  } //
  // Tools.
  //

  /** @type {TokenizeContext['sliceSerialize']} */

  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs)
  }
  /** @type {TokenizeContext['sliceStream']} */

  function sliceStream(token) {
    return sliceChunks(chunks, token)
  }
  /** @type {TokenizeContext['now']} */

  function now() {
    return Object.assign({}, point)
  }
  /** @type {TokenizeContext['defineSkip']} */

  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  } //
  // State management.
  //

  /**
   * Main loop (note that `_index` and `_bufferIndex` in `point` are modified by
   * `consume`).
   * Here is where we walk through the chunks, which either include strings of
   * several characters, or numerical character codes.
   * The reason to do this in a loop instead of a call is so the stack can
   * drain.
   *
   * @returns {void}
   */

  function main() {
    /** @type {number} */
    let chunkIndex;

    while (point._index < chunks.length) {
      const chunk = chunks[point._index]; // If we’re in a buffer chunk, loop through it.

      if (typeof chunk === 'string') {
        chunkIndex = point._index;

        if (point._bufferIndex < 0) {
          point._bufferIndex = 0;
        }

        while (
          point._index === chunkIndex &&
          point._bufferIndex < chunk.length
        ) {
          go(chunk.charCodeAt(point._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  /**
   * Deal with one code.
   *
   * @param {Code} code
   * @returns {void}
   */

  function go(code) {
    state = state(code);
  }
  /** @type {Effects['consume']} */

  function consume(code) {
    if (markdownLineEnding(code)) {
      point.line++;
      point.column = 1;
      point.offset += code === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code !== -1) {
      point.column++;
      point.offset++;
    } // Not in a string chunk.

    if (point._bufferIndex < 0) {
      point._index++;
    } else {
      point._bufferIndex++; // At end of string chunk.
      // @ts-expect-error Points w/ non-negative `_bufferIndex` reference
      // strings.

      if (point._bufferIndex === chunks[point._index].length) {
        point._bufferIndex = -1;
        point._index++;
      }
    } // Expose the previous character.

    context.previous = code; // Mark as consumed.
  }
  /** @type {Effects['enter']} */

  function enter(type, fields) {
    /** @type {Token} */
    // @ts-expect-error Patch instead of assign required fields to help GC.
    const token = fields || {};
    token.type = type;
    token.start = now();
    context.events.push(['enter', token, context]);
    stack.push(token);
    return token
  }
  /** @type {Effects['exit']} */

  function exit(type) {
    const token = stack.pop();
    token.end = now();
    context.events.push(['exit', token, context]);
    return token
  }
  /**
   * Use results.
   *
   * @type {ReturnHandle}
   */

  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  /**
   * Discard results.
   *
   * @type {ReturnHandle}
   */

  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  /**
   * Factory to attempt/check/interrupt.
   *
   * @param {ReturnHandle} onreturn
   * @param {Record<string, unknown>} [fields]
   */

  function constructFactory(onreturn, fields) {
    return hook
    /**
     * Handle either an object mapping codes to constructs, a list of
     * constructs, or a single construct.
     *
     * @param {Construct|Construct[]|ConstructRecord} constructs
     * @param {State} returnState
     * @param {State} [bogusState]
     * @returns {State}
     */

    function hook(constructs, returnState, bogusState) {
      /** @type {Construct[]} */
      let listOfConstructs;
      /** @type {number} */

      let constructIndex;
      /** @type {Construct} */

      let currentConstruct;
      /** @type {Info} */

      let info;
      return Array.isArray(constructs)
        ? /* c8 ignore next 1 */
          handleListOfConstructs(constructs)
        : 'tokenize' in constructs // @ts-expect-error Looks like a construct.
        ? handleListOfConstructs([constructs])
        : handleMapOfConstructs(constructs)
      /**
       * Handle a list of construct.
       *
       * @param {ConstructRecord} map
       * @returns {State}
       */

      function handleMapOfConstructs(map) {
        return start
        /** @type {State} */

        function start(code) {
          const def = code !== null && map[code];
          const all = code !== null && map.null;
          const list = [
            // To do: add more extension tests.

            /* c8 ignore next 2 */
            ...(Array.isArray(def) ? def : def ? [def] : []),
            ...(Array.isArray(all) ? all : all ? [all] : [])
          ];
          return handleListOfConstructs(list)(code)
        }
      }
      /**
       * Handle a list of construct.
       *
       * @param {Construct[]} list
       * @returns {State}
       */

      function handleListOfConstructs(list) {
        listOfConstructs = list;
        constructIndex = 0;

        if (list.length === 0) {
          return bogusState
        }

        return handleConstruct(list[constructIndex])
      }
      /**
       * Handle a single construct.
       *
       * @param {Construct} construct
       * @returns {State}
       */

      function handleConstruct(construct) {
        return start
        /** @type {State} */

        function start(code) {
          // To do: not needed to store if there is no bogus state, probably?
          // Currently doesn’t work because `inspect` in document does a check
          // w/o a bogus, which doesn’t make sense. But it does seem to help perf
          // by not storing.
          info = store();
          currentConstruct = construct;

          if (!construct.partial) {
            context.currentConstruct = construct;
          }

          if (
            construct.name &&
            context.parser.constructs.disable.null.includes(construct.name)
          ) {
            return nok()
          }

          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok,
            nok
          )(code)
        }
      }
      /** @type {State} */

      function ok(code) {
        onreturn(currentConstruct, info);
        return returnState
      }
      /** @type {State} */

      function nok(code) {
        info.restore();

        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex])
        }

        return bogusState
      }
    }
  }
  /**
   * @param {Construct} construct
   * @param {number} from
   * @returns {void}
   */

  function addResult(construct, from) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }

    if (construct.resolve) {
      splice(
        context.events,
        from,
        context.events.length - from,
        construct.resolve(context.events.slice(from), context)
      );
    }

    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  /**
   * Store state.
   *
   * @returns {Info}
   */

  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    }
    /**
     * Restore state.
     *
     * @returns {void}
     */

    function restore() {
      point = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  /**
   * Move the current point a bit forward in the line when it’s on a column
   * skip.
   *
   * @returns {void}
   */

  function accountForPotentialSkip() {
    if (point.line in columnStart && point.column < 2) {
      point.column = columnStart[point.line];
      point.offset += columnStart[point.line] - 1;
    }
  }
}
/**
 * Get the chunks from a slice of chunks in the range of a token.
 *
 * @param {Chunk[]} chunks
 * @param {Pick<Token, 'start'|'end'>} token
 * @returns {Chunk[]}
 */

function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  /** @type {Chunk[]} */

  let view;

  if (startIndex === endIndex) {
    // @ts-expect-error `_bufferIndex` is used on string chunks.
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);

    if (startBufferIndex > -1) {
      // @ts-expect-error `_bufferIndex` is used on string chunks.
      view[0] = view[0].slice(startBufferIndex);
    }

    if (endBufferIndex > 0) {
      // @ts-expect-error `_bufferIndex` is used on string chunks.
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }

  return view
}
/**
 * Get the string value of a slice of chunks.
 *
 * @param {Chunk[]} chunks
 * @param {boolean} [expandTabs=false]
 * @returns {string}
 */

function serializeChunks(chunks, expandTabs) {
  let index = -1;
  /** @type {string[]} */

  const result = [];
  /** @type {boolean|undefined} */

  let atTab;

  while (++index < chunks.length) {
    const chunk = chunks[index];
    /** @type {string} */

    let value;

    if (typeof chunk === 'string') {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = '\r';
          break
        }

        case -4: {
          value = '\n';
          break
        }

        case -3: {
          value = '\r' + '\n';
          break
        }

        case -2: {
          value = expandTabs ? ' ' : '\t';
          break
        }

        case -1: {
          if (!expandTabs && atTab) continue
          value = ' ';
          break
        }

        default: {
          // Currently only replacement character.
          value = String.fromCharCode(chunk);
        }
      }

    atTab = chunk === -2;
    result.push(value);
  }

  return result.join('')
}

/**
 * @typedef {import('micromark-util-types').Extension} Extension
 */
/** @type {Extension['document']} */

const document$1 = {
  [42]: list,
  [43]: list,
  [45]: list,
  [48]: list,
  [49]: list,
  [50]: list,
  [51]: list,
  [52]: list,
  [53]: list,
  [54]: list,
  [55]: list,
  [56]: list,
  [57]: list,
  [62]: blockQuote
};
/** @type {Extension['contentInitial']} */

const contentInitial = {
  [91]: definition
};
/** @type {Extension['flowInitial']} */

const flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
/** @type {Extension['flow']} */

const flow = {
  [35]: headingAtx,
  [42]: thematicBreak,
  [45]: [setextUnderline, thematicBreak],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak,
  [96]: codeFenced,
  [126]: codeFenced
};
/** @type {Extension['string']} */

const string = {
  [38]: characterReference,
  [92]: characterEscape
};
/** @type {Extension['text']} */

const text$1 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
/** @type {Extension['insideSpan']} */

const insideSpan = {
  null: [attention, resolver]
};
/** @type {Extension['attentionMarkers']} */

const attentionMarkers = {
  null: [42, 95]
};
/** @type {Extension['disable']} */

const disable = {
  null: []
};

var defaultConstructs = /*#__PURE__*/Object.freeze({
    __proto__: null,
    document: document$1,
    contentInitial: contentInitial,
    flowInitial: flowInitial,
    flow: flow,
    string: string,
    text: text$1,
    insideSpan: insideSpan,
    attentionMarkers: attentionMarkers,
    disable: disable
});

/**
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').FullNormalizedExtension} FullNormalizedExtension
 * @typedef {import('micromark-util-types').ParseOptions} ParseOptions
 * @typedef {import('micromark-util-types').ParseContext} ParseContext
 * @typedef {import('micromark-util-types').Create} Create
 */
/**
 * @param {ParseOptions} [options]
 * @returns {ParseContext}
 */

function parse$1(options = {}) {
  /** @type {FullNormalizedExtension} */
  // @ts-expect-error `defaultConstructs` is full, so the result will be too.
  const constructs = combineExtensions(
    // @ts-expect-error Same as above.
    [defaultConstructs].concat(options.extensions || [])
  );
  /** @type {ParseContext} */

  const parser = {
    defined: [],
    lazy: {},
    constructs,
    content: create(content$1),
    document: create(document$2),
    flow: create(flow$1),
    string: create(string$1),
    text: create(text$2)
  };
  return parser
  /**
   * @param {InitialConstruct} initial
   */

  function create(initial) {
    return creator
    /** @type {Create} */

    function creator(from) {
      return createTokenizer(parser, initial, from)
    }
  }
}

/**
 * @typedef {import('micromark-util-types').Encoding} Encoding
 * @typedef {import('micromark-util-types').Value} Value
 * @typedef {import('micromark-util-types').Chunk} Chunk
 * @typedef {import('micromark-util-types').Code} Code
 */

/**
 * @callback Preprocessor
 * @param {Value} value
 * @param {Encoding} [encoding]
 * @param {boolean} [end=false]
 * @returns {Chunk[]}
 */
const search = /[\0\t\n\r]/g;
/**
 * @returns {Preprocessor}
 */

function preprocess() {
  let column = 1;
  let buffer = '';
  /** @type {boolean|undefined} */

  let start = true;
  /** @type {boolean|undefined} */

  let atCarriageReturn;
  return preprocessor
  /** @type {Preprocessor} */

  function preprocessor(value, encoding, end) {
    /** @type {Chunk[]} */
    const chunks = [];
    /** @type {RegExpMatchArray|null} */

    let match;
    /** @type {number} */

    let next;
    /** @type {number} */

    let startPosition;
    /** @type {number} */

    let endPosition;
    /** @type {Code} */

    let code; // @ts-expect-error `Buffer` does allow an encoding.

    value = buffer + value.toString(encoding);
    startPosition = 0;
    buffer = '';

    if (start) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }

      start = undefined;
    }

    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition =
        match && match.index !== undefined ? match.index : value.length;
      code = value.charCodeAt(endPosition);

      if (!match) {
        buffer = value.slice(startPosition);
        break
      }

      if (code === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = undefined;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = undefined;
        }

        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }

        switch (code) {
          case 0: {
            chunks.push(65533);
            column++;
            break
          }

          case 9: {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);

            while (column++ < next) chunks.push(-1);

            break
          }

          case 10: {
            chunks.push(-4);
            column = 1;
            break
          }

          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }

      startPosition = endPosition + 1;
    }

    if (end) {
      if (atCarriageReturn) chunks.push(-5);
      if (buffer) chunks.push(buffer);
      chunks.push(null);
    }

    return chunks
  }
}

/**
 * @typedef {import('micromark-util-types').Event} Event
 */
/**
 * @param {Event[]} events
 * @returns {Event[]}
 */

function postprocess(events) {
  while (!subtokenize(events)) {
    // Empty
  }

  return events
}

/**
 * Turn the number (in string form as either hexa- or plain decimal) coming from
 * a numeric character reference into a character.
 *
 * @param {string} value
 *   Value to decode.
 * @param {number} base
 *   Numeric base.
 * @returns {string}
 */
function decodeNumericCharacterReference(value, base) {
  const code = Number.parseInt(value, base);

  if (
    // C0 except for HT, LF, FF, CR, space
    code < 9 ||
    code === 11 ||
    (code > 13 && code < 32) || // Control character (DEL) of the basic block and C1 controls.
    (code > 126 && code < 160) || // Lone high surrogates and low surrogates.
    (code > 55295 && code < 57344) || // Noncharacters.
    (code > 64975 && code < 65008) ||
    (code & 65535) === 65535 ||
    (code & 65535) === 65534 || // Out of range
    code > 1114111
  ) {
    return '\uFFFD'
  }

  return String.fromCharCode(code)
}

const characterEscapeOrReference =
  /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
/**
 * Utility to decode markdown strings (which occur in places such as fenced
 * code info strings, destinations, labels, and titles).
 * The “string” content type allows character escapes and -references.
 * This decodes those.
 *
 * @param {string} value
 * @returns {string}
 */

function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode)
}
/**
 * @param {string} $0
 * @param {string} $1
 * @param {string} $2
 * @returns {string}
 */

function decode($0, $1, $2) {
  if ($1) {
    // Escape.
    return $1
  } // Reference.

  const head = $2.charCodeAt(0);

  if (head === 35) {
    const head = $2.charCodeAt(1);
    const hex = head === 120 || head === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10)
  }

  return decodeNamedCharacterReference($2) || $0
}

/**
 * @typedef {import('micromark-util-types').Encoding} Encoding
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').ParseOptions} ParseOptions
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Value} Value
 * @typedef {import('unist').Parent} UnistParent
 * @typedef {import('unist').Point} Point
 * @typedef {import('mdast').PhrasingContent} PhrasingContent
 * @typedef {import('mdast').Content} Content
 * @typedef {Root|Content} Node
 * @typedef {Extract<Node, UnistParent>} Parent
 * @typedef {import('mdast').Break} Break
 * @typedef {import('mdast').Blockquote} Blockquote
 * @typedef {import('mdast').Code} Code
 * @typedef {import('mdast').Definition} Definition
 * @typedef {import('mdast').Emphasis} Emphasis
 * @typedef {import('mdast').Heading} Heading
 * @typedef {import('mdast').HTML} HTML
 * @typedef {import('mdast').Image} Image
 * @typedef {import('mdast').ImageReference} ImageReference
 * @typedef {import('mdast').InlineCode} InlineCode
 * @typedef {import('mdast').Link} Link
 * @typedef {import('mdast').LinkReference} LinkReference
 * @typedef {import('mdast').List} List
 * @typedef {import('mdast').ListItem} ListItem
 * @typedef {import('mdast').Paragraph} Paragraph
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast').Strong} Strong
 * @typedef {import('mdast').Text} Text
 * @typedef {import('mdast').ThematicBreak} ThematicBreak
 *
 * @typedef {UnistParent & {type: 'fragment', children: Array<PhrasingContent>}} Fragment
 */
const own$2 = {}.hasOwnProperty;
/**
 * @param value Markdown to parse (`string` or `Buffer`).
 * @param [encoding] Character encoding to understand `value` as when it’s a `Buffer` (`string`, default: `'utf8'`).
 * @param [options] Configuration
 */

const fromMarkdown =
  /**
   * @type {(
   *   ((value: Value, encoding: Encoding, options?: Options) => Root) &
   *   ((value: Value, options?: Options) => Root)
   * )}
   */

  /**
   * @param {Value} value
   * @param {Encoding} [encoding]
   * @param {Options} [options]
   * @returns {Root}
   */
  function (value, encoding, options) {
    if (typeof encoding !== 'string') {
      options = encoding;
      encoding = undefined;
    }

    return compiler(options)(
      postprocess(
        parse$1(options).document().write(preprocess()(value, encoding, true))
      )
    )
  };
/**
 * Note this compiler only understand complete buffering, not streaming.
 *
 * @param {Options} [options]
 */

function compiler(options = {}) {
  /** @type {NormalizedExtension} */
  // @ts-expect-error: our base has all required fields, so the result will too.
  const config = configure(
    {
      transforms: [],
      canContainEols: [
        'emphasis',
        'fragment',
        'heading',
        'paragraph',
        'strong'
      ],
      enter: {
        autolink: opener(link),
        autolinkProtocol: onenterdata,
        autolinkEmail: onenterdata,
        atxHeading: opener(heading),
        blockQuote: opener(blockQuote),
        characterEscape: onenterdata,
        characterReference: onenterdata,
        codeFenced: opener(codeFlow),
        codeFencedFenceInfo: buffer,
        codeFencedFenceMeta: buffer,
        codeIndented: opener(codeFlow, buffer),
        codeText: opener(codeText, buffer),
        codeTextData: onenterdata,
        data: onenterdata,
        codeFlowValue: onenterdata,
        definition: opener(definition),
        definitionDestinationString: buffer,
        definitionLabelString: buffer,
        definitionTitleString: buffer,
        emphasis: opener(emphasis),
        hardBreakEscape: opener(hardBreak),
        hardBreakTrailing: opener(hardBreak),
        htmlFlow: opener(html, buffer),
        htmlFlowData: onenterdata,
        htmlText: opener(html, buffer),
        htmlTextData: onenterdata,
        image: opener(image),
        label: buffer,
        link: opener(link),
        listItem: opener(listItem),
        listItemValue: onenterlistitemvalue,
        listOrdered: opener(list, onenterlistordered),
        listUnordered: opener(list),
        paragraph: opener(paragraph),
        reference: onenterreference,
        referenceString: buffer,
        resourceDestinationString: buffer,
        resourceTitleString: buffer,
        setextHeading: opener(heading),
        strong: opener(strong),
        thematicBreak: opener(thematicBreak)
      },
      exit: {
        atxHeading: closer(),
        atxHeadingSequence: onexitatxheadingsequence,
        autolink: closer(),
        autolinkEmail: onexitautolinkemail,
        autolinkProtocol: onexitautolinkprotocol,
        blockQuote: closer(),
        characterEscapeValue: onexitdata,
        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
        characterReferenceValue: onexitcharacterreferencevalue,
        codeFenced: closer(onexitcodefenced),
        codeFencedFence: onexitcodefencedfence,
        codeFencedFenceInfo: onexitcodefencedfenceinfo,
        codeFencedFenceMeta: onexitcodefencedfencemeta,
        codeFlowValue: onexitdata,
        codeIndented: closer(onexitcodeindented),
        codeText: closer(onexitcodetext),
        codeTextData: onexitdata,
        data: onexitdata,
        definition: closer(),
        definitionDestinationString: onexitdefinitiondestinationstring,
        definitionLabelString: onexitdefinitionlabelstring,
        definitionTitleString: onexitdefinitiontitlestring,
        emphasis: closer(),
        hardBreakEscape: closer(onexithardbreak),
        hardBreakTrailing: closer(onexithardbreak),
        htmlFlow: closer(onexithtmlflow),
        htmlFlowData: onexitdata,
        htmlText: closer(onexithtmltext),
        htmlTextData: onexitdata,
        image: closer(onexitimage),
        label: onexitlabel,
        labelText: onexitlabeltext,
        lineEnding: onexitlineending,
        link: closer(onexitlink),
        listItem: closer(),
        listOrdered: closer(),
        listUnordered: closer(),
        paragraph: closer(),
        referenceString: onexitreferencestring,
        resourceDestinationString: onexitresourcedestinationstring,
        resourceTitleString: onexitresourcetitlestring,
        resource: onexitresource,
        setextHeading: closer(onexitsetextheading),
        setextHeadingLineSequence: onexitsetextheadinglinesequence,
        setextHeadingText: onexitsetextheadingtext,
        strong: closer(),
        thematicBreak: closer()
      }
    },
    options.mdastExtensions || []
  );
  /** @type {CompileData} */

  const data = {};
  return compile
  /**
   * @param {Array<Event>} events
   * @returns {Root}
   */

  function compile(events) {
    /** @type {Root} */
    let tree = {
      type: 'root',
      children: []
    };
    /** @type {CompileContext['stack']} */

    const stack = [tree];
    /** @type {CompileContext['tokenStack']} */

    const tokenStack = [];
    /** @type {Array<number>} */

    const listStack = [];
    /** @type {Omit<CompileContext, 'sliceSerialize'>} */

    const context = {
      stack,
      tokenStack,
      config,
      enter,
      exit,
      buffer,
      resume,
      setData,
      getData
    };
    let index = -1;

    while (++index < events.length) {
      // We preprocess lists to add `listItem` tokens, and to infer whether
      // items the list itself are spread out.
      if (
        events[index][1].type === 'listOrdered' ||
        events[index][1].type === 'listUnordered'
      ) {
        if (events[index][0] === 'enter') {
          listStack.push(index);
        } else {
          const tail = listStack.pop();
          index = prepareList(events, tail, index);
        }
      }
    }

    index = -1;

    while (++index < events.length) {
      const handler = config[events[index][0]];

      if (own$2.call(handler, events[index][1].type)) {
        handler[events[index][1].type].call(
          Object.assign(
            {
              sliceSerialize: events[index][2].sliceSerialize
            },
            context
          ),
          events[index][1]
        );
      }
    }

    if (tokenStack.length > 0) {
      const tail = tokenStack[tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, undefined, tail[0]);
    } // Figure out `root` position.

    tree.position = {
      start: point(
        events.length > 0
          ? events[0][1].start
          : {
              line: 1,
              column: 1,
              offset: 0
            }
      ),
      end: point(
        events.length > 0
          ? events[events.length - 2][1].end
          : {
              line: 1,
              column: 1,
              offset: 0
            }
      )
    };
    index = -1;

    while (++index < config.transforms.length) {
      tree = config.transforms[index](tree) || tree;
    }

    return tree
  }
  /**
   * @param {Array<Event>} events
   * @param {number} start
   * @param {number} length
   * @returns {number}
   */

  function prepareList(events, start, length) {
    let index = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    /** @type {Token|undefined} */

    let listItem;
    /** @type {number|undefined} */

    let lineIndex;
    /** @type {number|undefined} */

    let firstBlankLineIndex;
    /** @type {boolean|undefined} */

    let atMarker;

    while (++index <= length) {
      const event = events[index];

      if (
        event[1].type === 'listUnordered' ||
        event[1].type === 'listOrdered' ||
        event[1].type === 'blockQuote'
      ) {
        if (event[0] === 'enter') {
          containerBalance++;
        } else {
          containerBalance--;
        }

        atMarker = undefined;
      } else if (event[1].type === 'lineEndingBlank') {
        if (event[0] === 'enter') {
          if (
            listItem &&
            !atMarker &&
            !containerBalance &&
            !firstBlankLineIndex
          ) {
            firstBlankLineIndex = index;
          }

          atMarker = undefined;
        }
      } else if (
        event[1].type === 'linePrefix' ||
        event[1].type === 'listItemValue' ||
        event[1].type === 'listItemMarker' ||
        event[1].type === 'listItemPrefix' ||
        event[1].type === 'listItemPrefixWhitespace'
      ) ; else {
        atMarker = undefined;
      }

      if (
        (!containerBalance &&
          event[0] === 'enter' &&
          event[1].type === 'listItemPrefix') ||
        (containerBalance === -1 &&
          event[0] === 'exit' &&
          (event[1].type === 'listUnordered' ||
            event[1].type === 'listOrdered'))
      ) {
        if (listItem) {
          let tailIndex = index;
          lineIndex = undefined;

          while (tailIndex--) {
            const tailEvent = events[tailIndex];

            if (
              tailEvent[1].type === 'lineEnding' ||
              tailEvent[1].type === 'lineEndingBlank'
            ) {
              if (tailEvent[0] === 'exit') continue

              if (lineIndex) {
                events[lineIndex][1].type = 'lineEndingBlank';
                listSpread = true;
              }

              tailEvent[1].type = 'lineEnding';
              lineIndex = tailIndex;
            } else if (
              tailEvent[1].type === 'linePrefix' ||
              tailEvent[1].type === 'blockQuotePrefix' ||
              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||
              tailEvent[1].type === 'blockQuoteMarker' ||
              tailEvent[1].type === 'listItemIndent'
            ) ; else {
              break
            }
          }

          if (
            firstBlankLineIndex &&
            (!lineIndex || firstBlankLineIndex < lineIndex)
          ) {
            // @ts-expect-error Patched.
            listItem._spread = true;
          } // Fix position.

          listItem.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]]);
          index++;
          length++;
        } // Create a new list item.

        if (event[1].type === 'listItemPrefix') {
          listItem = {
            type: 'listItem',
            // @ts-expect-error Patched
            _spread: false,
            start: Object.assign({}, event[1].start)
          }; // @ts-expect-error: `listItem` is most definitely defined, TS...

          events.splice(index, 0, ['enter', listItem, event[2]]);
          index++;
          length++;
          firstBlankLineIndex = undefined;
          atMarker = true;
        }
      }
    } // @ts-expect-error Patched.

    events[start][1]._spread = listSpread;
    return length
  }
  /**
   * @type {CompileContext['setData']}
   * @param [value]
   */

  function setData(key, value) {
    data[key] = value;
  }
  /**
   * @type {CompileContext['getData']}
   * @template {string} K
   * @param {K} key
   * @returns {CompileData[K]}
   */

  function getData(key) {
    return data[key]
  }
  /**
   * @param {Point} d
   * @returns {Point}
   */

  function point(d) {
    return {
      line: d.line,
      column: d.column,
      offset: d.offset
    }
  }
  /**
   * @param {(token: Token) => Node} create
   * @param {Handle} [and]
   * @returns {Handle}
   */

  function opener(create, and) {
    return open
    /**
     * @this {CompileContext}
     * @param {Token} token
     * @returns {void}
     */

    function open(token) {
      enter.call(this, create(token), token);
      if (and) and.call(this, token);
    }
  }
  /** @type {CompileContext['buffer']} */

  function buffer() {
    this.stack.push({
      type: 'fragment',
      children: []
    });
  }
  /**
   * @type {CompileContext['enter']}
   * @template {Node} N
   * @this {CompileContext}
   * @param {N} node
   * @param {Token} token
   * @param {OnEnterError} [errorHandler]
   * @returns {N}
   */

  function enter(node, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    // @ts-expect-error: Assume `Node` can exist as a child of `parent`.
    parent.children.push(node);
    this.stack.push(node);
    this.tokenStack.push([token, errorHandler]); // @ts-expect-error: `end` will be patched later.

    node.position = {
      start: point(token.start)
    };
    return node
  }
  /**
   * @param {Handle} [and]
   * @returns {Handle}
   */

  function closer(and) {
    return close
    /**
     * @this {CompileContext}
     * @param {Token} token
     * @returns {void}
     */

    function close(token) {
      if (and) and.call(this, token);
      exit.call(this, token);
    }
  }
  /**
   * @type {CompileContext['exit']}
   * @this {CompileContext}
   * @param {Token} token
   * @param {OnExitError} [onExitError]
   * @returns {Node}
   */

  function exit(token, onExitError) {
    const node = this.stack.pop();
    const open = this.tokenStack.pop();

    if (!open) {
      throw new Error(
        'Cannot close `' +
          token.type +
          '` (' +
          stringifyPosition({
            start: token.start,
            end: token.end
          }) +
          '): it’s not open'
      )
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }

    node.position.end = point(token.end);
    return node
  }
  /**
   * @this {CompileContext}
   * @returns {string}
   */

  function resume() {
    return toString(this.stack.pop())
  } //
  // Handlers.
  //

  /** @type {Handle} */

  function onenterlistordered() {
    setData('expectingFirstListItemValue', true);
  }
  /** @type {Handle} */

  function onenterlistitemvalue(token) {
    if (getData('expectingFirstListItemValue')) {
      const ancestor =
        /** @type {List} */
        this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      setData('expectingFirstListItemValue');
    }
  }
  /** @type {Handle} */

  function onexitcodefencedfenceinfo() {
    const data = this.resume();
    const node =
      /** @type {Code} */
      this.stack[this.stack.length - 1];
    node.lang = data;
  }
  /** @type {Handle} */

  function onexitcodefencedfencemeta() {
    const data = this.resume();
    const node =
      /** @type {Code} */
      this.stack[this.stack.length - 1];
    node.meta = data;
  }
  /** @type {Handle} */

  function onexitcodefencedfence() {
    // Exit if this is the closing fence.
    if (getData('flowCodeInside')) return
    this.buffer();
    setData('flowCodeInside', true);
  }
  /** @type {Handle} */

  function onexitcodefenced() {
    const data = this.resume();
    const node =
      /** @type {Code} */
      this.stack[this.stack.length - 1];
    node.value = data.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, '');
    setData('flowCodeInside');
  }
  /** @type {Handle} */

  function onexitcodeindented() {
    const data = this.resume();
    const node =
      /** @type {Code} */
      this.stack[this.stack.length - 1];
    node.value = data.replace(/(\r?\n|\r)$/g, '');
  }
  /** @type {Handle} */

  function onexitdefinitionlabelstring(token) {
    // Discard label, use the source content instead.
    const label = this.resume();
    const node =
      /** @type {Definition} */
      this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  /** @type {Handle} */

  function onexitdefinitiontitlestring() {
    const data = this.resume();
    const node =
      /** @type {Definition} */
      this.stack[this.stack.length - 1];
    node.title = data;
  }
  /** @type {Handle} */

  function onexitdefinitiondestinationstring() {
    const data = this.resume();
    const node =
      /** @type {Definition} */
      this.stack[this.stack.length - 1];
    node.url = data;
  }
  /** @type {Handle} */

  function onexitatxheadingsequence(token) {
    const node =
      /** @type {Heading} */
      this.stack[this.stack.length - 1];

    if (!node.depth) {
      const depth = this.sliceSerialize(token).length;
      node.depth = depth;
    }
  }
  /** @type {Handle} */

  function onexitsetextheadingtext() {
    setData('setextHeadingSlurpLineEnding', true);
  }
  /** @type {Handle} */

  function onexitsetextheadinglinesequence(token) {
    const node =
      /** @type {Heading} */
      this.stack[this.stack.length - 1];
    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
  }
  /** @type {Handle} */

  function onexitsetextheading() {
    setData('setextHeadingSlurpLineEnding');
  }
  /** @type {Handle} */

  function onenterdata(token) {
    const parent =
      /** @type {Parent} */
      this.stack[this.stack.length - 1];
    /** @type {Node} */

    let tail = parent.children[parent.children.length - 1];

    if (!tail || tail.type !== 'text') {
      // Add a new text node.
      tail = text(); // @ts-expect-error: we’ll add `end` later.

      tail.position = {
        start: point(token.start)
      }; // @ts-expect-error: Assume `parent` accepts `text`.

      parent.children.push(tail);
    }

    this.stack.push(tail);
  }
  /** @type {Handle} */

  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point(token.end);
  }
  /** @type {Handle} */

  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];

    // If we’re at a hard break, include the line ending in there.
    if (getData('atHardBreak')) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point(token.end);
      setData('atHardBreak');
      return
    }

    if (
      !getData('setextHeadingSlurpLineEnding') &&
      config.canContainEols.includes(context.type)
    ) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  /** @type {Handle} */

  function onexithardbreak() {
    setData('atHardBreak', true);
  }
  /** @type {Handle} */

  function onexithtmlflow() {
    const data = this.resume();
    const node =
      /** @type {HTML} */
      this.stack[this.stack.length - 1];
    node.value = data;
  }
  /** @type {Handle} */

  function onexithtmltext() {
    const data = this.resume();
    const node =
      /** @type {HTML} */
      this.stack[this.stack.length - 1];
    node.value = data;
  }
  /** @type {Handle} */

  function onexitcodetext() {
    const data = this.resume();
    const node =
      /** @type {InlineCode} */
      this.stack[this.stack.length - 1];
    node.value = data;
  }
  /** @type {Handle} */

  function onexitlink() {
    const context =
      /** @type {Link & {identifier: string, label: string}} */
      this.stack[this.stack.length - 1]; // To do: clean.

    if (getData('inReference')) {
      context.type += 'Reference'; // @ts-expect-error: mutate.

      context.referenceType = getData('referenceType') || 'shortcut'; // @ts-expect-error: mutate.

      delete context.url;
      delete context.title;
    } else {
      // @ts-expect-error: mutate.
      delete context.identifier; // @ts-expect-error: mutate.

      delete context.label;
    }

    setData('referenceType');
  }
  /** @type {Handle} */

  function onexitimage() {
    const context =
      /** @type {Image & {identifier: string, label: string}} */
      this.stack[this.stack.length - 1]; // To do: clean.

    if (getData('inReference')) {
      context.type += 'Reference'; // @ts-expect-error: mutate.

      context.referenceType = getData('referenceType') || 'shortcut'; // @ts-expect-error: mutate.

      delete context.url;
      delete context.title;
    } else {
      // @ts-expect-error: mutate.
      delete context.identifier; // @ts-expect-error: mutate.

      delete context.label;
    }

    setData('referenceType');
  }
  /** @type {Handle} */

  function onexitlabeltext(token) {
    const ancestor =
      /** @type {(Link|Image) & {identifier: string, label: string}} */
      this.stack[this.stack.length - 2];
    const string = this.sliceSerialize(token);
    ancestor.label = decodeString(string);
    ancestor.identifier = normalizeIdentifier(string).toLowerCase();
  }
  /** @type {Handle} */

  function onexitlabel() {
    const fragment =
      /** @type {Fragment} */
      this.stack[this.stack.length - 1];
    const value = this.resume();
    const node =
      /** @type {(Link|Image) & {identifier: string, label: string}} */
      this.stack[this.stack.length - 1]; // Assume a reference.

    setData('inReference', true);

    if (node.type === 'link') {
      // @ts-expect-error: Assume static phrasing content.
      node.children = fragment.children;
    } else {
      node.alt = value;
    }
  }
  /** @type {Handle} */

  function onexitresourcedestinationstring() {
    const data = this.resume();
    const node =
      /** @type {Link|Image} */
      this.stack[this.stack.length - 1];
    node.url = data;
  }
  /** @type {Handle} */

  function onexitresourcetitlestring() {
    const data = this.resume();
    const node =
      /** @type {Link|Image} */
      this.stack[this.stack.length - 1];
    node.title = data;
  }
  /** @type {Handle} */

  function onexitresource() {
    setData('inReference');
  }
  /** @type {Handle} */

  function onenterreference() {
    setData('referenceType', 'collapsed');
  }
  /** @type {Handle} */

  function onexitreferencestring(token) {
    const label = this.resume();
    const node =
      /** @type {LinkReference|ImageReference} */
      this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    setData('referenceType', 'full');
  }
  /** @type {Handle} */

  function onexitcharacterreferencemarker(token) {
    setData('characterReferenceType', token.type);
  }
  /** @type {Handle} */

  function onexitcharacterreferencevalue(token) {
    const data = this.sliceSerialize(token);
    const type = getData('characterReferenceType');
    /** @type {string} */

    let value;

    if (type) {
      value = decodeNumericCharacterReference(
        data,
        type === 'characterReferenceMarkerNumeric' ? 10 : 16
      );
      setData('characterReferenceType');
    } else {
      // @ts-expect-error `decodeNamedCharacterReference` can return false for
      // invalid named character references, but everything we’ve tokenized is
      // valid.
      value = decodeNamedCharacterReference(data);
    }

    const tail = this.stack.pop();
    tail.value += value;
    tail.position.end = point(token.end);
  }
  /** @type {Handle} */

  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node =
      /** @type {Link} */
      this.stack[this.stack.length - 1];
    node.url = this.sliceSerialize(token);
  }
  /** @type {Handle} */

  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node =
      /** @type {Link} */
      this.stack[this.stack.length - 1];
    node.url = 'mailto:' + this.sliceSerialize(token);
  } //
  // Creaters.
  //

  /** @returns {Blockquote} */

  function blockQuote() {
    return {
      type: 'blockquote',
      children: []
    }
  }
  /** @returns {Code} */

  function codeFlow() {
    return {
      type: 'code',
      lang: null,
      meta: null,
      value: ''
    }
  }
  /** @returns {InlineCode} */

  function codeText() {
    return {
      type: 'inlineCode',
      value: ''
    }
  }
  /** @returns {Definition} */

  function definition() {
    return {
      type: 'definition',
      identifier: '',
      label: null,
      title: null,
      url: ''
    }
  }
  /** @returns {Emphasis} */

  function emphasis() {
    return {
      type: 'emphasis',
      children: []
    }
  }
  /** @returns {Heading} */

  function heading() {
    // @ts-expect-error `depth` will be set later.
    return {
      type: 'heading',
      depth: undefined,
      children: []
    }
  }
  /** @returns {Break} */

  function hardBreak() {
    return {
      type: 'break'
    }
  }
  /** @returns {HTML} */

  function html() {
    return {
      type: 'html',
      value: ''
    }
  }
  /** @returns {Image} */

  function image() {
    return {
      type: 'image',
      title: null,
      url: '',
      alt: null
    }
  }
  /** @returns {Link} */

  function link() {
    return {
      type: 'link',
      title: null,
      url: '',
      children: []
    }
  }
  /**
   * @param {Token} token
   * @returns {List}
   */

  function list(token) {
    return {
      type: 'list',
      ordered: token.type === 'listOrdered',
      start: null,
      // @ts-expect-error Patched.
      spread: token._spread,
      children: []
    }
  }
  /**
   * @param {Token} token
   * @returns {ListItem}
   */

  function listItem(token) {
    return {
      type: 'listItem',
      // @ts-expect-error Patched.
      spread: token._spread,
      checked: null,
      children: []
    }
  }
  /** @returns {Paragraph} */

  function paragraph() {
    return {
      type: 'paragraph',
      children: []
    }
  }
  /** @returns {Strong} */

  function strong() {
    return {
      type: 'strong',
      children: []
    }
  }
  /** @returns {Text} */

  function text() {
    return {
      type: 'text',
      value: ''
    }
  }
  /** @returns {ThematicBreak} */

  function thematicBreak() {
    return {
      type: 'thematicBreak'
    }
  }
}
/**
 * @param {Extension} combined
 * @param {Array<Extension|Array<Extension>>} extensions
 * @returns {Extension}
 */

function configure(combined, extensions) {
  let index = -1;

  while (++index < extensions.length) {
    const value = extensions[index];

    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }

  return combined
}
/**
 * @param {Extension} combined
 * @param {Extension} extension
 * @returns {void}
 */

function extension(combined, extension) {
  /** @type {string} */
  let key;

  for (key in extension) {
    if (own$2.call(extension, key)) {
      const list = key === 'canContainEols' || key === 'transforms';
      const maybe = own$2.call(combined, key) ? combined[key] : undefined;
      /* c8 ignore next */

      const left = maybe || (combined[key] = list ? [] : {});
      const right = extension[key];

      if (right) {
        if (list) {
          // @ts-expect-error: `left` is an array.
          combined[key] = [...left, ...right];
        } else {
          Object.assign(left, right);
        }
      }
    }
  }
}
/** @type {OnEnterError} */

function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      'Cannot close `' +
        left.type +
        '` (' +
        stringifyPosition({
          start: left.start,
          end: left.end
        }) +
        '): a different token (`' +
        right.type +
        '`, ' +
        stringifyPosition({
          start: right.start,
          end: right.end
        }) +
        ') is open'
    )
  } else {
    throw new Error(
      'Cannot close document, a token (`' +
        right.type +
        '`, ' +
        stringifyPosition({
          start: right.start,
          end: right.end
        }) +
        ') is still open'
    )
  }
}

/**
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast-util-from-markdown').Options} Options
 */

/** @type {import('unified').Plugin<[Options?] | void[], string, Root>} */
function remarkParse(options) {
  /** @type {import('unified').ParserFunction<Root>} */
  const parser = (doc) => {
    // Assume options.
    const settings = /** @type {Options} */ (this.data('settings'));

    return fromMarkdown(
      doc,
      Object.assign({}, settings, options, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: this.data('micromarkExtensions') || [],
        mdastExtensions: this.data('fromMarkdownExtensions') || []
      })
    )
  };

  Object.assign(this, {Parser: parser});
}

var format = {exports: {}};

(function (module) {
(function() {

  //// Export the API
  var namespace;

  // CommonJS / Node module
  {
    namespace = module.exports = format;
  }

  namespace.format = format;
  namespace.vsprintf = vsprintf;

  if (typeof console !== 'undefined' && typeof console.log === 'function') {
    namespace.printf = printf;
  }

  function printf(/* ... */) {
    console.log(format.apply(null, arguments));
  }

  function vsprintf(fmt, replacements) {
    return format.apply(null, [fmt].concat(replacements));
  }

  function format(fmt) {
    var argIndex = 1 // skip initial format argument
      , args = [].slice.call(arguments)
      , i = 0
      , n = fmt.length
      , result = ''
      , c
      , escaped = false
      , arg
      , tmp
      , leadingZero = false
      , precision
      , nextArg = function() { return args[argIndex++]; }
      , slurpNumber = function() {
          var digits = '';
          while (/\d/.test(fmt[i])) {
            digits += fmt[i++];
            c = fmt[i];
          }
          return digits.length > 0 ? parseInt(digits) : null;
        }
      ;
    for (; i < n; ++i) {
      c = fmt[i];
      if (escaped) {
        escaped = false;
        if (c == '.') {
          leadingZero = false;
          c = fmt[++i];
        }
        else if (c == '0' && fmt[i + 1] == '.') {
          leadingZero = true;
          i += 2;
          c = fmt[i];
        }
        else {
          leadingZero = true;
        }
        precision = slurpNumber();
        switch (c) {
        case 'b': // number in binary
          result += parseInt(nextArg(), 10).toString(2);
          break;
        case 'c': // character
          arg = nextArg();
          if (typeof arg === 'string' || arg instanceof String)
            result += arg;
          else
            result += String.fromCharCode(parseInt(arg, 10));
          break;
        case 'd': // number in decimal
          result += parseInt(nextArg(), 10);
          break;
        case 'f': // floating point number
          tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
          result += leadingZero ? tmp : tmp.replace(/^0/, '');
          break;
        case 'j': // JSON
          result += JSON.stringify(nextArg());
          break;
        case 'o': // number in octal
          result += '0' + parseInt(nextArg(), 10).toString(8);
          break;
        case 's': // string
          result += nextArg();
          break;
        case 'x': // lowercase hexadecimal
          result += '0x' + parseInt(nextArg(), 10).toString(16);
          break;
        case 'X': // uppercase hexadecimal
          result += '0x' + parseInt(nextArg(), 10).toString(16).toUpperCase();
          break;
        default:
          result += c;
          break;
        }
      } else if (c === '%') {
        escaped = true;
      } else {
        result += c;
      }
    }
    return result;
  }

}());
}(format));

var formatter = format.exports;

// @ts-expect-error

const fault = Object.assign(create(Error), {
  eval: create(EvalError),
  range: create(RangeError),
  reference: create(ReferenceError),
  syntax: create(SyntaxError),
  type: create(TypeError),
  uri: create(URIError)
});

/**
 * Create a new `EConstructor`, with the formatted `format` as a first argument.
 *
 * @template {Error} Fault
 * @template {new (reason: string) => Fault} Class
 * @param {Class} Constructor
 */
function create(Constructor) {
  /** @type {string} */
  // @ts-expect-error
  FormattedError.displayName = Constructor.displayName || Constructor.name;

  return FormattedError

  /**
   * Create an error with a printf-like formatted message.
   *
   * @param {string|null} [format]
   *   Template string.
   * @param {...unknown} values
   *   Values to render in `format`.
   * @returns {Fault}
   */
  function FormattedError(format, ...values) {
    /** @type {string} */
    const reason = format ? formatter(format, ...values) : format;
    return new Constructor(reason)
  }
}

/**
 * @typedef {'yaml'|'toml'} Preset
 *   Either `'yaml'` or `'toml'`
 *
 * @typedef Info
 * @property {string} open
 * @property {string} close
 *
 * @typedef MatterProps
 * @property {string} type
 *   Type to tokenize as
 * @property {boolean} [anywhere=false]
 *   If `true`, matter can be found anywhere in the document.
 *   If `false` (default), only matter at the start of the document is
 *   recognized.
 *
 * @typedef MarkerProps
 * @property {string|Info} marker
 *   Character used to construct fences.
 *   By providing an object with `open` and `close` different characters can be
 *   used for opening and closing fences.
 *   For example the character `'-'` will result in `'---'` being used as the
 *   fence
 * @property {never} [fence]
 *
 * @typedef FenceProps
 * @property {string|Info} fence
 *   String used as the complete fence.
 *   By providing an object with `open` and `close` different values can be used
 *   for opening and closing fences.
 *   This can be used too if fences contain different characters or lengths
 *   other than 3.
 * @property {never} [marker]
 *
 * @typedef {(MatterProps & FenceProps)|(MatterProps & MarkerProps)} Matter
 *
 * @typedef {Preset|Matter|Array.<Preset|Matter>} Options
 */
const own$1 = {}.hasOwnProperty;
const markers = {
  yaml: '-',
  toml: '+'
};
/**
 * @param {Options} [options='yaml']
 * @returns {Array<Matter>}
 */

function matters(options = 'yaml') {
  /** @type {Array<Matter>} */
  const results = [];
  let index = -1; // One preset or matter.

  if (!Array.isArray(options)) {
    options = [options];
  }

  while (++index < options.length) {
    results[index] = matter(options[index]);
  }

  return results
}
/**
 * @param {Preset|Matter} option
 * @returns {Matter}
 */

function matter(option) {
  let result = option;

  if (typeof result === 'string') {
    if (!own$1.call(markers, result)) {
      throw fault('Missing matter definition for `%s`', result)
    }

    result = {
      type: result,
      marker: markers[result]
    };
  } else if (typeof result !== 'object') {
    throw fault('Expected matter to be an object, not `%j`', result)
  }

  if (!own$1.call(result, 'type')) {
    throw fault('Missing `type` in matter `%j`', result)
  }

  if (!own$1.call(result, 'fence') && !own$1.call(result, 'marker')) {
    throw fault('Missing `marker` or `fence` in matter `%j`', result)
  }

  return result
}

/**
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('../matters.js').Options} Options
 * @typedef {import('../matters.js').Matter} Matter
 * @typedef {import('../matters.js').Info} Info
 */
/**
 * Create an extension to support frontmatter (YAML, TOML, and more).
 *
 * @param {Options} [options='yaml'] One preset or matter, or an array of them.
 * @returns {Extension}
 */

function frontmatter(options) {
  const settings = matters(options);
  /** @type {ConstructRecord} */

  const flow = {};
  let index = -1;
  /** @type {Matter} */

  let matter;
  /** @type {number} */

  let code;

  while (++index < settings.length) {
    matter = settings[index];
    code = fence$1(matter, 'open').charCodeAt(0);

    if (code in flow) {
      // @ts-expect-error it clearly does exist.
      flow[code].push(parse(matter));
    } else {
      flow[code] = [parse(matter)];
    }
  }

  return {
    flow
  }
}
/**
 * @param {Matter} matter
 * @returns {Construct}
 */

function parse(matter) {
  const name = matter.type;
  const anywhere = matter.anywhere;
  const valueType = name + 'Value';
  const fenceType = name + 'Fence';
  const sequenceType = fenceType + 'Sequence';
  const fenceConstruct = {
    tokenize: tokenizeFence,
    partial: true
  };
  /** @type {string} */

  let buffer;
  return {
    tokenize: tokenizeFrontmatter,
    concrete: true
  }
  /** @type {Tokenizer} */

  function tokenizeFrontmatter(effects, ok, nok) {
    const self = this;
    return start
    /** @type {State} */

    function start(code) {
      const position = self.now();

      if (position.column !== 1 || (!anywhere && position.line !== 1)) {
        return nok(code)
      }

      effects.enter(name);
      buffer = fence$1(matter, 'open');
      return effects.attempt(fenceConstruct, afterOpeningFence, nok)(code)
    }
    /** @type {State} */

    function afterOpeningFence(code) {
      buffer = fence$1(matter, 'close');
      return lineEnd(code)
    }
    /** @type {State} */

    function lineStart(code) {
      if (code === null || markdownLineEnding(code)) {
        return lineEnd(code)
      }

      effects.enter(valueType);
      return lineData(code)
    }
    /** @type {State} */

    function lineData(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit(valueType);
        return lineEnd(code)
      }

      effects.consume(code);
      return lineData
    }
    /** @type {State} */

    function lineEnd(code) {
      // Require a closing fence.
      if (code === null) {
        return nok(code)
      } // Can only be an eol.

      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      return effects.attempt(fenceConstruct, after, lineStart)
    }
    /** @type {State} */

    function after(code) {
      effects.exit(name);
      return ok(code)
    }
  }
  /** @type {Tokenizer} */

  function tokenizeFence(effects, ok, nok) {
    let bufferIndex = 0;
    return start
    /** @type {State} */

    function start(code) {
      if (code === buffer.charCodeAt(bufferIndex)) {
        effects.enter(fenceType);
        effects.enter(sequenceType);
        return insideSequence(code)
      }

      return nok(code)
    }
    /** @type {State} */

    function insideSequence(code) {
      if (bufferIndex === buffer.length) {
        effects.exit(sequenceType);

        if (markdownSpace(code)) {
          effects.enter('whitespace');
          return insideWhitespace(code)
        }

        return fenceEnd(code)
      }

      if (code === buffer.charCodeAt(bufferIndex++)) {
        effects.consume(code);
        return insideSequence
      }

      return nok(code)
    }
    /** @type {State} */

    function insideWhitespace(code) {
      if (markdownSpace(code)) {
        effects.consume(code);
        return insideWhitespace
      }

      effects.exit('whitespace');
      return fenceEnd(code)
    }
    /** @type {State} */

    function fenceEnd(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit(fenceType);
        return ok(code)
      }

      return nok(code)
    }
  }
}
/**
 * @param {Matter} matter
 * @param {'open'|'close'} prop
 * @returns {string}
 */

function fence$1(matter, prop) {
  return matter.marker
    ? pick$1(matter.marker, prop).repeat(3) // @ts-expect-error: They’re mutually exclusive.
    : pick$1(matter.fence, prop)
}
/**
 * @param {Info|string} schema
 * @param {'open'|'close'} prop
 * @returns {string}
 */

function pick$1(schema, prop) {
  return typeof schema === 'string' ? schema : schema[prop]
}

/**
 * @typedef {import('mdast').Literal} Literal
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 * @typedef {import('mdast-util-to-markdown/lib/types.js').Options} ToMarkdownExtension
 * @typedef {import('mdast-util-to-markdown/lib/types.js').Handle} ToMarkdownHandle
 * @typedef {import('mdast-util-to-markdown/lib/util/indent-lines.js').Map} Map
 *
 * @typedef {import('micromark-extension-frontmatter/matters.js').Options} Options
 * @typedef {import('micromark-extension-frontmatter/matters.js').Matter} Matter
 * @typedef {import('micromark-extension-frontmatter/matters.js').Info} Info
 */

/**
 * @param {Options} [options]
 * @returns {FromMarkdownExtension}
 */
function frontmatterFromMarkdown(options) {
  const settings = matters(options);
  /** @type {FromMarkdownExtension['enter']} */
  const enter = {};
  /** @type {FromMarkdownExtension['exit']} */
  const exit = {};
  let index = -1;

  while (++index < settings.length) {
    const matter = settings[index];
    enter[matter.type] = opener(matter);
    exit[matter.type] = close;
    exit[matter.type + 'Value'] = value;
  }

  return {enter, exit}
}

/**
 * @param {Matter} matter
 * @returns {FromMarkdownHandle} enter
 */
function opener(matter) {
  return open
  /** @type {FromMarkdownHandle} */
  function open(token) {
    // @ts-expect-error: custom.
    this.enter({type: matter.type, value: ''}, token);
    this.buffer();
  }
}

/** @type {FromMarkdownHandle} */
function close(token) {
  const data = this.resume();
  // Remove the initial and final eol.
  this.exit(token).value = data.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, '');
}

/** @type {FromMarkdownHandle} */
function value(token) {
  this.config.enter.data.call(this, token);
  this.config.exit.data.call(this, token);
}

/**
 * @param {Options} [options]
 * @returns {ToMarkdownExtension}
 */
function frontmatterToMarkdown(options) {
  /** @type {ToMarkdownExtension['unsafe']} */
  const unsafe = [];
  /** @type {ToMarkdownExtension['handlers']} */
  const handlers = {};
  const settings = matters(options);
  let index = -1;

  while (++index < settings.length) {
    const matter = settings[index];
    handlers[matter.type] = handler(matter);
    unsafe.push({atBreak: true, character: fence(matter, 'open').charAt(0)});
  }

  return {unsafe, handlers}
}

/**
 * @param {Matter} matter
 * @returns {(node: Literal) => string} enter
 */
function handler(matter) {
  const open = fence(matter, 'open');
  const close = fence(matter, 'close');

  return handle

  /**
   * @type {ToMarkdownHandle}
   * @param {Literal} node
   */
  function handle(node) {
    return open + (node.value ? '\n' + node.value : '') + '\n' + close
  }
}

/**
 * @param {Matter} matter
 * @param {'open'|'close'} prop
 * @returns {string}
 */
function fence(matter, prop) {
  return matter.marker
    ? pick(matter.marker, prop).repeat(3)
    : // @ts-expect-error: They’re mutually exclusive.
      pick(matter.fence, prop)
}

/**
 * @param {Info|string} schema
 * @param {'open'|'close'} prop
 * @returns {string}
 */
function pick(schema, prop) {
  return typeof schema === 'string' ? schema : schema[prop]
}

/**
 * @typedef {import('mdast').Root} Root
 * @typedef {import('micromark-extension-frontmatter').Options} Options
 */

/**
 * Plugin to add support for frontmatter.
 *
 * @type {import('unified').Plugin<[Options?]|void[], Root>}
 */
function remarkFrontmatter(options = 'yaml') {
  const data = this.data();

  add('micromarkExtensions', frontmatter(options));
  add('fromMarkdownExtensions', frontmatterFromMarkdown(options));
  add('toMarkdownExtensions', frontmatterToMarkdown(options));

  /**
   * @param {string} field
   * @param {unknown} value
   */
  function add(field, value) {
    const list = /** @type {unknown[]} */ (
      // Other extensions
      /* c8 ignore next 2 */
      data[field] ? data[field] : (data[field] = [])
    );

    list.push(value);
  }
}

/**
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').Previous} Previous
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Code} Code
 */
const www = {
  tokenize: tokenizeWww,
  partial: true
};
const domain = {
  tokenize: tokenizeDomain,
  partial: true
};
const path = {
  tokenize: tokenizePath,
  partial: true
};
const punctuation = {
  tokenize: tokenizePunctuation,
  partial: true
};
const namedCharacterReference = {
  tokenize: tokenizeNamedCharacterReference,
  partial: true
};
const wwwAutolink = {
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
const httpAutolink = {
  tokenize: tokenizeHttpAutolink,
  previous: previousHttp
};
const emailAutolink = {
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
/** @type {ConstructRecord} */

const text = {};
/** @type {Extension} */

const gfmAutolinkLiteral = {
  text
};
let code = 48; // Add alphanumerics.

while (code < 123) {
  text[code] = emailAutolink;
  code++;
  if (code === 58) code = 65;
  else if (code === 91) code = 97;
}

text[43] = emailAutolink;
text[45] = emailAutolink;
text[46] = emailAutolink;
text[95] = emailAutolink;
text[72] = [emailAutolink, httpAutolink];
text[104] = [emailAutolink, httpAutolink];
text[87] = [emailAutolink, wwwAutolink];
text[119] = [emailAutolink, wwwAutolink];
/** @type {Tokenizer} */

function tokenizeEmailAutolink(effects, ok, nok) {
  const self = this;
  /** @type {boolean} */

  let hasDot;
  /** @type {boolean|undefined} */

  let hasDigitInLastSegment;
  return start
  /** @type {State} */

  function start(code) {
    if (
      !gfmAtext(code) ||
      !previousEmail(self.previous) ||
      previousUnbalanced(self.events)
    ) {
      return nok(code)
    }

    effects.enter('literalAutolink');
    effects.enter('literalAutolinkEmail');
    return atext(code)
  }
  /** @type {State} */

  function atext(code) {
    if (gfmAtext(code)) {
      effects.consume(code);
      return atext
    }

    if (code === 64) {
      effects.consume(code);
      return label
    }

    return nok(code)
  }
  /** @type {State} */

  function label(code) {
    if (code === 46) {
      return effects.check(punctuation, done, dotContinuation)(code)
    }

    if (code === 45 || code === 95) {
      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code)
    }

    if (asciiAlphanumeric(code)) {
      if (!hasDigitInLastSegment && asciiDigit(code)) {
        hasDigitInLastSegment = true;
      }

      effects.consume(code);
      return label
    }

    return done(code)
  }
  /** @type {State} */

  function dotContinuation(code) {
    effects.consume(code);
    hasDot = true;
    hasDigitInLastSegment = undefined;
    return label
  }
  /** @type {State} */

  function dashOrUnderscoreContinuation(code) {
    effects.consume(code);
    return afterDashOrUnderscore
  }
  /** @type {State} */

  function afterDashOrUnderscore(code) {
    if (code === 46) {
      return effects.check(punctuation, nok, dotContinuation)(code)
    }

    return label(code)
  }
  /** @type {State} */

  function done(code) {
    if (hasDot && !hasDigitInLastSegment) {
      effects.exit('literalAutolinkEmail');
      effects.exit('literalAutolink');
      return ok(code)
    }

    return nok(code)
  }
}
/** @type {Tokenizer} */

function tokenizeWwwAutolink(effects, ok, nok) {
  const self = this;
  return start
  /** @type {State} */

  function start(code) {
    if (
      (code !== 87 && code !== 119) ||
      !previousWww(self.previous) ||
      previousUnbalanced(self.events)
    ) {
      return nok(code)
    }

    effects.enter('literalAutolink');
    effects.enter('literalAutolinkWww'); // For `www.` we check instead of attempt, because when it matches, GH
    // treats it as part of a domain (yes, it says a valid domain must come
    // after `www.`, but that’s not how it’s implemented by them).

    return effects.check(
      www,
      effects.attempt(domain, effects.attempt(path, done), nok),
      nok
    )(code)
  }
  /** @type {State} */

  function done(code) {
    effects.exit('literalAutolinkWww');
    effects.exit('literalAutolink');
    return ok(code)
  }
}
/** @type {Tokenizer} */

function tokenizeHttpAutolink(effects, ok, nok) {
  const self = this;
  return start
  /** @type {State} */

  function start(code) {
    if (
      (code !== 72 && code !== 104) ||
      !previousHttp(self.previous) ||
      previousUnbalanced(self.events)
    ) {
      return nok(code)
    }

    effects.enter('literalAutolink');
    effects.enter('literalAutolinkHttp');
    effects.consume(code);
    return t1
  }
  /** @type {State} */

  function t1(code) {
    if (code === 84 || code === 116) {
      effects.consume(code);
      return t2
    }

    return nok(code)
  }
  /** @type {State} */

  function t2(code) {
    if (code === 84 || code === 116) {
      effects.consume(code);
      return p
    }

    return nok(code)
  }
  /** @type {State} */

  function p(code) {
    if (code === 80 || code === 112) {
      effects.consume(code);
      return s
    }

    return nok(code)
  }
  /** @type {State} */

  function s(code) {
    if (code === 83 || code === 115) {
      effects.consume(code);
      return colon
    }

    return colon(code)
  }
  /** @type {State} */

  function colon(code) {
    if (code === 58) {
      effects.consume(code);
      return slash1
    }

    return nok(code)
  }
  /** @type {State} */

  function slash1(code) {
    if (code === 47) {
      effects.consume(code);
      return slash2
    }

    return nok(code)
  }
  /** @type {State} */

  function slash2(code) {
    if (code === 47) {
      effects.consume(code);
      return after
    }

    return nok(code)
  }
  /** @type {State} */

  function after(code) {
    return code === null ||
      asciiControl(code) ||
      unicodeWhitespace(code) ||
      unicodePunctuation(code)
      ? nok(code)
      : effects.attempt(domain, effects.attempt(path, done), nok)(code)
  }
  /** @type {State} */

  function done(code) {
    effects.exit('literalAutolinkHttp');
    effects.exit('literalAutolink');
    return ok(code)
  }
}
/** @type {Tokenizer} */

function tokenizeWww(effects, ok, nok) {
  return start
  /** @type {State} */

  function start(code) {
    effects.consume(code);
    return w2
  }
  /** @type {State} */

  function w2(code) {
    if (code === 87 || code === 119) {
      effects.consume(code);
      return w3
    }

    return nok(code)
  }
  /** @type {State} */

  function w3(code) {
    if (code === 87 || code === 119) {
      effects.consume(code);
      return dot
    }

    return nok(code)
  }
  /** @type {State} */

  function dot(code) {
    if (code === 46) {
      effects.consume(code);
      return after
    }

    return nok(code)
  }
  /** @type {State} */

  function after(code) {
    return code === null || markdownLineEnding(code) ? nok(code) : ok(code)
  }
}
/** @type {Tokenizer} */

function tokenizeDomain(effects, ok, nok) {
  /** @type {boolean|undefined} */
  let hasUnderscoreInLastSegment;
  /** @type {boolean|undefined} */

  let hasUnderscoreInLastLastSegment;
  return domain
  /** @type {State} */

  function domain(code) {
    if (code === 38) {
      return effects.check(
        namedCharacterReference,
        done,
        punctuationContinuation
      )(code)
    }

    if (code === 46 || code === 95) {
      return effects.check(punctuation, done, punctuationContinuation)(code)
    } // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can
    // occur, which sounds like ASCII only, but they also support `www.點看.com`,
    // so that’s Unicode.
    // Instead of some new production for Unicode alphanumerics, markdown
    // already has that for Unicode punctuation and whitespace, so use those.

    if (
      code === null ||
      asciiControl(code) ||
      unicodeWhitespace(code) ||
      (code !== 45 && unicodePunctuation(code))
    ) {
      return done(code)
    }

    effects.consume(code);
    return domain
  }
  /** @type {State} */

  function punctuationContinuation(code) {
    if (code === 46) {
      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;
      hasUnderscoreInLastSegment = undefined;
      effects.consume(code);
      return domain
    }

    if (code === 95) hasUnderscoreInLastSegment = true;
    effects.consume(code);
    return domain
  }
  /** @type {State} */

  function done(code) {
    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {
      return ok(code)
    }

    return nok(code)
  }
}
/** @type {Tokenizer} */

function tokenizePath(effects, ok) {
  let balance = 0;
  return inPath
  /** @type {State} */

  function inPath(code) {
    if (code === 38) {
      return effects.check(
        namedCharacterReference,
        ok,
        continuedPunctuation
      )(code)
    }

    if (code === 40) {
      balance++;
    }

    if (code === 41) {
      return effects.check(
        punctuation,
        parenAtPathEnd,
        continuedPunctuation
      )(code)
    }

    if (pathEnd(code)) {
      return ok(code)
    }

    if (trailingPunctuation(code)) {
      return effects.check(punctuation, ok, continuedPunctuation)(code)
    }

    effects.consume(code);
    return inPath
  }
  /** @type {State} */

  function continuedPunctuation(code) {
    effects.consume(code);
    return inPath
  }
  /** @type {State} */

  function parenAtPathEnd(code) {
    balance--;
    return balance < 0 ? ok(code) : continuedPunctuation(code)
  }
}
/** @type {Tokenizer} */

function tokenizeNamedCharacterReference(effects, ok, nok) {
  return start
  /** @type {State} */

  function start(code) {
    effects.consume(code);
    return inside
  }
  /** @type {State} */

  function inside(code) {
    if (asciiAlpha(code)) {
      effects.consume(code);
      return inside
    }

    if (code === 59) {
      effects.consume(code);
      return after
    }

    return nok(code)
  }
  /** @type {State} */

  function after(code) {
    // If the named character reference is followed by the end of the path, it’s
    // not continued punctuation.
    return pathEnd(code) ? ok(code) : nok(code)
  }
}
/** @type {Tokenizer} */

function tokenizePunctuation(effects, ok, nok) {
  return start
  /** @type {State} */

  function start(code) {
    effects.consume(code);
    return after
  }
  /** @type {State} */

  function after(code) {
    // Check the next.
    if (trailingPunctuation(code)) {
      effects.consume(code);
      return after
    } // If the punctuation marker is followed by the end of the path, it’s not
    // continued punctuation.

    return pathEnd(code) ? ok(code) : nok(code)
  }
}
/**
 * @param {Code} code
 * @returns {boolean}
 */

function trailingPunctuation(code) {
  return (
    code === 33 ||
    code === 34 ||
    code === 39 ||
    code === 41 ||
    code === 42 ||
    code === 44 ||
    code === 46 ||
    code === 58 ||
    code === 59 ||
    code === 60 ||
    code === 63 ||
    code === 95 ||
    code === 126
  )
}
/**
 * @param {Code} code
 * @returns {boolean}
 */

function pathEnd(code) {
  return code === null || code === 60 || markdownLineEndingOrSpace(code)
}
/**
 * @param {Code} code
 * @returns {boolean}
 */

function gfmAtext(code) {
  return (
    code === 43 ||
    code === 45 ||
    code === 46 ||
    code === 95 ||
    asciiAlphanumeric(code)
  )
}
/** @type {Previous} */

function previousWww(code) {
  return (
    code === null ||
    code === 40 ||
    code === 42 ||
    code === 95 ||
    code === 126 ||
    markdownLineEndingOrSpace(code)
  )
}
/** @type {Previous} */

function previousHttp(code) {
  return code === null || !asciiAlpha(code)
}
/** @type {Previous} */

function previousEmail(code) {
  return code !== 47 && previousHttp(code)
}
/**
 * @param {Array<Event>} events
 * @returns {boolean}
 */

function previousUnbalanced(events) {
  let index = events.length;
  let result = false;

  while (index--) {
    const token = events[index][1];

    if (
      (token.type === 'labelLink' || token.type === 'labelImage') &&
      !token._balanced
    ) {
      result = true;
      break
    } // @ts-expect-error If we’ve seen this token, and it was marked as not
    // having any unbalanced bracket before it, we can exit.

    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break
    }
  }

  if (events.length > 0 && !result) {
    // @ts-expect-error Mark the last token as “walked into” w/o finding
    // anything.
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }

  return result
}

/**
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').Exiter} Exiter
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Event} Event
 */
const indent = {
  tokenize: tokenizeIndent,
  partial: true
};
/**
 * @returns {Extension}
 */

function gfmFootnote() {
  /** @type {Extension} */
  return {
    document: {
      [91]: {
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [91]: {
        tokenize: tokenizeGfmFootnoteCall
      },
      [93]: {
        add: 'after',
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  }
}
/** @type {Tokenizer} */

function tokenizePotentialGfmFootnoteCall(effects, ok, nok) {
  const self = this;
  let index = self.events.length;
  /** @type {Array<string>} */
  // @ts-expect-error It’s fine!

  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  /** @type {Token} */

  let labelStart; // Find an opening.

  while (index--) {
    const token = self.events[index][1];

    if (token.type === 'labelImage') {
      labelStart = token;
      break
    } // Exit if we’ve walked far enough.

    if (
      token.type === 'gfmFootnoteCall' ||
      token.type === 'labelLink' ||
      token.type === 'label' ||
      token.type === 'image' ||
      token.type === 'link'
    ) {
      break
    }
  }

  return start
  /** @type {State} */

  function start(code) {
    if (!labelStart || !labelStart._balanced) {
      return nok(code)
    }

    const id = normalizeIdentifier(
      self.sliceSerialize({
        start: labelStart.end,
        end: self.now()
      })
    );

    if (id.charCodeAt(0) !== 94 || !defined.includes(id.slice(1))) {
      return nok(code)
    }

    effects.enter('gfmFootnoteCallLabelMarker');
    effects.consume(code);
    effects.exit('gfmFootnoteCallLabelMarker');
    return ok(code)
  }
}
/** @type {Resolver} */

function resolveToPotentialGfmFootnoteCall(events, context) {
  let index = events.length;

  while (index--) {
    if (
      events[index][1].type === 'labelImage' &&
      events[index][0] === 'enter'
    ) {
      events[index][1];
      break
    }
  }

  // Change the `labelImageMarker` to a `data`.
  events[index + 1][1].type = 'data';
  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'; // The whole (without `!`):

  const call = {
    type: 'gfmFootnoteCall',
    start: Object.assign({}, events[index + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  }; // The `^` marker

  const marker = {
    type: 'gfmFootnoteCallMarker',
    start: Object.assign({}, events[index + 3][1].end),
    end: Object.assign({}, events[index + 3][1].end)
  }; // Increment the end 1 character.

  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string = {
    type: 'gfmFootnoteCallString',
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: 'chunkString',
    contentType: 'string',
    start: Object.assign({}, string.start),
    end: Object.assign({}, string.end)
  };
  /** @type {Array<Event>} */

  const replacement = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    events[index + 1],
    events[index + 2],
    ['enter', call, context], // The `[`
    events[index + 3],
    events[index + 4], // The `^`.
    ['enter', marker, context],
    ['exit', marker, context], // Everything in between.
    ['enter', string, context],
    ['enter', chunk, context],
    ['exit', chunk, context],
    ['exit', string, context], // The ending (`]`, properly parsed and labelled).
    events[events.length - 2],
    events[events.length - 1],
    ['exit', call, context]
  ];
  events.splice(index, events.length - index + 1, ...replacement);
  return events
}
/** @type {Tokenizer} */

function tokenizeGfmFootnoteCall(effects, ok, nok) {
  const self = this;
  /** @type {Array<string>} */
  // @ts-expect-error It’s fine!

  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let size = 0;
  /** @type {boolean} */

  let data;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('gfmFootnoteCall');
    effects.enter('gfmFootnoteCallLabelMarker');
    effects.consume(code);
    effects.exit('gfmFootnoteCallLabelMarker');
    return callStart
  }
  /** @type {State} */

  function callStart(code) {
    if (code !== 94) return nok(code)
    effects.enter('gfmFootnoteCallMarker');
    effects.consume(code);
    effects.exit('gfmFootnoteCallMarker');
    effects.enter('gfmFootnoteCallString');
    effects.enter('chunkString').contentType = 'string';
    return callData
  }
  /** @type {State} */

  function callData(code) {
    /** @type {Token} */
    let token;

    if (code === null || code === 91 || size++ > 999) {
      return nok(code)
    }

    if (code === 93) {
      if (!data) {
        return nok(code)
      }

      effects.exit('chunkString');
      token = effects.exit('gfmFootnoteCallString');
      return defined.includes(normalizeIdentifier(self.sliceSerialize(token)))
        ? end(code)
        : nok(code)
    }

    effects.consume(code);

    if (!markdownLineEndingOrSpace(code)) {
      data = true;
    }

    return code === 92 ? callEscape : callData
  }
  /** @type {State} */

  function callEscape(code) {
    if (code === 91 || code === 92 || code === 93) {
      effects.consume(code);
      size++;
      return callData
    }

    return callData(code)
  }
  /** @type {State} */

  function end(code) {
    effects.enter('gfmFootnoteCallLabelMarker');
    effects.consume(code);
    effects.exit('gfmFootnoteCallLabelMarker');
    effects.exit('gfmFootnoteCall');
    return ok
  }
}
/** @type {Tokenizer} */

function tokenizeDefinitionStart(effects, ok, nok) {
  const self = this;
  /** @type {Array<string>} */
  // @ts-expect-error It’s fine!

  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  /** @type {string} */

  let identifier;
  let size = 0;
  /** @type {boolean|undefined} */

  let data;
  return start
  /** @type {State} */

  function start(code) {
    effects.enter('gfmFootnoteDefinition')._container = true;
    effects.enter('gfmFootnoteDefinitionLabel');
    effects.enter('gfmFootnoteDefinitionLabelMarker');
    effects.consume(code);
    effects.exit('gfmFootnoteDefinitionLabelMarker');
    return labelStart
  }
  /** @type {State} */

  function labelStart(code) {
    if (code === 94) {
      effects.enter('gfmFootnoteDefinitionMarker');
      effects.consume(code);
      effects.exit('gfmFootnoteDefinitionMarker');
      effects.enter('gfmFootnoteDefinitionLabelString');
      return atBreak
    }

    return nok(code)
  }
  /** @type {State} */

  function atBreak(code) {
    /** @type {Token} */
    let token;

    if (code === null || code === 91 || size > 999) {
      return nok(code)
    }

    if (code === 93) {
      if (!data) {
        return nok(code)
      }

      token = effects.exit('gfmFootnoteDefinitionLabelString');
      identifier = normalizeIdentifier(self.sliceSerialize(token));
      effects.enter('gfmFootnoteDefinitionLabelMarker');
      effects.consume(code);
      effects.exit('gfmFootnoteDefinitionLabelMarker');
      effects.exit('gfmFootnoteDefinitionLabel');
      return labelAfter
    }

    if (markdownLineEnding(code)) {
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      size++;
      return atBreak
    }

    effects.enter('chunkString').contentType = 'string';
    return label(code)
  }
  /** @type {State} */

  function label(code) {
    if (
      code === null ||
      markdownLineEnding(code) ||
      code === 91 ||
      code === 93 ||
      size > 999
    ) {
      effects.exit('chunkString');
      return atBreak(code)
    }

    if (!markdownLineEndingOrSpace(code)) {
      data = true;
    }

    size++;
    effects.consume(code);
    return code === 92 ? labelEscape : label
  }
  /** @type {State} */

  function labelEscape(code) {
    if (code === 91 || code === 92 || code === 93) {
      effects.consume(code);
      size++;
      return label
    }

    return label(code)
  }
  /** @type {State} */

  function labelAfter(code) {
    if (code === 58) {
      effects.enter('definitionMarker');
      effects.consume(code);
      effects.exit('definitionMarker'); // Any whitespace after the marker is eaten, forming indented code
      // is not possible.
      // No space is also fine, just like a block quote marker.

      return factorySpace(effects, done, 'gfmFootnoteDefinitionWhitespace')
    }

    return nok(code)
  }
  /** @type {State} */

  function done(code) {
    if (!defined.includes(identifier)) {
      defined.push(identifier);
    }

    return ok(code)
  }
}
/** @type {Tokenizer} */

function tokenizeDefinitionContinuation(effects, ok, nok) {
  // Either a blank line, which is okay, or an indented thing.
  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))
}
/** @type {Exiter} */

function gfmFootnoteDefinitionEnd(effects) {
  effects.exit('gfmFootnoteDefinition');
}
/** @type {Tokenizer} */

function tokenizeIndent(effects, ok, nok) {
  const self = this;
  return factorySpace(
    effects,
    afterPrefix,
    'gfmFootnoteDefinitionIndent',
    4 + 1
  )
  /** @type {State} */

  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return tail &&
      tail[1].type === 'gfmFootnoteDefinitionIndent' &&
      tail[2].sliceSerialize(tail[1], true).length === 4
      ? ok(code)
      : nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').Event} Event
 */

/**
 * @param {Options} [options]
 * @returns {Extension}
 */
function gfmStrikethrough(options = {}) {
  let single = options.singleTilde;
  const tokenizer = {
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };

  if (single === null || single === undefined) {
    single = true;
  }

  return {
    text: {
      [126]: tokenizer
    },
    insideSpan: {
      null: [tokenizer]
    },
    attentionMarkers: {
      null: [126]
    }
  }
  /**
   * Take events and resolve strikethrough.
   *
   * @type {Resolver}
   */

  function resolveAllStrikethrough(events, context) {
    let index = -1; // Walk through all events.

    while (++index < events.length) {
      // Find a token that can close.
      if (
        events[index][0] === 'enter' &&
        events[index][1].type === 'strikethroughSequenceTemporary' &&
        events[index][1]._close
      ) {
        let open = index; // Now walk back to find an opener.

        while (open--) {
          // Find a token that can open the closer.
          if (
            events[open][0] === 'exit' &&
            events[open][1].type === 'strikethroughSequenceTemporary' &&
            events[open][1]._open && // If the sizes are the same:
            events[index][1].end.offset - events[index][1].start.offset ===
              events[open][1].end.offset - events[open][1].start.offset
          ) {
            events[index][1].type = 'strikethroughSequence';
            events[open][1].type = 'strikethroughSequence';
            const strikethrough = {
              type: 'strikethrough',
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index][1].end)
            };
            const text = {
              type: 'strikethroughText',
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index][1].start)
            }; // Opening.

            const nextEvents = [
              ['enter', strikethrough, context],
              ['enter', events[open][1], context],
              ['exit', events[open][1], context],
              ['enter', text, context]
            ]; // Between.

            splice(
              nextEvents,
              nextEvents.length,
              0,
              resolveAll(
                context.parser.constructs.insideSpan.null,
                events.slice(open + 1, index),
                context
              )
            ); // Closing.

            splice(nextEvents, nextEvents.length, 0, [
              ['exit', text, context],
              ['enter', events[index][1], context],
              ['exit', events[index][1], context],
              ['exit', strikethrough, context]
            ]);
            splice(events, open - 1, index - open + 3, nextEvents);
            index = open + nextEvents.length - 2;
            break
          }
        }
      }
    }

    index = -1;

    while (++index < events.length) {
      if (events[index][1].type === 'strikethroughSequenceTemporary') {
        events[index][1].type = 'data';
      }
    }

    return events
  }
  /** @type {Tokenizer} */

  function tokenizeStrikethrough(effects, ok, nok) {
    const previous = this.previous;
    const events = this.events;
    let size = 0;
    return start
    /** @type {State} */

    function start(code) {
      if (
        previous === 126 &&
        events[events.length - 1][1].type !== 'characterEscape'
      ) {
        return nok(code)
      }

      effects.enter('strikethroughSequenceTemporary');
      return more(code)
    }
    /** @type {State} */

    function more(code) {
      const before = classifyCharacter(previous);

      if (code === 126) {
        // If this is the third marker, exit.
        if (size > 1) return nok(code)
        effects.consume(code);
        size++;
        return more
      }

      if (size < 2 && !single) return nok(code)
      const token = effects.exit('strikethroughSequenceTemporary');
      const after = classifyCharacter(code);
      token._open = !after || (after === 2 && Boolean(before));
      token._close = !before || (before === 2 && Boolean(after));
      return ok(code)
    }
  }
}

/**
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 */

/** @type {Extension} */
const gfmTable = {
  flow: {
    null: {
      tokenize: tokenizeTable,
      resolve: resolveTable
    }
  }
};
const nextPrefixedOrBlank = {
  tokenize: tokenizeNextPrefixedOrBlank,
  partial: true
};
/** @type {Resolver} */

function resolveTable(events, context) {
  let index = -1;
  /** @type {boolean|undefined} */

  let inHead;
  /** @type {boolean|undefined} */

  let inDelimiterRow;
  /** @type {boolean|undefined} */

  let inRow;
  /** @type {number|undefined} */

  let contentStart;
  /** @type {number|undefined} */

  let contentEnd;
  /** @type {number|undefined} */

  let cellStart;
  /** @type {boolean|undefined} */

  let seenCellInRow;

  while (++index < events.length) {
    const token = events[index][1];

    if (inRow) {
      if (token.type === 'temporaryTableCellContent') {
        contentStart = contentStart || index;
        contentEnd = index;
      }

      if (
        // Combine separate content parts into one.
        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&
        contentEnd
      ) {
        const content = {
          type: 'tableContent',
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end
        };
        /** @type {Token} */

        const text = {
          type: 'chunkText',
          start: content.start,
          end: content.end,
          // @ts-expect-error It’s fine.
          contentType: 'text'
        };
        events.splice(
          contentStart,
          contentEnd - contentStart + 1,
          ['enter', content, context],
          ['enter', text, context],
          ['exit', text, context],
          ['exit', content, context]
        );
        index -= contentEnd - contentStart - 3;
        contentStart = undefined;
        contentEnd = undefined;
      }
    }

    if (
      events[index][0] === 'exit' &&
      cellStart !== undefined &&
      cellStart + (seenCellInRow ? 0 : 1) < index &&
      (token.type === 'tableCellDivider' ||
        (token.type === 'tableRow' &&
          (cellStart + 3 < index ||
            events[cellStart][1].type !== 'whitespace')))
    ) {
      const cell = {
        type: inDelimiterRow
          ? 'tableDelimiter'
          : inHead
          ? 'tableHeader'
          : 'tableData',
        start: events[cellStart][1].start,
        end: events[index][1].end
      };
      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [
        'exit',
        cell,
        context
      ]);
      events.splice(cellStart, 0, ['enter', cell, context]);
      index += 2;
      cellStart = index + 1;
      seenCellInRow = true;
    }

    if (token.type === 'tableRow') {
      inRow = events[index][0] === 'enter';

      if (inRow) {
        cellStart = index + 1;
        seenCellInRow = false;
      }
    }

    if (token.type === 'tableDelimiterRow') {
      inDelimiterRow = events[index][0] === 'enter';

      if (inDelimiterRow) {
        cellStart = index + 1;
        seenCellInRow = false;
      }
    }

    if (token.type === 'tableHead') {
      inHead = events[index][0] === 'enter';
    }
  }

  return events
}
/** @type {Tokenizer} */

function tokenizeTable(effects, ok, nok) {
  const self = this;
  /** @type {Array<Align>} */

  const align = [];
  let tableHeaderCount = 0;
  /** @type {boolean|undefined} */

  let seenDelimiter;
  /** @type {boolean|undefined} */

  let hasDash;
  return start
  /** @type {State} */

  function start(code) {
    // @ts-expect-error Custom.
    effects.enter('table')._align = align;
    effects.enter('tableHead');
    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.

    if (code === 124) {
      return cellDividerHead(code)
    }

    tableHeaderCount++;
    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.

    return inCellContentHead(code)
  }
  /** @type {State} */

  function cellDividerHead(code) {
    effects.enter('tableCellDivider');
    effects.consume(code);
    effects.exit('tableCellDivider');
    seenDelimiter = true;
    return cellBreakHead
  }
  /** @type {State} */

  function cellBreakHead(code) {
    if (code === null || markdownLineEnding(code)) {
      return atRowEndHead(code)
    }

    if (markdownSpace(code)) {
      effects.enter('whitespace');
      effects.consume(code);
      return inWhitespaceHead
    }

    if (seenDelimiter) {
      seenDelimiter = undefined;
      tableHeaderCount++;
    }

    if (code === 124) {
      return cellDividerHead(code)
    } // Anything else is cell content.

    effects.enter('temporaryTableCellContent');
    return inCellContentHead(code)
  }
  /** @type {State} */

  function inWhitespaceHead(code) {
    if (markdownSpace(code)) {
      effects.consume(code);
      return inWhitespaceHead
    }

    effects.exit('whitespace');
    return cellBreakHead(code)
  }
  /** @type {State} */

  function inCellContentHead(code) {
    // EOF, whitespace, pipe
    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {
      effects.exit('temporaryTableCellContent');
      return cellBreakHead(code)
    }

    effects.consume(code);
    return code === 92 ? inCellContentEscapeHead : inCellContentHead
  }
  /** @type {State} */

  function inCellContentEscapeHead(code) {
    if (code === 92 || code === 124) {
      effects.consume(code);
      return inCellContentHead
    } // Anything else.

    return inCellContentHead(code)
  }
  /** @type {State} */

  function atRowEndHead(code) {
    if (code === null) {
      return nok(code)
    }

    effects.exit('tableRow');
    effects.exit('tableHead');
    const originalInterrupt = self.interrupt;
    self.interrupt = true;
    return effects.attempt(
      {
        tokenize: tokenizeRowEnd,
        partial: true
      },
      function (code) {
        self.interrupt = originalInterrupt;
        effects.enter('tableDelimiterRow');
        return atDelimiterRowBreak(code)
      },
      function (code) {
        self.interrupt = originalInterrupt;
        return nok(code)
      }
    )(code)
  }
  /** @type {State} */

  function atDelimiterRowBreak(code) {
    if (code === null || markdownLineEnding(code)) {
      return rowEndDelimiter(code)
    }

    if (markdownSpace(code)) {
      effects.enter('whitespace');
      effects.consume(code);
      return inWhitespaceDelimiter
    }

    if (code === 45) {
      effects.enter('tableDelimiterFiller');
      effects.consume(code);
      hasDash = true;
      align.push('none');
      return inFillerDelimiter
    }

    if (code === 58) {
      effects.enter('tableDelimiterAlignment');
      effects.consume(code);
      effects.exit('tableDelimiterAlignment');
      align.push('left');
      return afterLeftAlignment
    } // If we start with a pipe, we open a cell marker.

    if (code === 124) {
      effects.enter('tableCellDivider');
      effects.consume(code);
      effects.exit('tableCellDivider');
      return atDelimiterRowBreak
    }

    return nok(code)
  }
  /** @type {State} */

  function inWhitespaceDelimiter(code) {
    if (markdownSpace(code)) {
      effects.consume(code);
      return inWhitespaceDelimiter
    }

    effects.exit('whitespace');
    return atDelimiterRowBreak(code)
  }
  /** @type {State} */

  function inFillerDelimiter(code) {
    if (code === 45) {
      effects.consume(code);
      return inFillerDelimiter
    }

    effects.exit('tableDelimiterFiller');

    if (code === 58) {
      effects.enter('tableDelimiterAlignment');
      effects.consume(code);
      effects.exit('tableDelimiterAlignment');
      align[align.length - 1] =
        align[align.length - 1] === 'left' ? 'center' : 'right';
      return afterRightAlignment
    }

    return atDelimiterRowBreak(code)
  }
  /** @type {State} */

  function afterLeftAlignment(code) {
    if (code === 45) {
      effects.enter('tableDelimiterFiller');
      effects.consume(code);
      hasDash = true;
      return inFillerDelimiter
    } // Anything else is not ok.

    return nok(code)
  }
  /** @type {State} */

  function afterRightAlignment(code) {
    if (code === null || markdownLineEnding(code)) {
      return rowEndDelimiter(code)
    }

    if (markdownSpace(code)) {
      effects.enter('whitespace');
      effects.consume(code);
      return inWhitespaceDelimiter
    } // `|`

    if (code === 124) {
      effects.enter('tableCellDivider');
      effects.consume(code);
      effects.exit('tableCellDivider');
      return atDelimiterRowBreak
    }

    return nok(code)
  }
  /** @type {State} */

  function rowEndDelimiter(code) {
    effects.exit('tableDelimiterRow'); // Exit if there was no dash at all, or if the header cell count is not the
    // delimiter cell count.

    if (!hasDash || tableHeaderCount !== align.length) {
      return nok(code)
    }

    if (code === null) {
      return tableClose(code)
    }

    return effects.check(
      nextPrefixedOrBlank,
      tableClose,
      effects.attempt(
        {
          tokenize: tokenizeRowEnd,
          partial: true
        },
        factorySpace(effects, bodyStart, 'linePrefix', 4),
        tableClose
      )
    )(code)
  }
  /** @type {State} */

  function tableClose(code) {
    effects.exit('table');
    return ok(code)
  }
  /** @type {State} */

  function bodyStart(code) {
    effects.enter('tableBody');
    return rowStartBody(code)
  }
  /** @type {State} */

  function rowStartBody(code) {
    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.

    if (code === 124) {
      return cellDividerBody(code)
    }

    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.

    return inCellContentBody(code)
  }
  /** @type {State} */

  function cellDividerBody(code) {
    effects.enter('tableCellDivider');
    effects.consume(code);
    effects.exit('tableCellDivider');
    return cellBreakBody
  }
  /** @type {State} */

  function cellBreakBody(code) {
    if (code === null || markdownLineEnding(code)) {
      return atRowEndBody(code)
    }

    if (markdownSpace(code)) {
      effects.enter('whitespace');
      effects.consume(code);
      return inWhitespaceBody
    } // `|`

    if (code === 124) {
      return cellDividerBody(code)
    } // Anything else is cell content.

    effects.enter('temporaryTableCellContent');
    return inCellContentBody(code)
  }
  /** @type {State} */

  function inWhitespaceBody(code) {
    if (markdownSpace(code)) {
      effects.consume(code);
      return inWhitespaceBody
    }

    effects.exit('whitespace');
    return cellBreakBody(code)
  }
  /** @type {State} */

  function inCellContentBody(code) {
    // EOF, whitespace, pipe
    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {
      effects.exit('temporaryTableCellContent');
      return cellBreakBody(code)
    }

    effects.consume(code);
    return code === 92 ? inCellContentEscapeBody : inCellContentBody
  }
  /** @type {State} */

  function inCellContentEscapeBody(code) {
    if (code === 92 || code === 124) {
      effects.consume(code);
      return inCellContentBody
    } // Anything else.

    return inCellContentBody(code)
  }
  /** @type {State} */

  function atRowEndBody(code) {
    effects.exit('tableRow');

    if (code === null) {
      return tableBodyClose(code)
    }

    return effects.check(
      nextPrefixedOrBlank,
      tableBodyClose,
      effects.attempt(
        {
          tokenize: tokenizeRowEnd,
          partial: true
        },
        factorySpace(effects, rowStartBody, 'linePrefix', 4),
        tableBodyClose
      )
    )(code)
  }
  /** @type {State} */

  function tableBodyClose(code) {
    effects.exit('tableBody');
    return tableClose(code)
  }
  /** @type {Tokenizer} */

  function tokenizeRowEnd(effects, ok, nok) {
    return start
    /** @type {State} */

    function start(code) {
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      return factorySpace(effects, prefixed, 'linePrefix')
    }
    /** @type {State} */

    function prefixed(code) {
      // Blank or interrupting line.
      if (
        self.parser.lazy[self.now().line] ||
        code === null ||
        markdownLineEnding(code)
      ) {
        return nok(code)
      }

      const tail = self.events[self.events.length - 1]; // Indented code can interrupt delimiter and body rows.

      if (
        !self.parser.constructs.disable.null.includes('codeIndented') &&
        tail &&
        tail[1].type === 'linePrefix' &&
        tail[2].sliceSerialize(tail[1], true).length >= 4
      ) {
        return nok(code)
      }

      self._gfmTableDynamicInterruptHack = true;
      return effects.check(
        self.parser.constructs.flow,
        function (code) {
          self._gfmTableDynamicInterruptHack = false;
          return nok(code)
        },
        function (code) {
          self._gfmTableDynamicInterruptHack = false;
          return ok(code)
        }
      )(code)
    }
  }
}
/** @type {Tokenizer} */

function tokenizeNextPrefixedOrBlank(effects, ok, nok) {
  let size = 0;
  return start
  /** @type {State} */

  function start(code) {
    // This is a check, so we don’t care about tokens, but we open a bogus one
    // so we’re valid.
    effects.enter('check'); // EOL.

    effects.consume(code);
    return whitespace
  }
  /** @type {State} */

  function whitespace(code) {
    if (code === -1 || code === 32) {
      effects.consume(code);
      size++;
      return size === 4 ? ok : whitespace
    } // EOF or whitespace

    if (code === null || markdownLineEndingOrSpace(code)) {
      return ok(code)
    } // Anything else.

    return nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 * @typedef {import('micromark-util-types').Previous} Previous
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Code} Code
 */
const tasklistCheck = {
  tokenize: tokenizeTasklistCheck
};
const gfmTaskListItem = {
  text: {
    [91]: tasklistCheck
  }
};
/** @type {Tokenizer} */

function tokenizeTasklistCheck(effects, ok, nok) {
  const self = this;
  return open
  /** @type {State} */

  function open(code) {
    if (
      // Exit if there’s stuff before.
      self.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !self._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code)
    }

    effects.enter('taskListCheck');
    effects.enter('taskListCheckMarker');
    effects.consume(code);
    effects.exit('taskListCheckMarker');
    return inside
  }
  /** @type {State} */

  function inside(code) {
    // To match how GH works in comments, use `markdownSpace` (`[ \t]`) instead
    // of `markdownLineEndingOrSpace` (`[ \t\r\n]`).
    if (markdownLineEndingOrSpace(code)) {
      effects.enter('taskListCheckValueUnchecked');
      effects.consume(code);
      effects.exit('taskListCheckValueUnchecked');
      return close
    }

    if (code === 88 || code === 120) {
      effects.enter('taskListCheckValueChecked');
      effects.consume(code);
      effects.exit('taskListCheckValueChecked');
      return close
    }

    return nok(code)
  }
  /** @type {State} */

  function close(code) {
    if (code === 93) {
      effects.enter('taskListCheckMarker');
      effects.consume(code);
      effects.exit('taskListCheckMarker');
      effects.exit('taskListCheck');
      return effects.check(
        {
          tokenize: spaceThenNonSpace
        },
        ok,
        nok
      )
    }

    return nok(code)
  }
}
/** @type {Tokenizer} */

function spaceThenNonSpace(effects, ok, nok) {
  const self = this;
  return factorySpace(effects, after, 'whitespace')
  /** @type {State} */

  function after(code) {
    const tail = self.events[self.events.length - 1];
    return (
      // We either found spaces…
      ((tail && tail[1].type === 'whitespace') || // …or it was followed by a line ending, in which case, there has to be
        // non-whitespace after that line ending, because otherwise we’d get an
        // EOF as the content is closed with blank lines.
        markdownLineEnding(code)) &&
        code !== null
        ? ok(code)
        : nok(code)
    )
  }
}

/**
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
 * @typedef {import('micromark-extension-gfm-strikethrough').Options} Options
 * @typedef {import('micromark-extension-gfm-footnote').HtmlOptions} HtmlOptions
 */

/**
 * Support GFM or markdown on github.com.
 *
 * @param {Options} [options]
 * @returns {Extension}
 */
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral,
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable,
    gfmTaskListItem
  ])
}

/**
 * Count how often a character (or substring) is used in a string.
 *
 * @param {string} value
 *   Value to search in.
 * @param {string} character
 *   Character (or substring) to look for.
 * @return {number}
 *   Number of times `character` occurred in `value`.
 */
function ccount(value, character) {
  const source = String(value);

  if (typeof character !== 'string') {
    throw new TypeError('Expected character')
  }

  let count = 0;
  let index = source.indexOf(character);

  while (index !== -1) {
    count++;
    index = source.indexOf(character, index + character.length);
  }

  return count
}

function escapeStringRegexp(string) {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	// Escape characters with special meaning either inside or outside character sets.
	// Use a simple backslash escape when it’s always valid, and a `\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.
	return string
		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
		.replace(/-/g, '\\x2d');
}

/**
 * @param {string} d
 * @returns {string}
 */
function color(d) {
  return d
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('unist-util-is').Test} Test
 * @typedef {import('./complex-types').Action} Action
 * @typedef {import('./complex-types').Index} Index
 * @typedef {import('./complex-types').ActionTuple} ActionTuple
 * @typedef {import('./complex-types').VisitorResult} VisitorResult
 * @typedef {import('./complex-types').Visitor} Visitor
 */

/**
 * Continue traversing as normal
 */
const CONTINUE = true;
/**
 * Do not traverse this node’s children
 */
const SKIP = 'skip';
/**
 * Stop traversing immediately
 */
const EXIT = false;

/**
 * Visit children of tree which pass a test
 *
 * @param tree Abstract syntax tree to walk
 * @param test Test node, optional
 * @param visitor Function to run for each node
 * @param reverse Visit the tree in reverse order, defaults to false
 */
const visitParents =
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types').BuildVisitor<Tree>, reverse?: boolean) => void)
   * )}
   */
  (
    /**
     * @param {Node} tree
     * @param {Test} test
     * @param {import('./complex-types').Visitor<Node>} visitor
     * @param {boolean} [reverse]
     */
    function (tree, test, visitor, reverse) {
      if (typeof test === 'function' && typeof visitor !== 'function') {
        reverse = visitor;
        // @ts-expect-error no visitor given, so `visitor` is test.
        visitor = test;
        test = null;
      }

      const is = convert(test);
      const step = reverse ? -1 : 1;

      factory(tree, null, [])();

      /**
       * @param {Node} node
       * @param {number?} index
       * @param {Array.<Parent>} parents
       */
      function factory(node, index, parents) {
        /** @type {Object.<string, unknown>} */
        // @ts-expect-error: hush
        const value = typeof node === 'object' && node !== null ? node : {};
        /** @type {string|undefined} */
        let name;

        if (typeof value.type === 'string') {
          name =
            typeof value.tagName === 'string'
              ? value.tagName
              : typeof value.name === 'string'
              ? value.name
              : undefined;

          Object.defineProperty(visit, 'name', {
            value:
              'node (' +
              color(value.type + (name ? '<' + name + '>' : '')) +
              ')'
          });
        }

        return visit

        function visit() {
          /** @type {ActionTuple} */
          let result = [];
          /** @type {ActionTuple} */
          let subresult;
          /** @type {number} */
          let offset;
          /** @type {Array.<Parent>} */
          let grandparents;

          if (!test || is(node, index, parents[parents.length - 1] || null)) {
            result = toResult(visitor(node, parents));

            if (result[0] === EXIT) {
              return result
            }
          }

          // @ts-expect-error looks like a parent.
          if (node.children && result[0] !== SKIP) {
            // @ts-expect-error looks like a parent.
            offset = (reverse ? node.children.length : -1) + step;
            // @ts-expect-error looks like a parent.
            grandparents = parents.concat(node);

            // @ts-expect-error looks like a parent.
            while (offset > -1 && offset < node.children.length) {
              // @ts-expect-error looks like a parent.
              subresult = factory(node.children[offset], offset, grandparents)();

              if (subresult[0] === EXIT) {
                return subresult
              }

              offset =
                typeof subresult[1] === 'number' ? subresult[1] : offset + step;
            }
          }

          return result
        }
      }
    }
  );

/**
 * @param {VisitorResult} value
 * @returns {ActionTuple}
 */
function toResult(value) {
  if (Array.isArray(value)) {
    return value
  }

  if (typeof value === 'number') {
    return [CONTINUE, value]
  }

  return [value]
}

/**
 * @typedef Options
 *   Configuration (optional).
 * @property {Test} [ignore]
 *   `unist-util-is` test used to assert parents
 *
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast').Content} Content
 * @typedef {import('mdast').PhrasingContent} PhrasingContent
 * @typedef {import('mdast').Text} Text
 * @typedef {Content|Root} Node
 * @typedef {Exclude<Extract<Node, import('mdast').Parent>, Root>} Parent
 *
 * @typedef {import('unist-util-visit-parents').Test} Test
 * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
 *
 * @typedef RegExpMatchObject
 * @property {number} index
 * @property {string} input
 * @property {[Root, ...Array<Parent>, Text]} stack
 *
 * @typedef {string|RegExp} Find
 * @typedef {string|ReplaceFunction} Replace
 *
 * @typedef {[Find, Replace]} FindAndReplaceTuple
 * @typedef {Record<string, Replace>} FindAndReplaceSchema
 * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList
 *
 * @typedef {[RegExp, ReplaceFunction]} Pair
 * @typedef {Array<Pair>} Pairs
 */

const own = {}.hasOwnProperty;

/**
 * @param tree mdast tree
 * @param find Value to find and remove. When `string`, escaped and made into a global `RegExp`
 * @param [replace] Value to insert.
 *   * When `string`, turned into a Text node.
 *   * When `Function`, called with the results of calling `RegExp.exec` as
 *     arguments, in which case it can return a single or a list of `Node`,
 *     a `string` (which is wrapped in a `Text` node), or `false` to not replace
 * @param [options] Configuration.
 */
const findAndReplace =
  /**
   * @type {(
   *   ((tree: Node, find: Find, replace?: Replace, options?: Options) => Node) &
   *   ((tree: Node, schema: FindAndReplaceSchema|FindAndReplaceList, options?: Options) => Node)
   * )}
   **/
  (
    /**
     * @param {Node} tree
     * @param {Find|FindAndReplaceSchema|FindAndReplaceList} find
     * @param {Replace|Options} [replace]
     * @param {Options} [options]
     */
    function (tree, find, replace, options) {
      /** @type {Options|undefined} */
      let settings;
      /** @type {FindAndReplaceSchema|FindAndReplaceList} */
      let schema;

      if (typeof find === 'string' || find instanceof RegExp) {
        // @ts-expect-error don’t expect options twice.
        schema = [[find, replace]];
        settings = options;
      } else {
        schema = find;
        // @ts-expect-error don’t expect replace twice.
        settings = replace;
      }

      if (!settings) {
        settings = {};
      }

      const ignored = convert(settings.ignore || []);
      const pairs = toPairs(schema);
      let pairIndex = -1;

      while (++pairIndex < pairs.length) {
        visitParents(tree, 'text', visitor);
      }

      return tree

      /** @type {import('unist-util-visit-parents/complex-types').BuildVisitor<Root, 'text'>} */
      function visitor(node, parents) {
        let index = -1;
        /** @type {Parent|undefined} */
        let grandparent;

        while (++index < parents.length) {
          const parent = /** @type {Parent} */ (parents[index]);

          if (
            ignored(
              parent,
              // @ts-expect-error mdast vs. unist parent.
              grandparent ? grandparent.children.indexOf(parent) : undefined,
              grandparent
            )
          ) {
            return
          }

          grandparent = parent;
        }

        if (grandparent) {
          // @ts-expect-error: stack is fine.
          return handler(node, parents)
        }
      }

      /**
       * @param {Text} node
       * @param {[Root, ...Array<Parent>]} parents
       * @returns {VisitorResult}
       */
      function handler(node, parents) {
        const parent = parents[parents.length - 1];
        const find = pairs[pairIndex][0];
        const replace = pairs[pairIndex][1];
        let start = 0;
        // @ts-expect-error: TS is wrong, some of these children can be text.
        const index = parent.children.indexOf(node);
        let change = false;
        /** @type {Array<PhrasingContent>} */
        let nodes = [];
        /** @type {number|undefined} */
        let position;

        find.lastIndex = 0;

        let match = find.exec(node.value);

        while (match) {
          position = match.index;
          /** @type {RegExpMatchObject} */
          const matchObject = {
            index: match.index,
            input: match.input,
            stack: [...parents, node]
          };
          let value = replace(...match, matchObject);

          if (typeof value === 'string') {
            value = value.length > 0 ? {type: 'text', value} : undefined;
          }

          if (value !== false) {
            if (start !== position) {
              nodes.push({
                type: 'text',
                value: node.value.slice(start, position)
              });
            }

            if (Array.isArray(value)) {
              nodes.push(...value);
            } else if (value) {
              nodes.push(value);
            }

            start = position + match[0].length;
            change = true;
          }

          if (!find.global) {
            break
          }

          match = find.exec(node.value);
        }

        if (change) {
          if (start < node.value.length) {
            nodes.push({type: 'text', value: node.value.slice(start)});
          }

          parent.children.splice(index, 1, ...nodes);
        } else {
          nodes = [node];
        }

        return index + nodes.length
      }
    }
  );

/**
 * @param {FindAndReplaceSchema|FindAndReplaceList} schema
 * @returns {Pairs}
 */
function toPairs(schema) {
  /** @type {Pairs} */
  const result = [];

  if (typeof schema !== 'object') {
    throw new TypeError('Expected array or object as schema')
  }

  if (Array.isArray(schema)) {
    let index = -1;

    while (++index < schema.length) {
      result.push([
        toExpression(schema[index][0]),
        toFunction(schema[index][1])
      ]);
    }
  } else {
    /** @type {string} */
    let key;

    for (key in schema) {
      if (own.call(schema, key)) {
        result.push([toExpression(key), toFunction(schema[key])]);
      }
    }
  }

  return result
}

/**
 * @param {Find} find
 * @returns {RegExp}
 */
function toExpression(find) {
  return typeof find === 'string' ? new RegExp(escapeStringRegexp(find), 'g') : find
}

/**
 * @param {Replace} replace
 * @returns {ReplaceFunction}
 */
function toFunction(replace) {
  return typeof replace === 'function' ? replace : () => replace
}

/**
 * @typedef {import('mdast').Link} Link
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Transform} FromMarkdownTransform
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 * @typedef {import('mdast-util-to-markdown/lib/types.js').Options} ToMarkdownExtension
 * @typedef {import('mdast-util-find-and-replace').ReplaceFunction} ReplaceFunction
 * @typedef {import('mdast-util-find-and-replace').RegExpMatchObject} RegExpMatchObject
 * @typedef {import('mdast-util-find-and-replace').PhrasingContent} PhrasingContent
 */

const inConstruct = 'phrasing';
const notInConstruct = ['autolink', 'link', 'image', 'label'];

/** @type {FromMarkdownExtension} */
const gfmAutolinkLiteralFromMarkdown = {
  transforms: [transformGfmAutolinkLiterals],
  enter: {
    literalAutolink: enterLiteralAutolink,
    literalAutolinkEmail: enterLiteralAutolinkValue,
    literalAutolinkHttp: enterLiteralAutolinkValue,
    literalAutolinkWww: enterLiteralAutolinkValue
  },
  exit: {
    literalAutolink: exitLiteralAutolink,
    literalAutolinkEmail: exitLiteralAutolinkEmail,
    literalAutolinkHttp: exitLiteralAutolinkHttp,
    literalAutolinkWww: exitLiteralAutolinkWww
  }
};

/** @type {ToMarkdownExtension} */
const gfmAutolinkLiteralToMarkdown = {
  unsafe: [
    {
      character: '@',
      before: '[+\\-.\\w]',
      after: '[\\-.\\w]',
      inConstruct,
      notInConstruct
    },
    {
      character: '.',
      before: '[Ww]',
      after: '[\\-.\\w]',
      inConstruct,
      notInConstruct
    },
    {character: ':', before: '[ps]', after: '\\/', inConstruct, notInConstruct}
  ]
};

/** @type {FromMarkdownHandle} */
function enterLiteralAutolink(token) {
  this.enter({type: 'link', title: null, url: '', children: []}, token);
}

/** @type {FromMarkdownHandle} */
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}

/** @type {FromMarkdownHandle} */
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}

/** @type {FromMarkdownHandle} */
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node = /** @type {Link} */ (this.stack[this.stack.length - 1]);
  node.url = 'http://' + this.sliceSerialize(token);
}

/** @type {FromMarkdownHandle} */
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}

/** @type {FromMarkdownHandle} */
function exitLiteralAutolink(token) {
  this.exit(token);
}

/** @type {FromMarkdownTransform} */
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
    ],
    {ignore: ['link', 'linkReference']}
  );
}

/**
 * @type {ReplaceFunction}
 * @param {string} _
 * @param {string} protocol
 * @param {string} domain
 * @param {string} path
 * @param {RegExpMatchObject} match
 */
// eslint-disable-next-line max-params
function findUrl(_, protocol, domain, path, match) {
  let prefix = '';

  // Not an expected previous character.
  if (!previous(match)) {
    return false
  }

  // Treat `www` as part of the domain.
  if (/^w/i.test(protocol)) {
    domain = protocol + domain;
    protocol = '';
    prefix = 'http://';
  }

  if (!isCorrectDomain(domain)) {
    return false
  }

  const parts = splitUrl(domain + path);

  if (!parts[0]) return false

  /** @type {PhrasingContent} */
  const result = {
    type: 'link',
    title: null,
    url: prefix + protocol + parts[0],
    children: [{type: 'text', value: protocol + parts[0]}]
  };

  if (parts[1]) {
    return [result, {type: 'text', value: parts[1]}]
  }

  return result
}

/**
 * @type {ReplaceFunction}
 * @param {string} _
 * @param {string} atext
 * @param {string} label
 * @param {RegExpMatchObject} match
 */
function findEmail(_, atext, label, match) {
  if (
    // Not an expected previous character.
    !previous(match, true) ||
    // Label ends in not allowed character.
    /[_-\d]$/.test(label)
  ) {
    return false
  }

  return {
    type: 'link',
    title: null,
    url: 'mailto:' + atext + '@' + label,
    children: [{type: 'text', value: atext + '@' + label}]
  }
}

/**
 * @param {string} domain
 * @returns {boolean}
 */
function isCorrectDomain(domain) {
  const parts = domain.split('.');

  if (
    parts.length < 2 ||
    (parts[parts.length - 1] &&
      (/_/.test(parts[parts.length - 1]) ||
        !/[a-zA-Z\d]/.test(parts[parts.length - 1]))) ||
    (parts[parts.length - 2] &&
      (/_/.test(parts[parts.length - 2]) ||
        !/[a-zA-Z\d]/.test(parts[parts.length - 2])))
  ) {
    return false
  }

  return true
}

/**
 * @param {string} url
 * @returns {[string, string|undefined]}
 */
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  /** @type {number} */
  let closingParenIndex;
  /** @type {number} */
  let openingParens;
  /** @type {number} */
  let closingParens;
  /** @type {string|undefined} */
  let trail;

  if (trailExec) {
    url = url.slice(0, trailExec.index);
    trail = trailExec[0];
    closingParenIndex = trail.indexOf(')');
    openingParens = ccount(url, '(');
    closingParens = ccount(url, ')');

    while (closingParenIndex !== -1 && openingParens > closingParens) {
      url += trail.slice(0, closingParenIndex + 1);
      trail = trail.slice(closingParenIndex + 1);
      closingParenIndex = trail.indexOf(')');
      closingParens++;
    }
  }

  return [url, trail]
}

/**
 * @param {RegExpMatchObject} match
 * @param {boolean} [email=false]
 * @returns {boolean}
 */
function previous(match, email) {
  const code = match.input.charCodeAt(match.index - 1);

  return (
    (match.index === 0 ||
      unicodeWhitespace(code) ||
      unicodePunctuation(code)) &&
    (!email || code !== 47)
  )
}

/**
 * @typedef {import('mdast').Association} Association
 */

/**
 * The `label` of an association is the string value: character escapes and
 * references work, and casing is intact.
 * The `identifier` is used to match one association to another: controversially,
 * character escapes and references don’t work in this matching: `&copy;` does
 * not match `©`, and `\+` does not match `+`.
 * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\nb`
 * matches `a b`.
 * So, we do prefer the label when figuring out how we’re going to serialize:
 * it has whitespace, casing, and we can ignore most useless character escapes
 * and all character references.
 *
 * @param {Association} node
 * @returns {string}
 */
function association(node) {
  if (node.label || !node.identifier) {
    return node.label || ''
  }

  return decodeString(node.identifier)
}

/**
 * @typedef {import('unist').Point} Point
 * @typedef {import('../types.js').TrackFields} TrackFields
 */

/**
 * Functions to track output positions.
 * This info isn’t used yet but suchs functionality allows line wrapping,
 * and theoretically source maps (though, is there practical use in that?).
 *
 * @param {TrackFields} options_
 */
function track(options_) {
  // Defaults are used to prevent crashes when older utilities somehow activate
  // this code.
  /* c8 ignore next 5 */
  const options = options_ || {};
  const now = options.now || {};
  let lineShift = options.lineShift || 0;
  let line = now.line || 1;
  let column = now.column || 1;

  return {move, current, shift}

  /**
   * Get the current tracked info.
   *
   * @returns {{now: Point, lineShift: number}}
   */
  function current() {
    return {now: {line, column}, lineShift}
  }

  /**
   * Define an increased line shift (the typical indent for lines).
   *
   * @param {number} value
   */
  function shift(value) {
    lineShift += value;
  }

  /**
   * Move past a string.
   *
   * @param {string} value
   * @returns {string}
   */
  function move(value = '') {
    const chunks = value.split(/\r?\n|\r/g);
    const tail = chunks[chunks.length - 1];
    line += chunks.length - 1;
    column =
      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
    return value
  }
}

/**
 * @typedef {import('../types.js').Node} Node
 * @typedef {import('../types.js').Parent} Parent
 * @typedef {import('../types.js').Join} Join
 * @typedef {import('../types.js').Context} Context
 * @typedef {import('../types.js').TrackFields} TrackFields
 */

/**
 * @param {Parent} parent
 * @param {Context} context
 * @param {TrackFields} safeOptions
 * @returns {string}
 */
function containerFlow(parent, context, safeOptions) {
  const indexStack = context.indexStack;
  const children = parent.children || [];
  const tracker = track(safeOptions);
  /** @type {Array<string>} */
  const results = [];
  let index = -1;

  indexStack.push(-1);

  while (++index < children.length) {
    const child = children[index];

    indexStack[indexStack.length - 1] = index;

    results.push(
      tracker.move(
        context.handle(child, parent, context, {
          before: '\n',
          after: '\n',
          ...tracker.current()
        })
      )
    );

    if (child.type !== 'list') {
      context.bulletLastUsed = undefined;
    }

    if (index < children.length - 1) {
      results.push(tracker.move(between(child, children[index + 1])));
    }
  }

  indexStack.pop();

  return results.join('')

  /**
   * @param {Node} left
   * @param {Node} right
   * @returns {string}
   */
  function between(left, right) {
    let index = context.join.length;

    while (index--) {
      const result = context.join[index](left, right, parent, context);

      if (result === true || result === 1) {
        break
      }

      if (typeof result === 'number') {
        return '\n'.repeat(1 + result)
      }

      if (result === false) {
        return '\n\n<!---->\n\n'
      }
    }

    return '\n\n'
  }
}

/**
 * @callback Map
 * @param {string} value
 * @param {number} line
 * @param {boolean} blank
 * @returns {string}
 */

const eol = /\r?\n|\r/g;

/**
 * @param {string} value
 * @param {Map} map
 * @returns {string}
 */
function indentLines(value, map) {
  /** @type {Array<string>} */
  const result = [];
  let start = 0;
  let line = 0;
  /** @type {RegExpExecArray|null} */
  let match;

  while ((match = eol.exec(value))) {
    one(value.slice(start, match.index));
    result.push(match[0]);
    start = match.index + match[0].length;
    line++;
  }

  one(value.slice(start));

  return result.join('')

  /**
   * @param {string} value
   */
  function one(value) {
    result.push(map(value, line, !value));
  }
}

/**
 * @typedef {import('../types.js').Unsafe} Unsafe
 */

/**
 * @param {Unsafe} pattern
 * @returns {RegExp}
 */
function patternCompile(pattern) {
  if (!pattern._compiled) {
    const before =
      (pattern.atBreak ? '[\\r\\n][\\t ]*' : '') +
      (pattern.before ? '(?:' + pattern.before + ')' : '');

    pattern._compiled = new RegExp(
      (before ? '(' + before + ')' : '') +
        (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? '\\' : '') +
        pattern.character +
        (pattern.after ? '(?:' + pattern.after + ')' : ''),
      'g'
    );
  }

  return pattern._compiled
}

/**
 * @typedef {import('../types.js').Unsafe} Unsafe
 */

/**
 * @param {Array<string>} stack
 * @param {Unsafe} pattern
 * @returns {boolean}
 */
function patternInScope(stack, pattern) {
  return (
    listInScope(stack, pattern.inConstruct, true) &&
    !listInScope(stack, pattern.notInConstruct, false)
  )
}

/**
 * @param {Array<string>} stack
 * @param {Unsafe['inConstruct']} list
 * @param {boolean} none
 * @returns {boolean}
 */
function listInScope(stack, list, none) {
  if (!list) {
    return none
  }

  if (typeof list === 'string') {
    list = [list];
  }

  let index = -1;

  while (++index < list.length) {
    if (stack.includes(list[index])) {
      return true
    }
  }

  return false
}

/**
 * @typedef {import('../types.js').Context} Context
 * @typedef {import('../types.js').SafeOptions} SafeOptions
 */

/**
 * @param {Context} context
 * @param {string|null|undefined} input
 * @param {SafeOptions & {encode?: Array<string>}} config
 * @returns {string}
 */
function safe(context, input, config) {
  const value = (config.before || '') + (input || '') + (config.after || '');
  /** @type {Array<number>} */
  const positions = [];
  /** @type {Array<string>} */
  const result = [];
  /** @type {Record<number, {before: boolean, after: boolean}>} */
  const infos = {};
  let index = -1;

  while (++index < context.unsafe.length) {
    const pattern = context.unsafe[index];

    if (!patternInScope(context.stack, pattern)) {
      continue
    }

    const expression = patternCompile(pattern);
    /** @type {RegExpExecArray|null} */
    let match;

    while ((match = expression.exec(value))) {
      const before = 'before' in pattern || Boolean(pattern.atBreak);
      const after = 'after' in pattern;
      const position = match.index + (before ? match[1].length : 0);

      if (positions.includes(position)) {
        if (infos[position].before && !before) {
          infos[position].before = false;
        }

        if (infos[position].after && !after) {
          infos[position].after = false;
        }
      } else {
        positions.push(position);
        infos[position] = {before, after};
      }
    }
  }

  positions.sort(numerical);

  let start = config.before ? config.before.length : 0;
  const end = value.length - (config.after ? config.after.length : 0);
  index = -1;

  while (++index < positions.length) {
    const position = positions[index];

    // Character before or after matched:
    if (position < start || position >= end) {
      continue
    }

    // If this character is supposed to be escaped because it has a condition on
    // the next character, and the next character is definitly being escaped,
    // then skip this escape.
    if (
      (position + 1 < end &&
        positions[index + 1] === position + 1 &&
        infos[position].after &&
        !infos[position + 1].before &&
        !infos[position + 1].after) ||
      (positions[index - 1] === position - 1 &&
        infos[position].before &&
        !infos[position - 1].before &&
        !infos[position - 1].after)
    ) {
      continue
    }

    if (start !== position) {
      // If we have to use a character reference, an ampersand would be more
      // correct, but as backslashes only care about punctuation, either will
      // do the trick
      result.push(escapeBackslashes(value.slice(start, position), '\\'));
    }

    start = position;

    if (
      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&
      (!config.encode || !config.encode.includes(value.charAt(position)))
    ) {
      // Character escape.
      result.push('\\');
    } else {
      // Character reference.
      result.push(
        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'
      );
      start++;
    }
  }

  result.push(escapeBackslashes(value.slice(start, end), config.after));

  return result.join('')
}

/**
 * @param {number} a
 * @param {number} b
 * @returns {number}
 */
function numerical(a, b) {
  return a - b
}

/**
 * @param {string} value
 * @param {string} after
 * @returns {string}
 */
function escapeBackslashes(value, after) {
  const expression = /\\(?=[!-/:-@[-`{-~])/g;
  /** @type {Array<number>} */
  const positions = [];
  /** @type {Array<string>} */
  const results = [];
  const whole = value + after;
  let index = -1;
  let start = 0;
  /** @type {RegExpExecArray|null} */
  let match;

  while ((match = expression.exec(whole))) {
    positions.push(match.index);
  }

  while (++index < positions.length) {
    if (start !== positions[index]) {
      results.push(value.slice(start, positions[index]));
    }

    results.push('\\');
    start = positions[index];
  }

  results.push(value.slice(start));

  return results.join('')
}

/**
 * @typedef {import('mdast').FootnoteReference} FootnoteReference
 * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
 * @typedef {import('mdast-util-to-markdown').Map} Map
 */

/**
 * @returns {FromMarkdownExtension}
 */
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteDefinition: enterFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteCallString: enterFootnoteCallString
    },
    exit: {
      gfmFootnoteDefinition: exitFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteCallString: exitFootnoteCallString
    }
  }

  /** @type {FromMarkdownHandle} */
  function enterFootnoteDefinition(token) {
    this.enter(
      {type: 'footnoteDefinition', identifier: '', label: '', children: []},
      token
    );
  }

  /** @type {FromMarkdownHandle} */
  function enterFootnoteDefinitionLabelString() {
    this.buffer();
  }

  /** @type {FromMarkdownHandle} */
  function exitFootnoteDefinitionLabelString(token) {
    const label = this.resume();
    const node = /** @type {FootnoteDefinition} */ (
      this.stack[this.stack.length - 1]
    );
    node.label = label;
    node.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }

  /** @type {FromMarkdownHandle} */
  function exitFootnoteDefinition(token) {
    this.exit(token);
  }

  /** @type {FromMarkdownHandle} */
  function enterFootnoteCall(token) {
    this.enter({type: 'footnoteReference', identifier: '', label: ''}, token);
  }

  /** @type {FromMarkdownHandle} */
  function enterFootnoteCallString() {
    this.buffer();
  }

  /** @type {FromMarkdownHandle} */
  function exitFootnoteCallString(token) {
    const label = this.resume();
    const node = /** @type {FootnoteDefinition} */ (
      this.stack[this.stack.length - 1]
    );
    node.label = label;
    node.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }

  /** @type {FromMarkdownHandle} */
  function exitFootnoteCall(token) {
    this.exit(token);
  }
}

/**
 * @returns {ToMarkdownExtension}
 */
function gfmFootnoteToMarkdown() {
  footnoteReference.peek = footnoteReferencePeek;

  return {
    // This is on by default already.
    unsafe: [{character: '[', inConstruct: ['phrasing', 'label', 'reference']}],
    handlers: {footnoteDefinition, footnoteReference}
  }

  /**
   * @type {ToMarkdownHandle}
   * @param {FootnoteReference} node
   */
  function footnoteReference(node, _, context, safeOptions) {
    const tracker = track(safeOptions);
    let value = tracker.move('[^');
    const exit = context.enter('footnoteReference');
    const subexit = context.enter('reference');
    value += tracker.move(
      safe(context, association(node), {
        ...tracker.current(),
        before: value,
        after: ']'
      })
    );
    subexit();
    exit();
    value += tracker.move(']');
    return value
  }

  /** @type {ToMarkdownHandle} */
  function footnoteReferencePeek() {
    return '['
  }

  /**
   * @type {ToMarkdownHandle}
   * @param {FootnoteDefinition} node
   */
  function footnoteDefinition(node, _, context, safeOptions) {
    const tracker = track(safeOptions);
    let value = tracker.move('[^');
    const exit = context.enter('footnoteDefinition');
    const subexit = context.enter('label');
    value += tracker.move(
      safe(context, association(node), {
        ...tracker.current(),
        before: value,
        after: ']'
      })
    );
    subexit();
    value += tracker.move(
      ']:' + (node.children && node.children.length > 0 ? ' ' : '')
    );
    tracker.shift(4);
    value += tracker.move(
      indentLines(containerFlow(node, context, tracker.current()), map)
    );
    exit();

    return value

    /** @type {Map} */
    function map(line, index, blank) {
      if (index) {
        return (blank ? '' : '    ') + line
      }

      return line
    }
  }
}

/**
 * @typedef {import('../types.js').Node} Node
 * @typedef {import('../types.js').Parent} Parent
 * @typedef {import('../types.js').SafeOptions} SafeOptions
 * @typedef {import('../types.js').Context} Context
 */

/**
 * @param {Parent} parent
 * @param {Context} context
 * @param {SafeOptions} safeOptions
 * @returns {string}
 */
function containerPhrasing(parent, context, safeOptions) {
  const indexStack = context.indexStack;
  const children = parent.children || [];
  /** @type {Array<string>} */
  const results = [];
  let index = -1;
  let before = safeOptions.before;

  indexStack.push(-1);
  let tracker = track(safeOptions);

  while (++index < children.length) {
    const child = children[index];
    /** @type {string} */
    let after;

    indexStack[indexStack.length - 1] = index;

    if (index + 1 < children.length) {
      // @ts-expect-error: hush, it’s actually a `zwitch`.
      let handle = context.handle.handlers[children[index + 1].type];
      if (handle && handle.peek) handle = handle.peek;
      after = handle
        ? handle(children[index + 1], parent, context, {
            before: '',
            after: '',
            ...tracker.current()
          }).charAt(0)
        : '';
    } else {
      after = safeOptions.after;
    }

    // In some cases, html (text) can be found in phrasing right after an eol.
    // When we’d serialize that, in most cases that would be seen as html
    // (flow).
    // As we can’t escape or so to prevent it from happening, we take a somewhat
    // reasonable approach: replace that eol with a space.
    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>
    if (
      results.length > 0 &&
      (before === '\r' || before === '\n') &&
      child.type === 'html'
    ) {
      results[results.length - 1] = results[results.length - 1].replace(
        /(\r?\n|\r)$/,
        ' '
      );
      before = ' ';

      // To do: does this work to reset tracker?
      tracker = track(safeOptions);
      tracker.move(results.join(''));
    }

    results.push(
      tracker.move(
        context.handle(child, parent, context, {
          ...tracker.current(),
          before,
          after
        })
      )
    );

    before = results[results.length - 1].slice(-1);
  }

  indexStack.pop();

  return results.join('')
}

/**
 * @typedef {import('mdast').Delete} Delete
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
 */

/** @type {FromMarkdownExtension} */
const gfmStrikethroughFromMarkdown = {
  canContainEols: ['delete'],
  enter: {strikethrough: enterStrikethrough},
  exit: {strikethrough: exitStrikethrough}
};

/** @type {ToMarkdownExtension} */
const gfmStrikethroughToMarkdown = {
  unsafe: [{character: '~', inConstruct: 'phrasing'}],
  handlers: {delete: handleDelete}
};

handleDelete.peek = peekDelete;

/** @type {FromMarkdownHandle} */
function enterStrikethrough(token) {
  this.enter({type: 'delete', children: []}, token);
}

/** @type {FromMarkdownHandle} */
function exitStrikethrough(token) {
  this.exit(token);
}

/**
 * @type {ToMarkdownHandle}
 * @param {Delete} node
 */
function handleDelete(node, _, context, safeOptions) {
  const tracker = track(safeOptions);
  const exit = context.enter('emphasis');
  let value = tracker.move('~~');
  value += containerPhrasing(node, context, {
    ...tracker.current(),
    before: value,
    after: '~'
  });
  value += tracker.move('~~');
  exit();
  return value
}

/** @type {ToMarkdownHandle} */
function peekDelete() {
  return '~'
}

/**
 * @typedef {import('mdast').InlineCode} InlineCode
 * @typedef {import('../types.js').Handle} Handle
 */

inlineCode.peek = inlineCodePeek;

/**
 * @type {Handle}
 * @param {InlineCode} node
 */
function inlineCode(node, _, context) {
  let value = node.value || '';
  let sequence = '`';
  let index = -1;

  // If there is a single grave accent on its own in the code, use a fence of
  // two.
  // If there are two in a row, use one.
  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {
    sequence += '`';
  }

  // If this is not just spaces or eols (tabs don’t count), and either the
  // first or last character are a space, eol, or tick, then pad with spaces.
  if (
    /[^ \r\n]/.test(value) &&
    ((/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value)) || /^`|`$/.test(value))
  ) {
    value = ' ' + value + ' ';
  }

  // We have a potential problem: certain characters after eols could result in
  // blocks being seen.
  // For example, if someone injected the string `'\n# b'`, then that would
  // result in an ATX heading.
  // We can’t escape characters in `inlineCode`, but because eols are
  // transformed to spaces when going from markdown to HTML anyway, we can swap
  // them out.
  while (++index < context.unsafe.length) {
    const pattern = context.unsafe[index];
    const expression = patternCompile(pattern);
    /** @type {RegExpExecArray|null} */
    let match;

    // Only look for `atBreak`s.
    // Btw: note that `atBreak` patterns will always start the regex at LF or
    // CR.
    if (!pattern.atBreak) continue

    while ((match = expression.exec(value))) {
      let position = match.index;

      // Support CRLF (patterns only look for one of the characters).
      if (
        value.charCodeAt(position) === 10 /* `\n` */ &&
        value.charCodeAt(position - 1) === 13 /* `\r` */
      ) {
        position--;
      }

      value = value.slice(0, position) + ' ' + value.slice(match.index + 1);
    }
  }

  return sequence + value + sequence
}

/**
 * @type {Handle}
 */
function inlineCodePeek() {
  return '`'
}

/**
 * @typedef Options
 *   Configuration (optional).
 * @property {string|null|Array<string|null|undefined>} [align]
 *   One style for all columns, or styles for their respective columns.
 *   Each style is either `'l'` (left), `'r'` (right), or `'c'` (center).
 *   Other values are treated as `''`, which doesn’t place the colon in the
 *   alignment row but does align left.
 *   *Only the lowercased first character is used, so `Right` is fine.*
 * @property {boolean} [padding=true]
 *   Whether to add a space of padding between delimiters and cells.
 *
 *   When `true`, there is padding:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   When `false`, there is no padding:
 *
 *   ```markdown
 *   |Alpha|B    |
 *   |-----|-----|
 *   |C    |Delta|
 *   ```
 * @property {boolean} [delimiterStart=true]
 *   Whether to begin each row with the delimiter.
 *
 *   > 👉 **Note**: please don’t use this: it could create fragile structures
 *   > that aren’t understandable to some markdown parsers.
 *
 *   When `true`, there are starting delimiters:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   When `false`, there are no starting delimiters:
 *
 *   ```markdown
 *   Alpha | B     |
 *   ----- | ----- |
 *   C     | Delta |
 *   ```
 * @property {boolean} [delimiterEnd=true]
 *   Whether to end each row with the delimiter.
 *
 *   > 👉 **Note**: please don’t use this: it could create fragile structures
 *   > that aren’t understandable to some markdown parsers.
 *
 *   When `true`, there are ending delimiters:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   When `false`, there are no ending delimiters:
 *
 *   ```markdown
 *   | Alpha | B
 *   | ----- | -----
 *   | C     | Delta
 *   ```
 * @property {boolean} [alignDelimiters=true]
 *   Whether to align the delimiters.
 *   By default, they are aligned:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   Pass `false` to make them staggered:
 *
 *   ```markdown
 *   | Alpha | B |
 *   | - | - |
 *   | C | Delta |
 *   ```
 * @property {(value: string) => number} [stringLength]
 *   Function to detect the length of table cell content.
 *   This is used when aligning the delimiters (`|`) between table cells.
 *   Full-width characters and emoji mess up delimiter alignment when viewing
 *   the markdown source.
 *   To fix this, you can pass this function, which receives the cell content
 *   and returns its “visible” size.
 *   Note that what is and isn’t visible depends on where the text is displayed.
 *
 *   Without such a function, the following:
 *
 *   ```js
 *   markdownTable([
 *     ['Alpha', 'Bravo'],
 *     ['中文', 'Charlie'],
 *     ['👩‍❤️‍👩', 'Delta']
 *   ])
 *   ```
 *
 *   Yields:
 *
 *   ```markdown
 *   | Alpha | Bravo |
 *   | - | - |
 *   | 中文 | Charlie |
 *   | 👩‍❤️‍👩 | Delta |
 *   ```
 *
 *   With [`string-width`](https://github.com/sindresorhus/string-width):
 *
 *   ```js
 *   import stringWidth from 'string-width'
 *
 *   markdownTable(
 *     [
 *       ['Alpha', 'Bravo'],
 *       ['中文', 'Charlie'],
 *       ['👩‍❤️‍👩', 'Delta']
 *     ],
 *     {stringLength: stringWidth}
 *   )
 *   ```
 *
 *   Yields:
 *
 *   ```markdown
 *   | Alpha | Bravo   |
 *   | ----- | ------- |
 *   | 中文  | Charlie |
 *   | 👩‍❤️‍👩    | Delta   |
 *   ```
 */

/**
 * @typedef {Options} MarkdownTableOptions
 * @todo
 *   Remove next major.
 */

/**
 * Generate a markdown ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables)) table..
 *
 * @param {Array<Array<string|null|undefined>>} table
 *   Table data (matrix of strings).
 * @param {Options} [options]
 *   Configuration (optional).
 * @returns {string}
 */
function markdownTable(table, options = {}) {
  const align = (options.align || []).concat();
  const stringLength = options.stringLength || defaultStringLength;
  /** @type {Array<number>} Character codes as symbols for alignment per column. */
  const alignments = [];
  /** @type {Array<Array<string>>} Cells per row. */
  const cellMatrix = [];
  /** @type {Array<Array<number>>} Sizes of each cell per row. */
  const sizeMatrix = [];
  /** @type {Array<number>} */
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;

  // This is a superfluous loop if we don’t align delimiters, but otherwise we’d
  // do superfluous work when aligning, so optimize for aligning.
  while (++rowIndex < table.length) {
    /** @type {Array<string>} */
    const row = [];
    /** @type {Array<number>} */
    const sizes = [];
    let columnIndex = -1;

    if (table[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table[rowIndex].length;
    }

    while (++columnIndex < table[rowIndex].length) {
      const cell = serialize(table[rowIndex][columnIndex]);

      if (options.alignDelimiters !== false) {
        const size = stringLength(cell);
        sizes[columnIndex] = size;

        if (
          longestCellByColumn[columnIndex] === undefined ||
          size > longestCellByColumn[columnIndex]
        ) {
          longestCellByColumn[columnIndex] = size;
        }
      }

      row.push(cell);
    }

    cellMatrix[rowIndex] = row;
    sizeMatrix[rowIndex] = sizes;
  }

  // Figure out which alignments to use.
  let columnIndex = -1;

  if (typeof align === 'object' && 'length' in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code = toAlignment(align);

    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = code;
    }
  }

  // Inject the alignment row.
  columnIndex = -1;
  /** @type {Array<string>} */
  const row = [];
  /** @type {Array<number>} */
  const sizes = [];

  while (++columnIndex < mostCellsPerRow) {
    const code = alignments[columnIndex];
    let before = '';
    let after = '';

    if (code === 99 /* `c` */) {
      before = ':';
      after = ':';
    } else if (code === 108 /* `l` */) {
      before = ':';
    } else if (code === 114 /* `r` */) {
      after = ':';
    }

    // There *must* be at least one hyphen-minus in each alignment cell.
    let size =
      options.alignDelimiters === false
        ? 1
        : Math.max(
            1,
            longestCellByColumn[columnIndex] - before.length - after.length
          );

    const cell = before + '-'.repeat(size) + after;

    if (options.alignDelimiters !== false) {
      size = before.length + size + after.length;

      if (size > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size;
      }

      sizes[columnIndex] = size;
    }

    row[columnIndex] = cell;
  }

  // Inject the alignment row.
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);

  rowIndex = -1;
  /** @type {Array<string>} */
  const lines = [];

  while (++rowIndex < cellMatrix.length) {
    const row = cellMatrix[rowIndex];
    const sizes = sizeMatrix[rowIndex];
    columnIndex = -1;
    /** @type {Array<string>} */
    const line = [];

    while (++columnIndex < mostCellsPerRow) {
      const cell = row[columnIndex] || '';
      let before = '';
      let after = '';

      if (options.alignDelimiters !== false) {
        const size =
          longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0);
        const code = alignments[columnIndex];

        if (code === 114 /* `r` */) {
          before = ' '.repeat(size);
        } else if (code === 99 /* `c` */) {
          if (size % 2) {
            before = ' '.repeat(size / 2 + 0.5);
            after = ' '.repeat(size / 2 - 0.5);
          } else {
            before = ' '.repeat(size / 2);
            after = before;
          }
        } else {
          after = ' '.repeat(size);
        }
      }

      if (options.delimiterStart !== false && !columnIndex) {
        line.push('|');
      }

      if (
        options.padding !== false &&
        // Don’t add the opening space if we’re not aligning and the cell is
        // empty: there will be a closing space.
        !(options.alignDelimiters === false && cell === '') &&
        (options.delimiterStart !== false || columnIndex)
      ) {
        line.push(' ');
      }

      if (options.alignDelimiters !== false) {
        line.push(before);
      }

      line.push(cell);

      if (options.alignDelimiters !== false) {
        line.push(after);
      }

      if (options.padding !== false) {
        line.push(' ');
      }

      if (
        options.delimiterEnd !== false ||
        columnIndex !== mostCellsPerRow - 1
      ) {
        line.push('|');
      }
    }

    lines.push(
      options.delimiterEnd === false
        ? line.join('').replace(/ +$/, '')
        : line.join('')
    );
  }

  return lines.join('\n')
}

/**
 * @param {string|null|undefined} [value]
 * @returns {string}
 */
function serialize(value) {
  return value === null || value === undefined ? '' : String(value)
}

/**
 * @param {string} value
 * @returns {number}
 */
function defaultStringLength(value) {
  return value.length
}

/**
 * @param {string|null|undefined} value
 * @returns {number}
 */
function toAlignment(value) {
  const code = typeof value === 'string' ? value.codePointAt(0) : 0;

  return code === 67 /* `C` */ || code === 99 /* `c` */
    ? 99 /* `c` */
    : code === 76 /* `L` */ || code === 108 /* `l` */
    ? 108 /* `l` */
    : code === 82 /* `R` */ || code === 114 /* `r` */
    ? 114 /* `r` */
    : 0
}

/**
 * @typedef {import('mdast').AlignType} AlignType
 * @typedef {import('mdast').Table} Table
 * @typedef {import('mdast').TableRow} TableRow
 * @typedef {import('mdast').TableCell} TableCell
 * @typedef {import('mdast').InlineCode} InlineCode
 * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
 * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext
 * @typedef {import('mdast-util-to-markdown').SafeOptions} SafeOptions
 *
 * @typedef Options
 * @property {boolean} [tableCellPadding=true]
 * @property {boolean} [tablePipeAlign=true]
 * @property {MarkdownTableOptions['stringLength']} [stringLength]
 */

/** @type {FromMarkdownExtension} */
const gfmTableFromMarkdown = {
  enter: {
    table: enterTable,
    tableData: enterCell,
    tableHeader: enterCell,
    tableRow: enterRow
  },
  exit: {
    codeText: exitCodeText,
    table: exitTable,
    tableData: exit,
    tableHeader: exit,
    tableRow: exit
  }
};

/** @type {FromMarkdownHandle} */
function enterTable(token) {
  /** @type {Array<'left'|'right'|'center'|'none'>} */
  // @ts-expect-error: `align` is custom.
  const align = token._align;
  this.enter(
    {
      type: 'table',
      align: align.map((d) => (d === 'none' ? null : d)),
      children: []
    },
    token
  );
  this.setData('inTable', true);
}

/** @type {FromMarkdownHandle} */
function exitTable(token) {
  this.exit(token);
  this.setData('inTable');
}

/** @type {FromMarkdownHandle} */
function enterRow(token) {
  this.enter({type: 'tableRow', children: []}, token);
}

/** @type {FromMarkdownHandle} */
function exit(token) {
  this.exit(token);
}

/** @type {FromMarkdownHandle} */
function enterCell(token) {
  this.enter({type: 'tableCell', children: []}, token);
}

// Overwrite the default code text data handler to unescape escaped pipes when
// they are in tables.
/** @type {FromMarkdownHandle} */
function exitCodeText(token) {
  let value = this.resume();

  if (this.getData('inTable')) {
    value = value.replace(/\\([\\|])/g, replace);
  }

  const node = /** @type {InlineCode} */ (this.stack[this.stack.length - 1]);
  node.value = value;
  this.exit(token);
}

/**
 * @param {string} $0
 * @param {string} $1
 * @returns {string}
 */
function replace($0, $1) {
  // Pipes work, backslashes don’t (but can’t escape pipes).
  return $1 === '|' ? $1 : $0
}

/**
 * @param {Options} [options]
 * @returns {ToMarkdownExtension}
 */
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding ? ' ' : '|';

  return {
    unsafe: [
      {character: '\r', inConstruct: 'tableCell'},
      {character: '\n', inConstruct: 'tableCell'},
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      {atBreak: true, character: '|', after: '[\t :-]'},
      // A pipe in a cell must be encoded.
      {character: '|', inConstruct: 'tableCell'},
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      {atBreak: true, character: ':', after: '-'},
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      {atBreak: true, character: '-', after: '[:|-]'}
    ],
    handlers: {
      table: handleTable,
      tableRow: handleTableRow,
      tableCell: handleTableCell,
      inlineCode: inlineCodeWithTable
    }
  }

  /**
   * @type {ToMarkdownHandle}
   * @param {Table} node
   */
  function handleTable(node, _, context, safeOptions) {
    return serializeData(
      handleTableAsData(node, context, safeOptions),
      // @ts-expect-error: fixed in `markdown-table@3.0.1`.
      node.align
    )
  }

  /**
   * This function isn’t really used normally, because we handle rows at the
   * table level.
   * But, if someone passes in a table row, this ensures we make somewhat sense.
   *
   * @type {ToMarkdownHandle}
   * @param {TableRow} node
   */
  function handleTableRow(node, _, context, safeOptions) {
    const row = handleTableRowAsData(node, context, safeOptions);
    // `markdown-table` will always add an align row
    const value = serializeData([row]);
    return value.slice(0, value.indexOf('\n'))
  }

  /**
   * @type {ToMarkdownHandle}
   * @param {TableCell} node
   */
  function handleTableCell(node, _, context, safeOptions) {
    const exit = context.enter('tableCell');
    const subexit = context.enter('phrasing');
    const value = containerPhrasing(node, context, {
      ...safeOptions,
      before: around,
      after: around
    });
    subexit();
    exit();
    return value
  }

  /**
   * @param {Array<Array<string>>} matrix
   * @param {Array<string>} [align]
   */
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      alignDelimiters,
      padding,
      stringLength
    })
  }

  /**
   * @param {Table} node
   * @param {ToMarkdownContext} context
   * @param {SafeOptions} safeOptions
   */
  function handleTableAsData(node, context, safeOptions) {
    const children = node.children;
    let index = -1;
    /** @type {Array<Array<string>>} */
    const result = [];
    const subexit = context.enter('table');

    while (++index < children.length) {
      result[index] = handleTableRowAsData(
        children[index],
        context,
        safeOptions
      );
    }

    subexit();

    return result
  }

  /**
   * @param {TableRow} node
   * @param {ToMarkdownContext} context
   * @param {SafeOptions} safeOptions
   */
  function handleTableRowAsData(node, context, safeOptions) {
    const children = node.children;
    let index = -1;
    /** @type {Array<string>} */
    const result = [];
    const subexit = context.enter('tableRow');

    while (++index < children.length) {
      // Note: the positional info as used here is incorrect.
      // Making it correct would be impossible due to aligning cells?
      // And it would need copy/pasting `markdown-table` into this project.
      result[index] = handleTableCell(
        children[index],
        node,
        context,
        safeOptions
      );
    }

    subexit();

    return result
  }

  /**
   * @type {ToMarkdownHandle}
   * @param {InlineCode} node
   */
  function inlineCodeWithTable(node, parent, context) {
    let value = inlineCode(node, parent, context);

    if (context.stack.includes('tableCell')) {
      value = value.replace(/\|/g, '\\$&');
    }

    return value
  }
}

/**
 * @typedef {import('../types.js').Context} Context
 * @typedef {import('../types.js').Options} Options
 */

/**
 * @param {Context} context
 * @returns {Exclude<Options['bullet'], undefined>}
 */
function checkBullet(context) {
  const marker = context.options.bullet || '*';

  if (marker !== '*' && marker !== '+' && marker !== '-') {
    throw new Error(
      'Cannot serialize items with `' +
        marker +
        '` for `options.bullet`, expected `*`, `+`, or `-`'
    )
  }

  return marker
}

/**
 * @typedef {import('../types.js').Context} Context
 * @typedef {import('../types.js').Options} Options
 */

/**
 * @param {Context} context
 * @returns {Exclude<Options['listItemIndent'], undefined>}
 */
function checkListItemIndent(context) {
  const style = context.options.listItemIndent || 'tab';

  // To do: remove in a major.
  // @ts-expect-error: deprecated.
  if (style === 1 || style === '1') {
    return 'one'
  }

  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {
    throw new Error(
      'Cannot serialize items with `' +
        style +
        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'
    )
  }

  return style
}

/**
 * @typedef {import('mdast').ListItem} ListItem
 * @typedef {import('mdast').List} List
 * @typedef {import('../util/indent-lines.js').Map} Map
 * @typedef {import('../types.js').Options} Options
 * @typedef {import('../types.js').Handle} Handle
 */

/**
 * @type {Handle}
 * @param {ListItem} node
 */
function listItem(node, parent, context, safeOptions) {
  const listItemIndent = checkListItemIndent(context);
  let bullet = context.bulletCurrent || checkBullet(context);

  // Add the marker value for ordered lists.
  if (parent && parent.type === 'list' && parent.ordered) {
    bullet =
      (typeof parent.start === 'number' && parent.start > -1
        ? parent.start
        : 1) +
      (context.options.incrementListMarker === false
        ? 0
        : parent.children.indexOf(node)) +
      bullet;
  }

  let size = bullet.length + 1;

  if (
    listItemIndent === 'tab' ||
    (listItemIndent === 'mixed' &&
      ((parent && parent.type === 'list' && parent.spread) || node.spread))
  ) {
    size = Math.ceil(size / 4) * 4;
  }

  const tracker = track(safeOptions);
  tracker.move(bullet + ' '.repeat(size - bullet.length));
  tracker.shift(size);
  const exit = context.enter('listItem');
  const value = indentLines(
    containerFlow(node, context, tracker.current()),
    map
  );
  exit();

  return value

  /** @type {Map} */
  function map(line, index, blank) {
    if (index) {
      return (blank ? '' : ' '.repeat(size)) + line
    }

    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line
  }
}

/**
 * @typedef {Extract<import('mdast').Root|import('mdast').Content, import('unist').Parent>} Parent
 * @typedef {import('mdast').ListItem} ListItem
 * @typedef {import('mdast').Paragraph} Paragraph
 * @typedef {import('mdast').BlockContent} BlockContent
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
 */

/** @type {FromMarkdownExtension} */
const gfmTaskListItemFromMarkdown = {
  exit: {
    taskListCheckValueChecked: exitCheck,
    taskListCheckValueUnchecked: exitCheck,
    paragraph: exitParagraphWithTaskListItem
  }
};

/** @type {ToMarkdownExtension} */
const gfmTaskListItemToMarkdown = {
  unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],
  handlers: {listItem: listItemWithTaskListItem}
};

/** @type {FromMarkdownHandle} */
function exitCheck(token) {
  const node = /** @type {ListItem} */ (this.stack[this.stack.length - 2]);
  // We’re always in a paragraph, in a list item.
  node.checked = token.type === 'taskListCheckValueChecked';
}

/** @type {FromMarkdownHandle} */
function exitParagraphWithTaskListItem(token) {
  const parent = /** @type {Parent} */ (this.stack[this.stack.length - 2]);
  const node = /** @type {Paragraph} */ (this.stack[this.stack.length - 1]);
  const siblings = parent.children;
  const head = node.children[0];
  let index = -1;
  /** @type {Paragraph|undefined} */
  let firstParaghraph;

  if (
    parent &&
    parent.type === 'listItem' &&
    typeof parent.checked === 'boolean' &&
    head &&
    head.type === 'text'
  ) {
    while (++index < siblings.length) {
      const sibling = siblings[index];
      if (sibling.type === 'paragraph') {
        firstParaghraph = sibling;
        break
      }
    }

    if (firstParaghraph === node) {
      // Must start with a space or a tab.
      head.value = head.value.slice(1);

      if (head.value.length === 0) {
        node.children.shift();
      } else if (
        node.position &&
        head.position &&
        typeof head.position.start.offset === 'number'
      ) {
        head.position.start.column++;
        head.position.start.offset++;
        node.position.start = Object.assign({}, head.position.start);
      }
    }
  }

  this.exit(token);
}

/**
 * @type {ToMarkdownHandle}
 * @param {ListItem} node
 */
function listItemWithTaskListItem(node, parent, context, safeOptions) {
  const head = node.children[0];
  const checkable =
    typeof node.checked === 'boolean' && head && head.type === 'paragraph';
  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] ';
  const tracker = track(safeOptions);

  if (checkable) {
    tracker.move(checkbox);
  }

  let value = listItem(node, parent, context, {
    ...safeOptions,
    ...tracker.current()
  });

  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }

  return value

  /**
   * @param {string} $0
   * @returns {string}
   */
  function check($0) {
    return $0 + checkbox
  }
}

/**
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 *
 * @typedef {import('mdast-util-gfm-table').Options} Options
 */

/**
 * @returns {Array<FromMarkdownExtension>}
 */
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown,
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown,
    gfmTableFromMarkdown,
    gfmTaskListItemFromMarkdown
  ]
}

/**
 * @param {Options} [options]
 * @returns {ToMarkdownExtension}
 */
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown,
      gfmFootnoteToMarkdown(),
      gfmStrikethroughToMarkdown,
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown
    ]
  }
}

/**
 * @typedef {import('mdast').Root} Root
 * @typedef {import('micromark-extension-gfm').Options & import('mdast-util-gfm').Options} Options
 */

/**
 * Plugin to support GFM (autolink literals, footnotes, strikethrough, tables, tasklists).
 *
 * @type {import('unified').Plugin<[Options?]|void[], Root>}
 */
function remarkGfm(options = {}) {
  const data = this.data();

  add('micromarkExtensions', gfm(options));
  add('fromMarkdownExtensions', gfmFromMarkdown());
  add('toMarkdownExtensions', gfmToMarkdown(options));

  /**
   * @param {string} field
   * @param {unknown} value
   */
  function add(field, value) {
    const list = /** @type {unknown[]} */ (
      // Other extensions
      /* c8 ignore next 2 */
      data[field] ? data[field] : (data[field] = [])
    );

    list.push(value);
  }
}

const selectNodes = selectAll;
const DEFAULT_SETTINGS = {
    hardBreakFormat: '  '
};
/**
 * Class representing the plugin
 */
class HardBreaksPlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            // load pluging settings
            yield this.loadSettings();
            // add settings tab to Obsidian settings panel
            this.addSettingTab(new HardBreaksPluginSettingsTab(this.app, this));
            // add command to replace all soft breaks in the current document with hard breaks
            this.addCommand({
                id: 'replace-all-soft-breaks',
                name: 'Force hard line breaks in current document',
                editorCallback: (editor, view) => {
                    this.forceHardBreaks(editor);
                }
            });
        });
    }
    forceHardBreaks(editor) {
        /**
         * It would be much more elegant (and easy!) to use Obsidian editor's replaceRange()
         * function to replace each range that represents a target text node, but that'd
         * result in multiple editor changes. So if the user wanted to undo what the command
         * did, they'd have to undo a change for every text node we inserted hard breaks
         * into. The solution below is more clunky (and probably more costly), but only
         * created a single change event.
         * A better solution has yet to be found...
         */
        let text = editor.getValue();
        this.getTextRanges(text).forEach(range => {
            const replacement = text
                .substring(range.from + this.settings.hardBreakFormat.length, range.to)
                .replace(/[ \t]*(?=\r\n|\r|\n)/gm, this.settings.hardBreakFormat);
            text = text.substring(0, range.from + this.settings.hardBreakFormat.length)
                + replacement
                + text.substring(range.to);
        });
        editor.setValue(text);
    }
    getTextRanges(md) {
        return selectNodes('root > paragraph > text, root > blockquote > paragraph > text', unified()
            .use(remarkParse)
            .use(remarkFrontmatter, ['yaml'])
            .use(remarkGfm)
            .parse(md))
            .filter(n => n.position.start.line < n.position.end.line)
            .map(n => ({
            'from': n.position.start.offset,
            'to': n.position.end.offset
        }));
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
}
/**
 * Class representing plugin settings tab
 */
class HardBreaksPluginSettingsTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    display() {
        const { containerEl } = this;
        containerEl.empty();
        containerEl.createEl('h3', { text: 'Hard Breaks' });
        containerEl.createEl('small', { text: 'Hint: Access this plugin\'s command via the editor\'s command palette.' });
        const settings = this.plugin.settings;
        // hard line break format setting
        new obsidian.Setting(containerEl)
            .setName('Hard Line Break Format')
            .setDesc('The type of Markdown notation to use for hard line breaks')
            .addDropdown(dropdown => dropdown
            .addOptions({
            '  ': 'Double Whitespace',
            '\\': 'Backslash'
        })
            .setValue(settings.hardBreakFormat)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            settings.hardBreakFormat = value;
            yield this.plugin.saveSettings();
        })));
    }
}

module.exports = HardBreaksPlugin;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXMiOlsibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIm5vZGVfbW9kdWxlcy9iYWlsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9leHRlbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Ryb3VnaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bmlzdC11dGlsLXN0cmluZ2lmeS1wb3NpdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZmlsZS1tZXNzYWdlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZmaWxlL2xpYi9taW5wYXRoLmJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdmZpbGUvbGliL21pbnByb2MuYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy92ZmlsZS9saWIvbWludXJsLnNoYXJlZC5qcyIsIm5vZGVfbW9kdWxlcy92ZmlsZS9saWIvbWludXJsLmJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdmZpbGUvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VuaWZpZWQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3p3aXRjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bmlzdC11dGlsLXNlbGVjdC9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy91bmlzdC11dGlsLXNlbGVjdC9saWIvbmVzdC5qcyIsIm5vZGVfbW9kdWxlcy91bmlzdC11dGlsLWlzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VuaXN0LXV0aWwtc2VsZWN0L2xpYi9wc2V1ZG8uanMiLCJub2RlX21vZHVsZXMvdW5pc3QtdXRpbC1zZWxlY3QvbGliL2F0dHJpYnV0ZS5qcyIsIm5vZGVfbW9kdWxlcy91bmlzdC11dGlsLXNlbGVjdC9saWIvbmFtZS5qcyIsIm5vZGVfbW9kdWxlcy91bmlzdC11dGlsLXNlbGVjdC9saWIvdGVzdC5qcyIsIm5vZGVfbW9kdWxlcy91bmlzdC11dGlsLXNlbGVjdC9saWIvYW55LmpzIiwibm9kZV9tb2R1bGVzL2Nzcy1zZWxlY3Rvci1wYXJzZXIvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2Nzcy1zZWxlY3Rvci1wYXJzZXIvbGliL3BhcnNlci1jb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL2Nzcy1zZWxlY3Rvci1wYXJzZXIvbGliL3JlbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9jc3Mtc2VsZWN0b3ItcGFyc2VyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9udGgtY2hlY2svbGliL2VzbS9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9ib29sYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9udGgtY2hlY2svbGliL2VzbS9jb21waWxlLmpzIiwibm9kZV9tb2R1bGVzL250aC1jaGVjay9saWIvZXNtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VuaXN0LXV0aWwtc2VsZWN0L2xpYi9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy91bmlzdC11dGlsLXNlbGVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLXN0cmluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1jaHVua2VkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay11dGlsLWNvbWJpbmUtZXh0ZW5zaW9ucy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1jaGFyYWN0ZXIvbGliL3VuaWNvZGUtcHVuY3R1YXRpb24tcmVnZXguanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay1mYWN0b3J5LXNwYWNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay9saWIvaW5pdGlhbGl6ZS9jb250ZW50LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay9saWIvaW5pdGlhbGl6ZS9kb2N1bWVudC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1jbGFzc2lmeS1jaGFyYWN0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrLXV0aWwtcmVzb2x2ZS1hbGwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvYXR0ZW50aW9uLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2F1dG9saW5rLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2JsYW5rLWxpbmUuanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvYmxvY2stcXVvdGUuanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvY2hhcmFjdGVyLWVzY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9kZWNvZGUtbmFtZWQtY2hhcmFjdGVyLXJlZmVyZW5jZS9pbmRleC5kb20uanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvY2hhcmFjdGVyLXJlZmVyZW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9jb2RlLWZlbmNlZC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9jb2RlLWluZGVudGVkLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2NvZGUtdGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1zdWJ0b2tlbml6ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9jb250ZW50LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay1mYWN0b3J5LWRlc3RpbmF0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay1mYWN0b3J5LWxhYmVsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay1mYWN0b3J5LXRpdGxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay1mYWN0b3J5LXdoaXRlc3BhY2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrLXV0aWwtbm9ybWFsaXplLWlkZW50aWZpZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvZGVmaW5pdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9oYXJkLWJyZWFrLWVzY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9oZWFkaW5nLWF0eC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1odG1sLXRhZy1uYW1lL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2h0bWwtZmxvdy5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9odG1sLXRleHQuanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvbGFiZWwtZW5kLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2xhYmVsLXN0YXJ0LWltYWdlLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2xhYmVsLXN0YXJ0LWxpbmsuanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvbGluZS1lbmRpbmcuanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvdGhlbWF0aWMtYnJlYWsuanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvbGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9zZXRleHQtdW5kZXJsaW5lLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay9saWIvaW5pdGlhbGl6ZS9mbG93LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay9saWIvaW5pdGlhbGl6ZS90ZXh0LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay9saWIvY3JlYXRlLXRva2VuaXplci5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmsvbGliL2NvbnN0cnVjdHMuanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrL2xpYi9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmsvbGliL3ByZXByb2Nlc3MuanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrL2xpYi9wb3N0cHJvY2Vzcy5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1kZWNvZGUtbnVtZXJpYy1jaGFyYWN0ZXItcmVmZXJlbmNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay11dGlsLWRlY29kZS1zdHJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZW1hcmstcGFyc2UvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Zvcm1hdC9mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZmF1bHQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1mcm9udG1hdHRlci9tYXR0ZXJzLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay1leHRlbnNpb24tZnJvbnRtYXR0ZXIvbGliL3N5bnRheC5qcyIsIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWZyb250bWF0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlbWFyay1mcm9udG1hdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1hdXRvbGluay1saXRlcmFsL2xpYi9zeW50YXguanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tZm9vdG5vdGUvbGliL3N5bnRheC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1zdHJpa2V0aHJvdWdoL2xpYi9zeW50YXguanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvbGliL3N5bnRheC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YXNrLWxpc3QtaXRlbS9saWIvc3ludGF4LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWFyay1leHRlbnNpb24tZ2ZtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Njb3VudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bmlzdC11dGlsLXZpc2l0LXBhcmVudHMvY29sb3IuYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91bmlzdC11dGlsLXZpc2l0LXBhcmVudHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWdmbS1hdXRvbGluay1saXRlcmFsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvYXNzb2NpYXRpb24uanMiLCJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC90cmFjay5qcyIsIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NvbnRhaW5lci1mbG93LmpzIiwibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvaW5kZW50LWxpbmVzLmpzIiwibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvcGF0dGVybi1jb21waWxlLmpzIiwibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvcGF0dGVybi1pbi1zY29wZS5qcyIsIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL3NhZmUuanMiLCJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1nZm0tZm9vdG5vdGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC9jb250YWluZXItcGhyYXNpbmcuanMiLCJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1nZm0tc3RyaWtldGhyb3VnaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvaW5saW5lLWNvZGUuanMiLCJub2RlX21vZHVsZXMvbWFya2Rvd24tdGFibGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1nZm0tdGFibGUvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvY2hlY2stYnVsbGV0LmpzIiwibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvY2hlY2stbGlzdC1pdGVtLWluZGVudC5qcyIsIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvbGlzdC1pdGVtLmpzIiwibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZ2ZtLXRhc2stbGlzdC1pdGVtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZ2ZtL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZW1hcmstZ2ZtL2luZGV4LmpzIiwic3JjL21haW4udHMiXSwic291cmNlc0NvbnRlbnQiOm51bGwsIm5hbWVzIjpbImlzUGxhaW5PYmplY3QiLCJwYXRoIiwiYXNzZXJ0UGF0aCIsImJ1ZmZlciIsIm93biIsImlzUGxhaW5PYmoiLCJyb290IiwiaGFuZGxlIiwic2VsZWN0b3JzIiwicnVsZVNldCIsInJ1bGUiLCJjb25maWd1cmUiLCJ1dGlsc18xIiwicmVxdWlyZSQkMCIsInJlcXVpcmUkJDEiLCJwYXJzZSIsImNvbXBpbGUiLCJudGhDaGVjayIsImZhdXhFc21OdGhDaGVjayIsIkNzc1NlbGVjdG9yUGFyc2VyIiwiY29udGVudCIsImRvY3VtZW50IiwiZXhpdCIsInByZXZpb3VzIiwidG9rZW5pemVJbmRlbnQiLCJmbG93Iiwic3RyaW5nIiwidGV4dCIsInJlc29sdmVUZXh0IiwiZmVuY2UiLCJwaWNrIiwiZXNjYXBlIiwiUGx1Z2luIiwiUGx1Z2luU2V0dGluZ1RhYiIsIlNldHRpbmciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF1REE7QUFDTyxTQUFTLFNBQVMsQ0FBQyxPQUFPLEVBQUUsVUFBVSxFQUFFLENBQUMsRUFBRSxTQUFTLEVBQUU7QUFDN0QsSUFBSSxTQUFTLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxPQUFPLEtBQUssWUFBWSxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLFVBQVUsT0FBTyxFQUFFLEVBQUUsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7QUFDaEgsSUFBSSxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sRUFBRSxNQUFNLEVBQUU7QUFDL0QsUUFBUSxTQUFTLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FB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SUFBSSxPQUFPLEtBQUssQ0FBQyxTQUFTLEtBQUssUUFBUTtBQUN2QyxJQUFJLEtBQUssQ0FBQyxTQUFTLEtBQUssS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDO0FBQzNDLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRTtBQUM3QyxFQUFFLFVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFDO0FBQzFCLEVBQUUsT0FBTyxLQUFLLENBQUMsU0FBUyxLQUFLLENBQUM7QUFDOUIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUU7QUFDNUMsRUFBRSxVQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBQztBQUMxQixFQUFFLE9BQU8sT0FBTyxLQUFLLENBQUMsU0FBUyxLQUFLLFFBQVEsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUM7QUFDNUUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsWUFBWSxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUU7QUFDaEQsRUFBRSxVQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBQztBQUMxQixFQUFFO0FBQ0YsSUFBSSxPQUFPLEtBQUssQ0FBQyxTQUFTLEtBQUssUUFBUTtBQUN2QyxJQUFJLE9BQU8sS0FBSyxDQUFDLFNBQVMsS0FBSyxRQUFRO0FBQ3ZDLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO0FBQ3RELEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRTtBQUM3QyxFQUFFLFVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFDO0FBQzFCLEVBQUUsT0FBTyxPQUFPLEtBQUssQ0FBQyxTQUFTLEtBQUssUUFBUSxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQztBQUM1RSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxhQUFhLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRTtBQUNqRCxFQUFFLFVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFDO0FBQzFCLEVBQUU7QUFDRixJQUFJLE9BQU8sS0FBSyxDQUFDLFNBQVMsS0FBSyxRQUFRO0FBQ3ZDLElBQUksT0FBTyxLQUFLLENBQUMsU0FBUyxLQUFLLFFBQVE7QUFDdkMsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUM7QUFDdEQsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVcsQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFO0FBQy9DLEVBQUUsVUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUM7QUFDMUIsRUFBRSxPQUFPLEtBQUssQ0FBQyxTQUFTLEtBQUssQ0FBQztBQUM5QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxV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UixFQUFFLFVBQVU7QUFDWixFQUFFLFlBQVk7QUFDZCxFQUFFLE1BQU07QUFDUixFQUFFLFNBQVM7QUFDWCxFQUFFLFFBQVE7QUFDVixFQUFFLEtBQUs7QUFDUCxFQUFFLFVBQVU7QUFDWixFQUFFLElBQUk7QUFDTixFQUFFLFNBQVM7QUFDWCxFQUFFLFFBQVE7QUFDVixFQUFFLEtBQUs7QUFDUCxFQUFFLEtBQUs7QUFDUCxFQUFFLElBQUk7QUFDTixFQUFFLElBQUk7QUFDTixFQUFFLFVBQVU7QUFDWixFQUFFLFlBQVk7QUFDZCxFQUFFLFFBQVE7QUFDVixFQUFFLFFBQVE7QUFDVixFQUFFLE1BQU07QUFDUixFQUFFLE9BQU87QUFDVCxFQUFFLFVBQVU7QUFDWixFQUFFLElBQUk7QUFDTixFQUFFLElBQUk7QUFDTixFQUFFLElBQUk7QUFDTixFQUFFLElBQUk7QUFDTixFQUFFLElBQUk7QUFDTixFQUFFLElBQUk7QUFDTixFQUFFLE1BQU07QUFDUixFQUFFLFFBQVE7QUFDVixFQUFFLElBQUk7QUFDTixFQUFFLE1BQU07QUFDUixFQUFFLFFBQVE7QUFDVixFQUFFLFFBQVE7QUFDVixFQUFFLElBQUk7QUFDTixFQUFFLE1BQU07QUFDUixFQUFFLE1BQU07QUFDUixFQUFFLE1BQU07QUFDUixFQUFFLFVBQVU7QUFDWixFQUFFLEtBQUs7QUFDUCxFQUFFLFVBQVU7QUFDWixFQUFFLElBQUk7QUFDTixFQUFFLFVBQVU7QUFDWixFQUFFLFFBQVE7QUFDVixFQUFFLEdBQUc7QUFDTCxFQUFFLE9BQU87QUFDVCxFQUFFLFNBQVM7QUFDWCxFQUFFLFNBQVM7QUFDWCxFQUFFLE9BQU87QUFDVCxFQUFFLE9BQU87QUFDVCxFQUFFLElBQUk7QUFDTixFQUFFLE9BQU87QUFDVCxFQUFFLElBQUk7QUFDTixFQUFFLE9BQU87QUFDVCxFQUFFLE9BQU87QUFDVCxFQUFFLElBQUk7QUFDTixFQUFFLE9BQU87QUFDVCxFQUFFLElBQUk7QUFDTixFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sSUFBSSxFQUFDO0FBQzlCO0FBQ0EsRUFBRSxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxTQUFTLE9BQU8sR0FBRztBQUNyQixJQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQUUsU0FBUyxDQUFDO0FBQzNDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFNBQVMsS0FBSyxDQUFDLEtBQUssRUFBRTtBQUN4QixJQUFJLFNBQVMsSUFBSSxNQUFLO0FBQ3RCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsU0FBUyxJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsRUFBRTtBQUM1QixJQUFJLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFDO0FBQzNDLElBQUksTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFDO0FBQzFDLElBQUksSUFBSSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsRUFBQztBQUM3QixJQUFJLE1BQU07QUFDVixNQUFNLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLFVBQVM7QUFDOUUsSUFBSSxPQUFPLEtBQUs7QUFDaEIsR0FBRztBQUNIOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBUyxhQUFhLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUU7QUFDNUQsRUFBRSxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsV0FBVTtB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QUFDN0MsTUFBTSxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsTUFBSztBQUNoQztBQUNBO0FBQ0EsTUFBTTtBQUNOLFFBQVEsS0FBSyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFO0FBQ3pDLFFBQVEsS0FBSyxDQUFDLFVBQVUsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRTtBQUM3QyxRQUFRO0FBQ1IsUUFBUSxRQUFRLEdBQUU7QUFDbEIsT0FBTztBQUNQO0FBQ0EsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLEdBQUcsR0FBRyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUM7QUFDM0UsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEVBQUUsT0FBTyxRQUFRLEdBQUcsS0FBSyxHQUFHLFFBQVE7QUFDcEMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxjQUFjLEdBQUc7QUFDMUIsRUFBRSxPQUFPLEdBQUc7QUFDWjs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTLGFBQWEsQ0FBQyxLQUFLLEVBQUUsT0FBTyxHQUFHLEVBQUUsRUFBRTtBQUNuRCxFQUFFLE1BQU0sS0FBSyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssSUFBSSxFQUFFLEVBQUUsTUFBTSxHQUFFO0FBQzlDLEVBQUUsTUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLFlBQVksSUFBSSxvQkFBbUI7QUFDbEU7QUFDQSxFQUFFLE1BQU0sVUFBVSxHQUFHLEdBQUU7QUFDdkI7QUFDQSxFQUFFLE1BQU0sVUFBVSxHQUFHLEdBQUU7QUFDdkI7QUFDQSxFQUFFLE1BQU0sVUFBVSxHQUFHLEdBQUU7QUFDdkI7QUFDQSxFQUFFLE1BQU0sbUJBQW1CLEdBQUcsR0FBRTtBQUNoQyxFQUFFLElBQUksZUFBZSxHQUFHLEVBQUM7QUFDekIsRUFBRSxJQUFJLFFBQVEsR0FBRyxDQUFDLEVBQUM7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxPQUFPLEVBQUUsUUFBUSxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUU7QUFDcEM7QUFDQSxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUU7QUFDbEI7QUFDQSxJQUFJLE1BQU0sS0FBSyxHQUFHLEdBQUU7QUFDcEIsSUFBSSxJQUFJ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
