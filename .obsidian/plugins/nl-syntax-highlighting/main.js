/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all4) => {
  for (var name in all4)
    __defProp(target, name, { get: all4[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NLSyntaxHighlightPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// syntaxHighlight.ts
var import_view = require("@codemirror/view");

// node_modules/compromise/src/API/world.js
var methods = {
  one: {},
  two: {},
  three: {},
  four: {}
};
var model = {
  one: {},
  two: {},
  three: {}
};
var compute = {};
var hooks = [];
var world_default = { methods, model, compute, hooks };

// node_modules/compromise/src/API/methods/compute.js
var isArray = (input) => Object.prototype.toString.call(input) === "[object Array]";
var fns = {
  compute: function(input) {
    const { world: world2 } = this;
    const compute4 = world2.compute;
    if (typeof input === "string" && compute4.hasOwnProperty(input)) {
      compute4[input](this);
    } else if (isArray(input)) {
      input.forEach((name) => {
        if (world2.compute.hasOwnProperty(name)) {
          compute4[name](this);
        } else {
          console.warn("no compute:", input);
        }
      });
    } else if (typeof input === "function") {
      input(this);
    } else {
      console.warn("no compute:", input);
    }
    return this;
  }
};
var compute_default = fns;

// node_modules/compromise/src/API/methods/loops.js
var forEach = function(cb) {
  let ptrs = this.fullPointer;
  ptrs.forEach((ptr, i3) => {
    let view = this.update([ptr]);
    cb(view, i3);
  });
  return this;
};
var map = function(cb, empty) {
  let ptrs = this.fullPointer;
  let res = ptrs.map((ptr, i3) => {
    let view = this.update([ptr]);
    let out2 = cb(view, i3);
    if (out2 === void 0) {
      return this.none();
    }
    return out2;
  });
  if (res.length === 0) {
    return empty || this.update([]);
  }
  if (res[0] !== void 0) {
    if (typeof res[0] === "string") {
      return res;
    }
    if (typeof res[0] === "object" && (res[0] === null || !res[0].isView)) {
      return res;
    }
  }
  let all4 = [];
  res.forEach((ptr) => {
    all4 = all4.concat(ptr.fullPointer);
  });
  return this.toView(all4);
};
var filter = function(cb) {
  let ptrs = this.fullPointer;
  ptrs = ptrs.filter((ptr, i3) => {
    let view = this.update([ptr]);
    return cb(view, i3);
  });
  let res = this.update(ptrs);
  return res;
};
var find = function(cb) {
  let ptrs = this.fullPointer;
  let found = ptrs.find((ptr, i3) => {
    let view = this.update([ptr]);
    return cb(view, i3);
  });
  return this.update([found]);
};
var some = function(cb) {
  let ptrs = this.fullPointer;
  return ptrs.some((ptr, i3) => {
    let view = this.update([ptr]);
    return cb(view, i3);
  });
};
var random = function(n3 = 1) {
  let ptrs = this.fullPointer;
  let r2 = Math.floor(Math.random() * ptrs.length);
  if (r2 + n3 > this.length) {
    r2 = this.length - n3;
    r2 = r2 < 0 ? 0 : r2;
  }
  ptrs = ptrs.slice(r2, r2 + n3);
  return this.update(ptrs);
};
var loops_default = { forEach, map, filter, find, some, random };

// node_modules/compromise/src/API/methods/utils.js
var utils = {
  termList: function() {
    return this.methods.one.termList(this.docs);
  },
  terms: function(n3) {
    let m3 = this.match(".");
    return typeof n3 === "number" ? m3.eq(n3) : m3;
  },
  groups: function(group) {
    if (group || group === 0) {
      return this.update(this._groups[group] || []);
    }
    let res = {};
    Object.keys(this._groups).forEach((k2) => {
      res[k2] = this.update(this._groups[k2]);
    });
    return res;
  },
  eq: function(n3) {
    let ptr = this.pointer;
    if (!ptr) {
      ptr = this.docs.map((_doc, i3) => [i3]);
    }
    if (ptr[n3]) {
      return this.update([ptr[n3]]);
    }
    return this.none();
  },
  first: function() {
    return this.eq(0);
  },
  last: function() {
    let n3 = this.fullPointer.length - 1;
    return this.eq(n3);
  },
  firstTerms: function() {
    return this.match("^.");
  },
  lastTerms: function() {
    return this.match(".$");
  },
  slice: function(min2, max3) {
    let pntrs = this.pointer || this.docs.map((_o, n3) => [n3]);
    pntrs = pntrs.slice(min2, max3);
    return this.update(pntrs);
  },
  all: function() {
    return this.update().toView();
  },
  fullSentences: function() {
    let ptrs = this.fullPointer.map((a2) => [a2[0]]);
    return this.update(ptrs).toView();
  },
  none: function() {
    return this.update([]);
  },
  isDoc: function(b) {
    if (!b || !b.isView) {
      return false;
    }
    let aPtr = this.fullPointer;
    let bPtr = b.fullPointer;
    if (!aPtr.length === bPtr.length) {
      return false;
    }
    return aPtr.every((ptr, i3) => {
      if (!bPtr[i3]) {
        return false;
      }
      return ptr[0] === bPtr[i3][0] && ptr[1] === bPtr[i3][1] && ptr[2] === bPtr[i3][2];
    });
  },
  wordCount: function() {
    return this.docs.reduce((count, terms) => {
      count += terms.filter((t2) => t2.text !== "").length;
      return count;
    }, 0);
  },
  isFull: function() {
    let ptrs = this.pointer;
    if (!ptrs) {
      return true;
    }
    let document2 = this.document;
    for (let i3 = 0; i3 < ptrs.length; i3 += 1) {
      let [n3, start2, end2] = ptrs[i3];
      if (n3 !== i3 || start2 !== 0) {
        return false;
      }
      if (document2[n3].length > end2) {
        return false;
      }
    }
    return true;
  },
  getNth: function(n3) {
    if (typeof n3 === "number") {
      return this.eq(n3);
    } else if (typeof n3 === "string") {
      return this.if(n3);
    }
    return this;
  }
};
utils.group = utils.groups;
utils.fullSentence = utils.fullSentences;
utils.sentence = utils.fullSentences;
utils.lastTerm = utils.lastTerms;
utils.firstTerm = utils.firstTerms;
var utils_default = utils;

// node_modules/compromise/src/API/methods/index.js
var methods2 = Object.assign({}, utils_default, compute_default, loops_default);
methods2.get = methods2.eq;
var methods_default = methods2;

// node_modules/compromise/src/API/View.js
var View = class {
  constructor(document2, pointer, groups = {}) {
    [
      ["document", document2],
      ["world", world_default],
      ["_groups", groups],
      ["_cache", null],
      ["viewType", "View"]
    ].forEach((a2) => {
      Object.defineProperty(this, a2[0], {
        value: a2[1],
        writable: true
      });
    });
    this.ptrs = pointer;
  }
  get docs() {
    let docs = this.document;
    if (this.ptrs) {
      docs = world_default.methods.one.getDoc(this.ptrs, this.document);
    }
    return docs;
  }
  get pointer() {
    return this.ptrs;
  }
  get methods() {
    return this.world.methods;
  }
  get model() {
    return this.world.model;
  }
  get hooks() {
    return this.world.hooks;
  }
  get isView() {
    return true;
  }
  get found() {
    return this.docs.length > 0;
  }
  get length() {
    return this.docs.length;
  }
  get fullPointer() {
    let { docs, ptrs, document: document2 } = this;
    let pointers = ptrs || docs.map((_d, n3) => [n3]);
    return pointers.map((a2) => {
      let [n3, start2, end2, id, endId] = a2;
      start2 = start2 || 0;
      end2 = end2 || (document2[n3] || []).length;
      if (document2[n3] && document2[n3][start2]) {
        id = id || document2[n3][start2].id;
        if (document2[n3][end2 - 1]) {
          endId = endId || document2[n3][end2 - 1].id;
        }
      }
      return [n3, start2, end2, id, endId];
    });
  }
  update(pointer) {
    let m3 = new View(this.document, pointer);
    if (this._cache && pointer && pointer.length > 0) {
      let cache2 = [];
      pointer.forEach((ptr, i3) => {
        let [n3, start2, end2] = ptr;
        if (ptr.length === 1) {
          cache2[i3] = this._cache[n3];
        } else if (start2 === 0 && this.document[n3].length === end2) {
          cache2[i3] = this._cache[n3];
        }
      });
      if (cache2.length > 0) {
        m3._cache = cache2;
      }
    }
    m3.world = this.world;
    return m3;
  }
  toView(pointer) {
    return new View(this.document, pointer || this.pointer);
  }
  fromText(input) {
    const { methods: methods16 } = this;
    let document2 = methods16.one.tokenize.fromString(input, this.world);
    let doc = new View(document2);
    doc.world = this.world;
    doc.compute(["normal", "lexicon"]);
    if (this.world.compute.preTagger) {
      doc.compute("preTagger");
    }
    return doc;
  }
  clone() {
    let document2 = this.document.slice(0);
    document2 = document2.map((terms) => {
      return terms.map((term) => {
        term = Object.assign({}, term);
        term.tags = new Set(term.tags);
        return term;
      });
    });
    let m3 = this.update(this.pointer);
    m3.document = document2;
    m3._cache = this._cache;
    return m3;
  }
};
Object.assign(View.prototype, methods_default);
var View_default = View;

// node_modules/compromise/src/_version.js
var version_default = "14.8.1";

// node_modules/compromise/src/API/extend.js
var isObject = function(item) {
  return item && typeof item === "object" && !Array.isArray(item);
};
function mergeDeep(model5, plugin5) {
  if (isObject(plugin5)) {
    for (const key in plugin5) {
      if (isObject(plugin5[key])) {
        if (!model5[key])
          Object.assign(model5, { [key]: {} });
        mergeDeep(model5[key], plugin5[key]);
      } else {
        Object.assign(model5, { [key]: plugin5[key] });
      }
    }
  }
  return model5;
}
function mergeQuick(model5, plugin5) {
  for (const key in plugin5) {
    model5[key] = model5[key] || {};
    Object.assign(model5[key], plugin5[key]);
  }
  return model5;
}
var addIrregulars = function(model5, conj) {
  let m3 = model5.two.models || {};
  Object.keys(conj).forEach((k2) => {
    if (conj[k2].pastTense) {
      if (m3.toPast) {
        m3.toPast.exceptions[k2] = conj[k2].pastTense;
      }
      if (m3.fromPast) {
        m3.fromPast.exceptions[conj[k2].pastTense] = k2;
      }
    }
    if (conj[k2].presentTense) {
      if (m3.toPresent) {
        m3.toPresent.exceptions[k2] = conj[k2].presentTense;
      }
      if (m3.fromPresent) {
        m3.fromPresent.exceptions[conj[k2].presentTense] = k2;
      }
    }
    if (conj[k2].gerund) {
      if (m3.toGerund) {
        m3.toGerund.exceptions[k2] = conj[k2].gerund;
      }
      if (m3.fromGerund) {
        m3.fromGerund.exceptions[conj[k2].gerund] = k2;
      }
    }
    if (conj[k2].comparative) {
      if (m3.toComparative) {
        m3.toComparative.exceptions[k2] = conj[k2].comparative;
      }
      if (m3.fromComparative) {
        m3.fromComparative.exceptions[conj[k2].comparative] = k2;
      }
    }
    if (conj[k2].superlative) {
      if (m3.toSuperlative) {
        m3.toSuperlative.exceptions[k2] = conj[k2].superlative;
      }
      if (m3.fromSuperlative) {
        m3.fromSuperlative.exceptions[conj[k2].superlative] = k2;
      }
    }
  });
};
var extend = function(plugin5, world2, View2, nlp2) {
  const { methods: methods16, model: model5, compute: compute4, hooks: hooks2 } = world2;
  if (plugin5.methods) {
    mergeQuick(methods16, plugin5.methods);
  }
  if (plugin5.model) {
    mergeDeep(model5, plugin5.model);
  }
  if (plugin5.irregulars) {
    addIrregulars(model5, plugin5.irregulars);
  }
  if (plugin5.compute) {
    Object.assign(compute4, plugin5.compute);
  }
  if (hooks2) {
    world2.hooks = hooks2.concat(plugin5.hooks || []);
  }
  if (plugin5.api) {
    plugin5.api(View2);
  }
  if (plugin5.lib) {
    Object.keys(plugin5.lib).forEach((k2) => nlp2[k2] = plugin5.lib[k2]);
  }
  if (plugin5.tags) {
    nlp2.addTags(plugin5.tags);
  }
  if (plugin5.words) {
    nlp2.addWords(plugin5.words);
  }
  if (plugin5.mutate) {
    plugin5.mutate(world2);
  }
};
var extend_default = extend;

// node_modules/compromise/src/API/_lib.js
var verbose = function(set) {
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  env2.DEBUG_TAGS = set === "tagger" || set === true ? true : "";
  env2.DEBUG_MATCH = set === "match" || set === true ? true : "";
  env2.DEBUG_CHUNKS = set === "chunker" || set === true ? true : "";
  return this;
};

// node_modules/compromise/src/API/inputs.js
var isObject2 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var isArray2 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var fromJson = function(json) {
  return json.map((o2) => {
    return o2.terms.map((term) => {
      if (isArray2(term.tags)) {
        term.tags = new Set(term.tags);
      }
      return term;
    });
  });
};
var preTokenized = function(arr) {
  return arr.map((a2) => {
    return a2.map((str) => {
      return {
        text: str,
        normal: str,
        pre: "",
        post: " ",
        tags: /* @__PURE__ */ new Set()
      };
    });
  });
};
var inputs = function(input, View2, world2) {
  const { methods: methods16 } = world2;
  let doc = new View2([]);
  doc.world = world2;
  if (typeof input === "number") {
    input = String(input);
  }
  if (!input) {
    return doc;
  }
  if (typeof input === "string") {
    let document2 = methods16.one.tokenize.fromString(input, world2);
    return new View2(document2);
  }
  if (isObject2(input) && input.isView) {
    return new View2(input.document, input.ptrs);
  }
  if (isArray2(input)) {
    if (isArray2(input[0])) {
      let document3 = preTokenized(input);
      return new View2(document3);
    }
    let document2 = fromJson(input);
    return new View2(document2);
  }
  return doc;
};
var inputs_default = inputs;

// node_modules/compromise/src/nlp.js
var world = Object.assign({}, world_default);
var nlp = function(input, lex) {
  if (lex) {
    nlp.addWords(lex);
  }
  let doc = inputs_default(input, View_default, world);
  if (input) {
    doc.compute(world.hooks);
  }
  return doc;
};
Object.defineProperty(nlp, "_world", {
  value: world,
  writable: true
});
nlp.tokenize = function(input, lex) {
  const { compute: compute4 } = this._world;
  if (lex) {
    nlp.addWords(lex);
  }
  let doc = inputs_default(input, View_default, world);
  if (compute4.contractions) {
    doc.compute(["alias", "normal", "machine", "contractions"]);
  }
  return doc;
};
nlp.plugin = function(plugin5) {
  extend_default(plugin5, this._world, View_default, this);
  return this;
};
nlp.extend = nlp.plugin;
nlp.world = function() {
  return this._world;
};
nlp.model = function() {
  return this._world.model;
};
nlp.methods = function() {
  return this._world.methods;
};
nlp.hooks = function() {
  return this._world.hooks;
};
nlp.verbose = verbose;
nlp.version = version_default;
var nlp_default = nlp;

// node_modules/compromise/src/1-one/cache/methods/cacheDoc.js
var createCache = function(document2) {
  let cache2 = document2.map((terms) => {
    let stuff = /* @__PURE__ */ new Set();
    terms.forEach((term) => {
      if (term.normal !== "") {
        stuff.add(term.normal);
      }
      if (term.switch) {
        stuff.add(`%${term.switch}%`);
      }
      if (term.implicit) {
        stuff.add(term.implicit);
      }
      if (term.machine) {
        stuff.add(term.machine);
      }
      if (term.root) {
        stuff.add(term.root);
      }
      if (term.alias) {
        term.alias.forEach((str) => stuff.add(str));
      }
      let tags = Array.from(term.tags);
      for (let t2 = 0; t2 < tags.length; t2 += 1) {
        stuff.add("#" + tags[t2]);
      }
    });
    return stuff;
  });
  return cache2;
};
var cacheDoc_default = createCache;

// node_modules/compromise/src/1-one/cache/methods/index.js
var methods_default2 = {
  one: {
    cacheDoc: cacheDoc_default
  }
};

// node_modules/compromise/src/1-one/cache/api.js
var methods3 = {
  cache: function() {
    this._cache = this.methods.one.cacheDoc(this.document);
    return this;
  },
  uncache: function() {
    this._cache = null;
    return this;
  }
};
var addAPI = function(View2) {
  Object.assign(View2.prototype, methods3);
};
var api_default = addAPI;

// node_modules/compromise/src/1-one/cache/compute.js
var compute_default2 = {
  cache: function(view) {
    view._cache = view.methods.one.cacheDoc(view.document);
  }
};

// node_modules/compromise/src/1-one/cache/plugin.js
var plugin_default = {
  api: api_default,
  compute: compute_default2,
  methods: methods_default2
};

// node_modules/compromise/src/1-one/change/api/case.js
var case_default = {
  toLowerCase: function() {
    this.termList().forEach((t2) => {
      t2.text = t2.text.toLowerCase();
    });
    return this;
  },
  toUpperCase: function() {
    this.termList().forEach((t2) => {
      t2.text = t2.text.toUpperCase();
    });
    return this;
  },
  toTitleCase: function() {
    this.termList().forEach((t2) => {
      t2.text = t2.text.replace(/^ *[a-z\u00C0-\u00FF]/, (x) => x.toUpperCase());
    });
    return this;
  },
  toCamelCase: function() {
    this.docs.forEach((terms) => {
      terms.forEach((t2, i3) => {
        if (i3 !== 0) {
          t2.text = t2.text.replace(/^ *[a-z\u00C0-\u00FF]/, (x) => x.toUpperCase());
        }
        if (i3 !== terms.length - 1) {
          t2.post = "";
        }
      });
    });
    return this;
  }
};

// node_modules/compromise/src/1-one/change/api/lib/insert.js
var isTitleCase = (str) => /^\p{Lu}[\p{Ll}'’]/u.test(str) || /^\p{Lu}$/u.test(str);
var toTitleCase = (str) => str.replace(/^\p{Ll}/u, (x) => x.toUpperCase());
var toLowerCase = (str) => str.replace(/^\p{Lu}/u, (x) => x.toLowerCase());
var spliceArr = (parent, index3, child) => {
  child.forEach((term) => term.dirty = true);
  if (parent) {
    let args = [index3, 0].concat(child);
    Array.prototype.splice.apply(parent, args);
  }
  return parent;
};
var endSpace = function(terms) {
  const hasSpace2 = / $/;
  const hasDash4 = /[-–—]/;
  let lastTerm = terms[terms.length - 1];
  if (lastTerm && !hasSpace2.test(lastTerm.post) && !hasDash4.test(lastTerm.post)) {
    lastTerm.post += " ";
  }
};
var movePunct = (source, end2, needle) => {
  const juicy = /[-.?!,;:)–—'"]/g;
  let wasLast = source[end2 - 1];
  if (!wasLast) {
    return;
  }
  let post = wasLast.post;
  if (juicy.test(post)) {
    let punct = post.match(juicy).join("");
    let last = needle[needle.length - 1];
    last.post = punct + last.post;
    wasLast.post = wasLast.post.replace(juicy, "");
  }
};
var moveTitleCase = function(home, start2, needle) {
  let from = home[start2];
  if (start2 !== 0 || !isTitleCase(from.text)) {
    return;
  }
  needle[0].text = toTitleCase(needle[0].text);
  let old = home[start2];
  if (old.tags.has("ProperNoun") || old.tags.has("Acronym")) {
    return;
  }
  if (isTitleCase(old.text) && old.text.length > 1) {
    old.text = toLowerCase(old.text);
  }
};
var cleanPrepend = function(home, ptr, needle, document2) {
  let [n3, start2, end2] = ptr;
  if (start2 === 0) {
    endSpace(needle);
  } else if (end2 === document2[n3].length) {
    endSpace(needle);
  } else {
    endSpace(needle);
    endSpace([home[ptr[1]]]);
  }
  moveTitleCase(home, start2, needle);
  spliceArr(home, start2, needle);
};
var cleanAppend = function(home, ptr, needle, document2) {
  let [n3, , end2] = ptr;
  let total = (document2[n3] || []).length;
  if (end2 < total) {
    movePunct(home, end2, needle);
    endSpace(needle);
  } else if (total === end2) {
    endSpace(home);
    movePunct(home, end2, needle);
    if (document2[n3 + 1]) {
      needle[needle.length - 1].post += " ";
    }
  }
  spliceArr(home, ptr[2], needle);
  ptr[4] = needle[needle.length - 1].id;
};

// node_modules/compromise/src/1-one/change/compute/uuid.js
var index = 0;
var pad3 = (str) => {
  str = str.length < 3 ? "0" + str : str;
  return str.length < 3 ? "0" + str : str;
};
var toId = function(term) {
  let [n3, i3] = term.index || [0, 0];
  index += 1;
  index = index > 46655 ? 0 : index;
  n3 = n3 > 46655 ? 0 : n3;
  i3 = i3 > 1294 ? 0 : i3;
  let id = pad3(index.toString(36));
  id += pad3(n3.toString(36));
  let tx = i3.toString(36);
  tx = tx.length < 2 ? "0" + tx : tx;
  id += tx;
  let r2 = parseInt(Math.random() * 36, 10);
  id += r2.toString(36);
  return term.normal + "|" + id.toUpperCase();
};
var uuid_default = toId;

// node_modules/compromise/src/1-one/change/api/insert.js
var expand = function(m3) {
  if (m3.has("@hasContraction") && typeof m3.contractions === "function") {
    let more = m3.grow("@hasContraction");
    more.contractions().expand();
  }
};
var isArray3 = (arr) => Object.prototype.toString.call(arr) === "[object Array]";
var addIds = function(terms) {
  terms = terms.map((term) => {
    term.id = uuid_default(term);
    return term;
  });
  return terms;
};
var getTerms = function(input, world2) {
  const { methods: methods16 } = world2;
  if (typeof input === "string") {
    return methods16.one.tokenize.fromString(input, world2)[0];
  }
  if (typeof input === "object" && input.isView) {
    return input.clone().docs[0] || [];
  }
  if (isArray3(input)) {
    return isArray3(input[0]) ? input[0] : input;
  }
  return [];
};
var insert = function(input, view, prepend) {
  const { document: document2, world: world2 } = view;
  view.uncache();
  let ptrs = view.fullPointer;
  let selfPtrs = view.fullPointer;
  view.forEach((m3, i3) => {
    let ptr = m3.fullPointer[0];
    let [n3] = ptr;
    let home = document2[n3];
    let terms = getTerms(input, world2);
    if (terms.length === 0) {
      return;
    }
    terms = addIds(terms);
    if (prepend) {
      expand(view.update([ptr]).firstTerm());
      cleanPrepend(home, ptr, terms, document2);
    } else {
      expand(view.update([ptr]).lastTerm());
      cleanAppend(home, ptr, terms, document2);
    }
    if (document2[n3] && document2[n3][ptr[1]]) {
      ptr[3] = document2[n3][ptr[1]].id;
    }
    selfPtrs[i3] = ptr;
    ptr[2] += terms.length;
    ptrs[i3] = ptr;
  });
  let doc = view.toView(ptrs);
  view.ptrs = selfPtrs;
  doc.compute(["id", "index", "lexicon"]);
  if (doc.world.compute.preTagger) {
    doc.compute("preTagger");
  }
  return doc;
};
var fns2 = {
  insertAfter: function(input) {
    return insert(input, this, false);
  },
  insertBefore: function(input) {
    return insert(input, this, true);
  }
};
fns2.append = fns2.insertAfter;
fns2.prepend = fns2.insertBefore;
fns2.insert = fns2.insertAfter;
var insert_default = fns2;

// node_modules/compromise/src/1-one/change/api/replace.js
var dollarStub = /\$[0-9a-z]+/g;
var fns3 = {};
var titleCase = function(str) {
  return str.replace(/\w\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase());
};
var replaceByFn = function(main, fn) {
  main.forEach((m3) => {
    let out2 = fn(m3);
    m3.replaceWith(out2);
  });
  return main;
};
var subDollarSign = function(input, main) {
  if (typeof input !== "string") {
    return input;
  }
  let groups = main.groups();
  input = input.replace(dollarStub, (a2) => {
    let num = a2.replace(/\$/, "");
    if (groups.hasOwnProperty(num)) {
      return groups[num].text();
    }
    return a2;
  });
  return input;
};
fns3.replaceWith = function(input, keep9 = {}) {
  let ptrs = this.fullPointer;
  let main = this;
  this.uncache();
  if (typeof input === "function") {
    return replaceByFn(main, input);
  }
  input = subDollarSign(input, main);
  let original = this.update(ptrs);
  ptrs = ptrs.map((ptr) => ptr.slice(0, 3));
  let oldTags = (original.docs[0] || []).map((term) => Array.from(term.tags));
  if (typeof input === "string") {
    input = this.fromText(input).compute("id");
  }
  main.insertAfter(input);
  if (original.has("@hasContraction") && main.contractions) {
    let more = main.grow("@hasContraction+");
    more.contractions().expand();
  }
  main.delete(original);
  let m3 = main.toView(ptrs).compute(["index", "lexicon"]);
  if (m3.world.compute.preTagger) {
    m3.compute("preTagger");
  }
  if (keep9.tags) {
    m3.terms().forEach((term, i3) => {
      term.tagSafe(oldTags[i3]);
    });
  }
  if (keep9.case && m3.docs[0] && m3.docs[0][0] && m3.docs[0][0].index[1] === 0) {
    m3.docs[0][0].text = titleCase(m3.docs[0][0].text);
  }
  return m3;
};
fns3.replace = function(match2, input, keep9) {
  if (match2 && !input) {
    return this.replaceWith(match2, keep9);
  }
  let m3 = this.match(match2);
  if (!m3.found) {
    return this;
  }
  this.soften();
  return m3.replaceWith(input, keep9);
};
var replace_default = fns3;

// node_modules/compromise/src/1-one/change/api/lib/remove.js
var repairPunct = function(terms, len) {
  let last = terms.length - 1;
  let from = terms[last];
  let to = terms[last - len];
  if (to && from) {
    to.post += from.post;
    to.post = to.post.replace(/ +([.?!,;:])/, "$1");
    to.post = to.post.replace(/[,;:]+([.?!])/, "$1");
  }
};
var pluckOut = function(document2, nots) {
  nots.forEach((ptr) => {
    let [n3, start2, end2] = ptr;
    let len = end2 - start2;
    if (!document2[n3]) {
      return;
    }
    if (end2 === document2[n3].length && end2 > 1) {
      repairPunct(document2[n3], len);
    }
    document2[n3].splice(start2, len);
  });
  for (let i3 = document2.length - 1; i3 >= 0; i3 -= 1) {
    if (document2[i3].length === 0) {
      document2.splice(i3, 1);
      if (i3 === document2.length && document2[i3 - 1]) {
        let terms = document2[i3 - 1];
        let lastTerm = terms[terms.length - 1];
        if (lastTerm) {
          lastTerm.post = lastTerm.post.trimEnd();
        }
      }
    }
  }
  return document2;
};
var remove_default = pluckOut;

// node_modules/compromise/src/1-one/change/api/remove.js
var fixPointers = function(ptrs, gonePtrs) {
  ptrs = ptrs.map((ptr) => {
    let [n3] = ptr;
    if (!gonePtrs[n3]) {
      return ptr;
    }
    gonePtrs[n3].forEach((no) => {
      let len = no[2] - no[1];
      if (ptr[1] <= no[1] && ptr[2] >= no[2]) {
        ptr[2] -= len;
      }
    });
    return ptr;
  });
  ptrs.forEach((ptr, i3) => {
    if (ptr[1] === 0 && ptr[2] == 0) {
      for (let n3 = i3 + 1; n3 < ptrs.length; n3 += 1) {
        ptrs[n3][0] -= 1;
        if (ptrs[n3][0] < 0) {
          ptrs[n3][0] = 0;
        }
      }
    }
  });
  ptrs = ptrs.filter((ptr) => ptr[2] - ptr[1] > 0);
  ptrs = ptrs.map((ptr) => {
    ptr[3] = null;
    ptr[4] = null;
    return ptr;
  });
  return ptrs;
};
var methods4 = {
  remove: function(reg) {
    const { indexN: indexN2 } = this.methods.one.pointer;
    this.uncache();
    let self2 = this.all();
    let not = this;
    if (reg) {
      self2 = this;
      not = this.match(reg);
    }
    let isFull = !self2.ptrs;
    if (not.has("@hasContraction") && not.contractions) {
      let more = not.grow("@hasContraction");
      more.contractions().expand();
    }
    let ptrs = self2.fullPointer;
    let nots = not.fullPointer.reverse();
    let document2 = remove_default(this.document, nots);
    let gonePtrs = indexN2(nots);
    ptrs = fixPointers(ptrs, gonePtrs);
    self2.ptrs = ptrs;
    self2.document = document2;
    self2.compute("index");
    if (isFull) {
      self2.ptrs = void 0;
    }
    if (!reg) {
      this.ptrs = [];
      return self2.none();
    }
    let res = self2.toView(ptrs);
    return res;
  }
};
methods4.delete = methods4.remove;
var remove_default2 = methods4;

// node_modules/compromise/src/1-one/change/api/whitespace.js
var methods5 = {
  pre: function(str, concat) {
    if (str === void 0 && this.found) {
      return this.docs[0][0].pre;
    }
    this.docs.forEach((terms) => {
      let term = terms[0];
      if (concat === true) {
        term.pre += str;
      } else {
        term.pre = str;
      }
    });
    return this;
  },
  post: function(str, concat) {
    if (str === void 0) {
      let last = this.docs[this.docs.length - 1];
      return last[last.length - 1].post;
    }
    this.docs.forEach((terms) => {
      let term = terms[terms.length - 1];
      if (concat === true) {
        term.post += str;
      } else {
        term.post = str;
      }
    });
    return this;
  },
  trim: function() {
    if (!this.found) {
      return this;
    }
    let docs = this.docs;
    let start2 = docs[0][0];
    start2.pre = start2.pre.trimStart();
    let last = docs[docs.length - 1];
    let end2 = last[last.length - 1];
    end2.post = end2.post.trimEnd();
    return this;
  },
  hyphenate: function() {
    this.docs.forEach((terms) => {
      terms.forEach((t2, i3) => {
        if (i3 !== 0) {
          t2.pre = "";
        }
        if (terms[i3 + 1]) {
          t2.post = "-";
        }
      });
    });
    return this;
  },
  dehyphenate: function() {
    const hasHyphen3 = /[-–—]/;
    this.docs.forEach((terms) => {
      terms.forEach((t2) => {
        if (hasHyphen3.test(t2.post)) {
          t2.post = " ";
        }
      });
    });
    return this;
  },
  toQuotations: function(start2, end2) {
    start2 = start2 || `"`;
    end2 = end2 || `"`;
    this.docs.forEach((terms) => {
      terms[0].pre = start2 + terms[0].pre;
      let last = terms[terms.length - 1];
      last.post = end2 + last.post;
    });
    return this;
  },
  toParentheses: function(start2, end2) {
    start2 = start2 || `(`;
    end2 = end2 || `)`;
    this.docs.forEach((terms) => {
      terms[0].pre = start2 + terms[0].pre;
      let last = terms[terms.length - 1];
      last.post = end2 + last.post;
    });
    return this;
  }
};
methods5.deHyphenate = methods5.dehyphenate;
methods5.toQuotation = methods5.toQuotations;
var whitespace_default = methods5;

// node_modules/compromise/src/1-one/change/api/lib/_sort.js
var alpha = (a2, b) => {
  if (a2.normal < b.normal) {
    return -1;
  }
  if (a2.normal > b.normal) {
    return 1;
  }
  return 0;
};
var length = (a2, b) => {
  let left = a2.normal.trim().length;
  let right = b.normal.trim().length;
  if (left < right) {
    return 1;
  }
  if (left > right) {
    return -1;
  }
  return 0;
};
var wordCount = (a2, b) => {
  if (a2.words < b.words) {
    return 1;
  }
  if (a2.words > b.words) {
    return -1;
  }
  return 0;
};
var sequential = (a2, b) => {
  if (a2[0] < b[0]) {
    return 1;
  }
  if (a2[0] > b[0]) {
    return -1;
  }
  return a2[1] > b[1] ? 1 : -1;
};
var byFreq = function(arr) {
  let counts = {};
  arr.forEach((o2) => {
    counts[o2.normal] = counts[o2.normal] || 0;
    counts[o2.normal] += 1;
  });
  arr.sort((a2, b) => {
    let left = counts[a2.normal];
    let right = counts[b.normal];
    if (left < right) {
      return 1;
    }
    if (left > right) {
      return -1;
    }
    return 0;
  });
  return arr;
};
var sort_default = { alpha, length, wordCount, sequential, byFreq };

// node_modules/compromise/src/1-one/change/api/sort.js
var seqNames = /* @__PURE__ */ new Set(["index", "sequence", "seq", "sequential", "chron", "chronological"]);
var freqNames = /* @__PURE__ */ new Set(["freq", "frequency", "topk", "repeats"]);
var alphaNames = /* @__PURE__ */ new Set(["alpha", "alphabetical"]);
var customSort = function(view, fn) {
  let ptrs = view.fullPointer;
  ptrs = ptrs.sort((a2, b) => {
    a2 = view.update([a2]);
    b = view.update([b]);
    return fn(a2, b);
  });
  view.ptrs = ptrs;
  return view;
};
var sort = function(input) {
  let { docs, pointer } = this;
  this.uncache();
  if (typeof input === "function") {
    return customSort(this, input);
  }
  input = input || "alpha";
  let ptrs = pointer || docs.map((_d, n3) => [n3]);
  let arr = docs.map((terms, n3) => {
    return {
      index: n3,
      words: terms.length,
      normal: terms.map((t2) => t2.machine || t2.normal || "").join(" "),
      pointer: ptrs[n3]
    };
  });
  if (seqNames.has(input)) {
    input = "sequential";
  }
  if (alphaNames.has(input)) {
    input = "alpha";
  }
  if (freqNames.has(input)) {
    arr = sort_default.byFreq(arr);
    return this.update(arr.map((o2) => o2.pointer));
  }
  if (typeof sort_default[input] === "function") {
    arr = arr.sort(sort_default[input]);
    return this.update(arr.map((o2) => o2.pointer));
  }
  return this;
};
var reverse = function() {
  let ptrs = this.pointer || this.docs.map((_d, n3) => [n3]);
  ptrs = [].concat(ptrs);
  ptrs = ptrs.reverse();
  if (this._cache) {
    this._cache = this._cache.reverse();
  }
  return this.update(ptrs);
};
var unique = function() {
  let already = /* @__PURE__ */ new Set();
  let res = this.filter((m3) => {
    let txt = m3.text("machine");
    if (already.has(txt)) {
      return false;
    }
    already.add(txt);
    return true;
  });
  return res;
};
var sort_default2 = { unique, reverse, sort };

// node_modules/compromise/src/1-one/change/api/concat.js
var isArray4 = (arr) => Object.prototype.toString.call(arr) === "[object Array]";
var combineDocs = function(homeDocs, inputDocs) {
  if (homeDocs.length > 0) {
    let end2 = homeDocs[homeDocs.length - 1];
    let last = end2[end2.length - 1];
    if (/ /.test(last.post) === false) {
      last.post += " ";
    }
  }
  homeDocs = homeDocs.concat(inputDocs);
  return homeDocs;
};
var combineViews = function(home, input) {
  if (home.document === input.document) {
    let ptrs2 = home.fullPointer.concat(input.fullPointer);
    return home.toView(ptrs2).compute("index");
  }
  let ptrs = input.fullPointer;
  ptrs.forEach((a2) => {
    a2[0] += home.document.length;
  });
  home.document = combineDocs(home.document, input.docs);
  return home.all();
};
var concat_default = {
  concat: function(input) {
    if (typeof input === "string") {
      let more = this.fromText(input);
      if (!this.found || !this.ptrs) {
        this.document = this.document.concat(more.document);
      } else {
        let ptrs = this.fullPointer;
        let at = ptrs[ptrs.length - 1][0];
        this.document.splice(at, 0, ...more.document);
      }
      return this.all().compute("index");
    }
    if (typeof input === "object" && input.isView) {
      return combineViews(this, input);
    }
    if (isArray4(input)) {
      let docs = combineDocs(this.document, input);
      this.document = docs;
      return this.all();
    }
    return this;
  }
};

// node_modules/compromise/src/1-one/change/api/harden.js
var harden = function() {
  this.ptrs = this.fullPointer;
  return this;
};
var soften = function() {
  let ptr = this.ptrs;
  if (!ptr || ptr.length < 1) {
    return this;
  }
  ptr = ptr.map((a2) => a2.slice(0, 3));
  this.ptrs = ptr;
  return this;
};
var harden_default = { harden, soften };

// node_modules/compromise/src/1-one/change/api/index.js
var methods6 = Object.assign({}, case_default, insert_default, replace_default, remove_default2, whitespace_default, sort_default2, concat_default, harden_default);
var addAPI2 = function(View2) {
  Object.assign(View2.prototype, methods6);
};
var api_default2 = addAPI2;

// node_modules/compromise/src/1-one/change/compute/index.js
var compute2 = {
  id: function(view) {
    let docs = view.docs;
    for (let n3 = 0; n3 < docs.length; n3 += 1) {
      for (let i3 = 0; i3 < docs[n3].length; i3 += 1) {
        let term = docs[n3][i3];
        term.id = term.id || uuid_default(term);
      }
    }
  }
};
var compute_default3 = compute2;

// node_modules/compromise/src/1-one/change/plugin.js
var plugin_default2 = {
  api: api_default2,
  compute: compute_default3
};

// node_modules/compromise/src/1-one/contraction-one/model/contractions.js
var contractions_default = [
  { word: "@", out: ["at"] },
  { word: "alot", out: ["a", "lot"] },
  { word: "brb", out: ["be", "right", "back"] },
  { word: "cannot", out: ["can", "not"] },
  { word: "cant", out: ["can", "not"] },
  { word: "dont", out: ["do", "not"] },
  { word: "dun", out: ["do", "not"] },
  { word: "wont", out: ["will", "not"] },
  { word: "can't", out: ["can", "not"] },
  { word: "shan't", out: ["should", "not"] },
  { word: "won't", out: ["will", "not"] },
  { word: "that's", out: ["that", "is"] },
  { word: "what's", out: ["what", "is"] },
  { word: "let's", out: ["let", "us"] },
  { word: "there's", out: ["there", "is"] },
  { word: "dunno", out: ["do", "not", "know"] },
  { word: "gonna", out: ["going", "to"] },
  { word: "gotta", out: ["have", "got", "to"] },
  { word: "gimme", out: ["give", "me"] },
  { word: "tryna", out: ["trying", "to"] },
  { word: "gtg", out: ["got", "to", "go"] },
  { word: "im", out: ["i", "am"] },
  { word: "imma", out: ["I", "will"] },
  { word: "imo", out: ["in", "my", "opinion"] },
  { word: "irl", out: ["in", "real", "life"] },
  { word: "ive", out: ["i", "have"] },
  { word: "rn", out: ["right", "now"] },
  { word: "tbh", out: ["to", "be", "honest"] },
  { word: "wanna", out: ["want", "to"] },
  { word: `c'mere`, out: ["come", "here"] },
  { word: `c'mon`, out: ["come", "on"] },
  { word: "howd", out: ["how", "did"] },
  { word: "whatd", out: ["what", "did"] },
  { word: "whend", out: ["when", "did"] },
  { word: "whered", out: ["where", "did"] },
  { word: "shoulda", out: ["should", "have"] },
  { word: "coulda", out: ["coulda", "have"] },
  { word: "woulda", out: ["woulda", "have"] },
  { word: "musta", out: ["must", "have"] },
  { word: "tis", out: ["it", "is"] },
  { word: "twas", out: ["it", "was"] },
  { word: `y'know`, out: ["you", "know"] },
  { word: "ne'er", out: ["never"] },
  { word: "o'er", out: ["over"] },
  { after: "ll", out: ["will"] },
  { after: "ve", out: ["have"] },
  { after: "re", out: ["are"] },
  { after: "m", out: ["am"] },
  { before: "c", out: ["ce"] },
  { before: "m", out: ["me"] },
  { before: "n", out: ["ne"] },
  { before: "qu", out: ["que"] },
  { before: "s", out: ["se"] },
  { before: "t", out: ["tu"] }
];

// node_modules/compromise/src/1-one/contraction-one/model/index.js
var model_default = { one: { contractions: contractions_default } };

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/_splice.js
var insertContraction = function(document2, point, words) {
  let [n3, w] = point;
  if (!words || words.length === 0) {
    return;
  }
  words = words.map((word, i3) => {
    word.implicit = word.text;
    word.machine = word.text;
    word.pre = "";
    word.post = "";
    word.text = "";
    word.normal = "";
    word.index = [n3, w + i3];
    return word;
  });
  if (words[0]) {
    words[0].pre = document2[n3][w].pre;
    words[words.length - 1].post = document2[n3][w].post;
    words[0].text = document2[n3][w].text;
    words[0].normal = document2[n3][w].normal;
  }
  document2[n3].splice(w, 1, ...words);
};
var splice_default = insertContraction;

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/apostrophe-d.js
var hasContraction = /'/;
var alwaysDid = /* @__PURE__ */ new Set([
  "what",
  "how",
  "when",
  "where",
  "why"
]);
var useWould = /* @__PURE__ */ new Set([
  "be",
  "go",
  "start",
  "think",
  "need"
]);
var useHad = /* @__PURE__ */ new Set([
  "been",
  "gone"
]);
var _apostropheD = function(terms, i3) {
  let before2 = terms[i3].normal.split(hasContraction)[0];
  if (alwaysDid.has(before2)) {
    return [before2, "did"];
  }
  if (terms[i3 + 1]) {
    if (useHad.has(terms[i3 + 1].normal)) {
      return [before2, "had"];
    }
    if (useWould.has(terms[i3 + 1].normal)) {
      return [before2, "would"];
    }
  }
  return null;
};
var apostrophe_d_default = _apostropheD;

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/apostrophe-t.js
var apostropheT = function(terms, i3) {
  if (terms[i3].normal === "ain't" || terms[i3].normal === "aint") {
    return null;
  }
  let before2 = terms[i3].normal.replace(/n't/, "");
  return [before2, "not"];
};
var apostrophe_t_default = apostropheT;

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/french.js
var hasContraction2 = /'/;
var preL = (terms, i3) => {
  let after2 = terms[i3].normal.split(hasContraction2)[1];
  if (after2 && after2.endsWith("e")) {
    return ["la", after2];
  }
  return ["le", after2];
};
var preD = (terms, i3) => {
  let after2 = terms[i3].normal.split(hasContraction2)[1];
  if (after2 && after2.endsWith("e")) {
    return ["du", after2];
  } else if (after2 && after2.endsWith("s")) {
    return ["des", after2];
  }
  return ["de", after2];
};
var preJ = (terms, i3) => {
  let after2 = terms[i3].normal.split(hasContraction2)[1];
  return ["je", after2];
};
var french_default = {
  preJ,
  preL,
  preD
};

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/number-range.js
var isRange = /^([0-9.]{1,4}[a-z]{0,2}) ?[-–—] ?([0-9]{1,4}[a-z]{0,2})$/i;
var timeRange = /^([0-9]{1,2}(:[0-9][0-9])?(am|pm)?) ?[-–—] ?([0-9]{1,2}(:[0-9][0-9])?(am|pm)?)$/i;
var phoneNum = /^[0-9]{3}-[0-9]{4}$/;
var numberRange = function(terms, i3) {
  let term = terms[i3];
  let parts = term.text.match(isRange);
  if (parts !== null) {
    if (term.tags.has("PhoneNumber") === true || phoneNum.test(term.text)) {
      return null;
    }
    return [parts[1], "to", parts[2]];
  } else {
    parts = term.text.match(timeRange);
    if (parts !== null) {
      return [parts[1], "to", parts[4]];
    }
  }
  return null;
};
var number_range_default = numberRange;

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/number-unit.js
var numUnit = /^([+-]?[0-9][.,0-9]*)([a-z°²³µ/]+)$/;
var notUnit = /* @__PURE__ */ new Set([
  "st",
  "nd",
  "rd",
  "th",
  "am",
  "pm",
  "max",
  "\xB0",
  "s",
  "e"
]);
var numberUnit = function(terms, i3) {
  let term = terms[i3];
  let parts = term.text.match(numUnit);
  if (parts !== null) {
    let unit = parts[2].toLowerCase().trim();
    if (notUnit.has(unit)) {
      return null;
    }
    return [parts[1], unit];
  }
  return null;
};
var number_unit_default = numberUnit;

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/index.js
var byApostrophe = /'/;
var numDash = /^[0-9][^-–—]*[-–—].*?[0-9]/;
var reTag = function(terms, view, start2, len) {
  let tmp = view.update();
  tmp.document = [terms];
  let end2 = start2 + len;
  if (start2 > 0) {
    start2 -= 1;
  }
  if (terms[end2]) {
    end2 += 1;
  }
  tmp.ptrs = [[0, start2, end2]];
};
var byEnd = {
  t: (terms, i3) => apostrophe_t_default(terms, i3),
  d: (terms, i3) => apostrophe_d_default(terms, i3)
};
var byStart = {
  j: (terms, i3) => french_default.preJ(terms, i3),
  l: (terms, i3) => french_default.preL(terms, i3),
  d: (terms, i3) => french_default.preD(terms, i3)
};
var knownOnes = function(list4, term, before2, after2) {
  for (let i3 = 0; i3 < list4.length; i3 += 1) {
    let o2 = list4[i3];
    if (o2.word === term.normal) {
      return o2.out;
    } else if (after2 !== null && after2 === o2.after) {
      return [before2].concat(o2.out);
    } else if (before2 !== null && before2 === o2.before) {
      return o2.out.concat(after2);
    }
  }
  return null;
};
var toDocs = function(words, view) {
  let doc = view.fromText(words.join(" "));
  doc.compute(["id", "alias"]);
  return doc.docs[0];
};
var contractions = (view) => {
  let { world: world2, document: document2 } = view;
  const { model: model5, methods: methods16 } = world2;
  let list4 = model5.one.contractions || [];
  let units = new Set(model5.one.units || []);
  document2.forEach((terms, n3) => {
    for (let i3 = terms.length - 1; i3 >= 0; i3 -= 1) {
      let before2 = null;
      let after2 = null;
      if (byApostrophe.test(terms[i3].normal) === true) {
        [before2, after2] = terms[i3].normal.split(byApostrophe);
      }
      let words = knownOnes(list4, terms[i3], before2, after2);
      if (!words && byEnd.hasOwnProperty(after2)) {
        words = byEnd[after2](terms, i3, world2);
      }
      if (!words && byStart.hasOwnProperty(before2)) {
        words = byStart[before2](terms, i3);
      }
      if (words) {
        words = toDocs(words, view);
        splice_default(document2, [n3, i3], words);
        reTag(document2[n3], view, i3, words.length);
        continue;
      }
      if (numDash.test(terms[i3].normal)) {
        words = number_range_default(terms, i3);
        if (words) {
          words = toDocs(words, view);
          splice_default(document2, [n3, i3], words);
          methods16.one.setTag(words, "NumberRange", world2);
          if (words[2] && words[2].tags.has("Time")) {
            methods16.one.setTag([words[0]], "Time", world2, null, "time-range");
          }
          reTag(document2[n3], view, i3, words.length);
        }
        continue;
      }
      words = number_unit_default(terms, i3, units);
      if (words) {
        words = toDocs(words, view);
        splice_default(document2, [n3, i3], words);
        methods16.one.setTag([words[1]], "Unit", world2, null, "contraction-unit");
      }
    }
  });
};
var contractions_default2 = contractions;

// node_modules/compromise/src/1-one/contraction-one/compute/index.js
var compute_default4 = { contractions: contractions_default2 };

// node_modules/compromise/src/1-one/contraction-one/plugin.js
var plugin = {
  model: model_default,
  compute: compute_default4,
  hooks: ["contractions"]
};
var plugin_default3 = plugin;

// node_modules/compromise/src/1-one/lexicon/compute/multi-word.js
var checkMulti = function(terms, i3, lexicon4, setTag3, world2) {
  let max3 = i3 + 4 > terms.length ? terms.length - i3 : 4;
  let str = terms[i3].machine || terms[i3].normal;
  for (let skip = 1; skip < max3; skip += 1) {
    let t2 = terms[i3 + skip];
    let word = t2.machine || t2.normal;
    str += " " + word;
    if (lexicon4.hasOwnProperty(str) === true) {
      let tag = lexicon4[str];
      let ts = terms.slice(i3, i3 + skip + 1);
      setTag3(ts, tag, world2, false, "1-multi-lexicon");
      if (tag && tag.length === 2 && (tag[0] === "PhrasalVerb" || tag[1] === "PhrasalVerb")) {
        setTag3([ts[1]], "Particle", world2, false, "1-phrasal-particle");
      }
      return true;
    }
  }
  return false;
};
var multiWord = function(terms, i3, world2) {
  const { model: model5, methods: methods16 } = world2;
  const setTag3 = methods16.one.setTag;
  const multi = model5.one._multiCache || {};
  const lexicon4 = model5.one.lexicon || {};
  let t2 = terms[i3];
  let word = t2.machine || t2.normal;
  if (terms[i3 + 1] !== void 0 && multi[word] === true) {
    return checkMulti(terms, i3, lexicon4, setTag3, world2);
  }
  return null;
};
var multi_word_default = multiWord;

// node_modules/compromise/src/1-one/lexicon/compute/single-word.js
var prefix = /^(under|over|mis|re|un|dis|semi|pre|post)-?/;
var allowPrefix = /* @__PURE__ */ new Set(["Verb", "Infinitive", "PastTense", "Gerund", "PresentTense", "Adjective", "Participle"]);
var checkLexicon = function(terms, i3, world2) {
  const { model: model5, methods: methods16 } = world2;
  const setTag3 = methods16.one.setTag;
  const lexicon4 = model5.one.lexicon;
  let t2 = terms[i3];
  let word = t2.machine || t2.normal;
  if (lexicon4[word] !== void 0 && lexicon4.hasOwnProperty(word)) {
    let tag = lexicon4[word];
    setTag3([t2], tag, world2, false, "1-lexicon");
    return true;
  }
  if (t2.alias) {
    let found = t2.alias.find((str) => lexicon4.hasOwnProperty(str));
    if (found) {
      let tag = lexicon4[found];
      setTag3([t2], tag, world2, false, "1-lexicon-alias");
      return true;
    }
  }
  if (prefix.test(word) === true) {
    let stem = word.replace(prefix, "");
    if (lexicon4.hasOwnProperty(stem) && stem.length > 3) {
      if (allowPrefix.has(lexicon4[stem])) {
        setTag3([t2], lexicon4[stem], world2, false, "1-lexicon-prefix");
        return true;
      }
    }
  }
  return null;
};
var single_word_default = checkLexicon;

// node_modules/compromise/src/1-one/lexicon/compute/index.js
var lexicon = function(view) {
  const world2 = view.world;
  view.docs.forEach((terms) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      if (terms[i3].tags.size === 0) {
        let found = null;
        found = found || multi_word_default(terms, i3, world2);
        found = found || single_word_default(terms, i3, world2);
      }
    }
  });
};
var compute_default5 = {
  lexicon
};

// node_modules/compromise/src/1-one/lexicon/methods/expand.js
var expand2 = function(words) {
  let lex = {};
  let _multi = {};
  Object.keys(words).forEach((word) => {
    let tag = words[word];
    word = word.toLowerCase().trim();
    word = word.replace(/'s\b/, "");
    let split3 = word.split(/ /);
    if (split3.length > 1) {
      _multi[split3[0]] = true;
    }
    lex[word] = lex[word] || tag;
  });
  delete lex[""];
  delete lex[null];
  delete lex[" "];
  return { lex, _multi };
};
var expand_default = expand2;

// node_modules/compromise/src/1-one/lexicon/methods/index.js
var methods_default3 = {
  one: {
    expandLexicon: expand_default
  }
};

// node_modules/compromise/src/1-one/lexicon/lib.js
var addWords = function(words) {
  const world2 = this.world();
  const { methods: methods16, model: model5 } = world2;
  if (!words) {
    return;
  }
  Object.keys(words).forEach((k2) => {
    if (typeof words[k2] === "string" && words[k2].startsWith("#")) {
      words[k2] = words[k2].replace(/^#/, "");
    }
  });
  if (methods16.two.expandLexicon) {
    let { lex, _multi } = methods16.two.expandLexicon(words, world2);
    Object.assign(model5.one.lexicon, lex);
    Object.assign(model5.one._multiCache, _multi);
  } else if (methods16.one.expandLexicon) {
    let { lex, _multi } = methods16.one.expandLexicon(words, world2);
    Object.assign(model5.one.lexicon, lex);
    Object.assign(model5.one._multiCache, _multi);
  } else {
    Object.assign(model5.one.lexicon, words);
  }
};
var lib_default = { addWords };

// node_modules/compromise/src/1-one/lexicon/plugin.js
var model2 = {
  one: {
    lexicon: {},
    _multiCache: {}
  }
};
var plugin_default4 = {
  model: model2,
  methods: methods_default3,
  compute: compute_default5,
  lib: lib_default,
  hooks: ["lexicon"]
};

// node_modules/compromise/src/1-one/lookup/api/buildTrie/index.js
var tokenize = function(phrase, world2) {
  const { methods: methods16, model: model5 } = world2;
  let terms = methods16.one.tokenize.splitTerms(phrase, model5).map((t2) => methods16.one.tokenize.splitWhitespace(t2, model5));
  return terms.map((term) => term.text.toLowerCase());
};
var buildTrie = function(phrases, world2) {
  let goNext = [{}];
  let endAs = [null];
  let failTo = [0];
  let xs = [];
  let n3 = 0;
  phrases.forEach(function(phrase) {
    let curr = 0;
    let words = tokenize(phrase, world2);
    for (let i3 = 0; i3 < words.length; i3++) {
      let word = words[i3];
      if (goNext[curr] && goNext[curr].hasOwnProperty(word)) {
        curr = goNext[curr][word];
      } else {
        n3++;
        goNext[curr][word] = n3;
        goNext[n3] = {};
        curr = n3;
        endAs[n3] = null;
      }
    }
    endAs[curr] = [words.length];
  });
  for (let word in goNext[0]) {
    n3 = goNext[0][word];
    failTo[n3] = 0;
    xs.push(n3);
  }
  while (xs.length) {
    let r2 = xs.shift();
    let keys = Object.keys(goNext[r2]);
    for (let i3 = 0; i3 < keys.length; i3 += 1) {
      let word = keys[i3];
      let s3 = goNext[r2][word];
      xs.push(s3);
      n3 = failTo[r2];
      while (n3 > 0 && !goNext[n3].hasOwnProperty(word)) {
        n3 = failTo[n3];
      }
      if (goNext.hasOwnProperty(n3)) {
        let fs = goNext[n3][word];
        failTo[s3] = fs;
        if (endAs[fs]) {
          endAs[s3] = endAs[s3] || [];
          endAs[s3] = endAs[s3].concat(endAs[fs]);
        }
      } else {
        failTo[s3] = 0;
      }
    }
  }
  return { goNext, endAs, failTo };
};
var buildTrie_default = buildTrie;

// node_modules/compromise/src/1-one/lookup/api/scan.js
var scanWords = function(terms, trie, opts2) {
  let n3 = 0;
  let results = [];
  for (let i3 = 0; i3 < terms.length; i3++) {
    let word = terms[i3][opts2.form] || terms[i3].normal;
    while (n3 > 0 && (trie.goNext[n3] === void 0 || !trie.goNext[n3].hasOwnProperty(word))) {
      n3 = trie.failTo[n3] || 0;
    }
    if (!trie.goNext[n3].hasOwnProperty(word)) {
      continue;
    }
    n3 = trie.goNext[n3][word];
    if (trie.endAs[n3]) {
      let arr = trie.endAs[n3];
      for (let o2 = 0; o2 < arr.length; o2++) {
        let len = arr[o2];
        let term = terms[i3 - len + 1];
        let [no, start2] = term.index;
        results.push([no, start2, start2 + len, term.id]);
      }
    }
  }
  return results;
};
var cacheMiss = function(words, cache2) {
  for (let i3 = 0; i3 < words.length; i3 += 1) {
    if (cache2.has(words[i3]) === true) {
      return false;
    }
  }
  return true;
};
var scan = function(view, trie, opts2) {
  let results = [];
  opts2.form = opts2.form || "normal";
  let docs = view.docs;
  if (!trie.goNext || !trie.goNext[0]) {
    console.error("Compromise invalid lookup trie");
    return view.none();
  }
  let firstWords = Object.keys(trie.goNext[0]);
  for (let i3 = 0; i3 < docs.length; i3++) {
    if (view._cache && view._cache[i3] && cacheMiss(firstWords, view._cache[i3]) === true) {
      continue;
    }
    let terms = docs[i3];
    let found = scanWords(terms, trie, opts2);
    if (found.length > 0) {
      results = results.concat(found);
    }
  }
  return view.update(results);
};
var scan_default = scan;

// node_modules/compromise/src/1-one/lookup/api/index.js
var isObject3 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
function api_default3(View2) {
  View2.prototype.lookup = function(input, opts2 = {}) {
    if (!input) {
      return this.none();
    }
    if (typeof input === "string") {
      input = [input];
    }
    let trie = isObject3(input) ? input : buildTrie_default(input, this.world);
    let res = scan_default(this, trie, opts2);
    res = res.settle();
    return res;
  };
}

// node_modules/compromise/src/1-one/lookup/api/buildTrie/compress.js
var truncate = (list4, val) => {
  for (let i3 = list4.length - 1; i3 >= 0; i3 -= 1) {
    if (list4[i3] !== val) {
      list4 = list4.slice(0, i3 + 1);
      return list4;
    }
  }
  return list4;
};
var compress = function(trie) {
  trie.goNext = trie.goNext.map((o2) => {
    if (Object.keys(o2).length === 0) {
      return void 0;
    }
    return o2;
  });
  trie.goNext = truncate(trie.goNext, void 0);
  trie.failTo = truncate(trie.failTo, 0);
  trie.endAs = truncate(trie.endAs, null);
  return trie;
};
var compress_default = compress;

// node_modules/compromise/src/1-one/lookup/plugin.js
var lib = {
  buildTrie: function(input) {
    const trie = buildTrie_default(input, this.world());
    return compress_default(trie);
  }
};
lib.compile = lib.buildTrie;
var plugin_default5 = {
  api: api_default3,
  lib
};

// node_modules/compromise/src/1-one/match/api/_lib.js
var relPointer = function(ptrs, parent) {
  if (!parent) {
    return ptrs;
  }
  ptrs.forEach((ptr) => {
    let n3 = ptr[0];
    if (parent[n3]) {
      ptr[0] = parent[n3][0];
      ptr[1] += parent[n3][1];
      ptr[2] += parent[n3][1];
    }
  });
  return ptrs;
};
var fixPointers2 = function(res, parent) {
  let { ptrs, byGroup } = res;
  ptrs = relPointer(ptrs, parent);
  Object.keys(byGroup).forEach((k2) => {
    byGroup[k2] = relPointer(byGroup[k2], parent);
  });
  return { ptrs, byGroup };
};
var isObject4 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var isView = (val) => val && isObject4(val) && val.isView === true;
var isNet = (val) => val && isObject4(val) && val.isNet === true;

// node_modules/compromise/src/1-one/match/api/match.js
var parseRegs = function(regs, opts2, world2) {
  const one = world2.methods.one;
  if (typeof regs === "number") {
    regs = String(regs);
  }
  if (typeof regs === "string") {
    regs = one.killUnicode(regs, world2);
    regs = one.parseMatch(regs, opts2, world2);
  }
  return regs;
};
var match = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    return this.intersection(regs);
  }
  if (isNet(regs)) {
    return this.sweep(regs, { tagger: false }).view.settle();
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group };
  let res = one.match(this.docs, todo, this._cache);
  let { ptrs, byGroup } = fixPointers2(res, this.fullPointer);
  let view = this.toView(ptrs);
  view._groups = byGroup;
  return view;
};
var matchOne = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    return this.intersection(regs).eq(0);
  }
  if (isNet(regs)) {
    return this.sweep(regs, { tagger: false, matchOne: true }).view;
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group, justOne: true };
  let res = one.match(this.docs, todo, this._cache);
  let { ptrs, byGroup } = fixPointers2(res, this.fullPointer);
  let view = this.toView(ptrs);
  view._groups = byGroup;
  return view;
};
var has = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    let ptrs2 = regs.fullPointer;
    return ptrs2.length > 0;
  }
  if (isNet(regs)) {
    return this.sweep(regs, { tagger: false }).view.found;
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group, justOne: true };
  let ptrs = one.match(this.docs, todo, this._cache).ptrs;
  return ptrs.length > 0;
};
var ifFn = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    return this.filter((m3) => m3.intersection(regs).found);
  }
  if (isNet(regs)) {
    let m3 = this.sweep(regs, { tagger: false }).view.settle();
    return this.if(m3);
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group, justOne: true };
  let ptrs = this.fullPointer;
  let cache2 = this._cache || [];
  ptrs = ptrs.filter((ptr, i3) => {
    let m3 = this.update([ptr]);
    let res = one.match(m3.docs, todo, cache2[i3]).ptrs;
    return res.length > 0;
  });
  let view = this.update(ptrs);
  if (this._cache) {
    view._cache = ptrs.map((ptr) => cache2[ptr[0]]);
  }
  return view;
};
var ifNo = function(regs, group, opts2) {
  const { methods: methods16 } = this;
  const one = methods16.one;
  if (isView(regs)) {
    return this.filter((m3) => !m3.intersection(regs).found);
  }
  if (isNet(regs)) {
    let m3 = this.sweep(regs, { tagger: false }).view.settle();
    return this.ifNo(m3);
  }
  regs = parseRegs(regs, opts2, this.world);
  let cache2 = this._cache || [];
  let view = this.filter((m3, i3) => {
    let todo = { regs, group, justOne: true };
    let ptrs = one.match(m3.docs, todo, cache2[i3]).ptrs;
    return ptrs.length === 0;
  });
  if (this._cache) {
    view._cache = view.ptrs.map((ptr) => cache2[ptr[0]]);
  }
  return view;
};
var match_default = { matchOne, match, has, if: ifFn, ifNo };

// node_modules/compromise/src/1-one/match/api/lookaround.js
var before = function(regs, group, opts2) {
  const { indexN: indexN2 } = this.methods.one.pointer;
  let pre = [];
  let byN = indexN2(this.fullPointer);
  Object.keys(byN).forEach((k2) => {
    let first = byN[k2].sort((a2, b) => a2[1] > b[1] ? 1 : -1)[0];
    if (first[1] > 0) {
      pre.push([first[0], 0, first[1]]);
    }
  });
  let preWords = this.toView(pre);
  if (!regs) {
    return preWords;
  }
  return preWords.match(regs, group, opts2);
};
var after = function(regs, group, opts2) {
  const { indexN: indexN2 } = this.methods.one.pointer;
  let post = [];
  let byN = indexN2(this.fullPointer);
  let document2 = this.document;
  Object.keys(byN).forEach((k2) => {
    let last = byN[k2].sort((a2, b) => a2[1] > b[1] ? -1 : 1)[0];
    let [n3, , end2] = last;
    if (end2 < document2[n3].length) {
      post.push([n3, end2, document2[n3].length]);
    }
  });
  let postWords = this.toView(post);
  if (!regs) {
    return postWords;
  }
  return postWords.match(regs, group, opts2);
};
var growLeft = function(regs, group, opts2) {
  if (typeof regs === "string") {
    regs = this.world.methods.one.parseMatch(regs, opts2, this.world);
  }
  regs[regs.length - 1].end = true;
  let ptrs = this.fullPointer;
  this.forEach((m3, n3) => {
    let more = m3.before(regs, group);
    if (more.found) {
      let terms = more.terms();
      ptrs[n3][1] -= terms.length;
      ptrs[n3][3] = terms.docs[0][0].id;
    }
  });
  return this.update(ptrs);
};
var growRight = function(regs, group, opts2) {
  if (typeof regs === "string") {
    regs = this.world.methods.one.parseMatch(regs, opts2, this.world);
  }
  regs[0].start = true;
  let ptrs = this.fullPointer;
  this.forEach((m3, n3) => {
    let more = m3.after(regs, group);
    if (more.found) {
      let terms = more.terms();
      ptrs[n3][2] += terms.length;
      ptrs[n3][4] = null;
    }
  });
  return this.update(ptrs);
};
var grow = function(regs, group, opts2) {
  return this.growRight(regs, group, opts2).growLeft(regs, group, opts2);
};
var lookaround_default = { before, after, growLeft, growRight, grow };

// node_modules/compromise/src/1-one/match/api/split.js
var combine = function(left, right) {
  return [left[0], left[1], right[2]];
};
var isArray5 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var getDoc = (reg, view, group) => {
  if (typeof reg === "string" || isArray5(reg)) {
    return view.match(reg, group);
  }
  if (!reg) {
    return view.none();
  }
  return reg;
};
var addIds2 = function(ptr, view) {
  let [n3, start2, end2] = ptr;
  if (view.document[n3] && view.document[n3][start2]) {
    ptr[3] = ptr[3] || view.document[n3][start2].id;
    if (view.document[n3][end2 - 1]) {
      ptr[4] = ptr[4] || view.document[n3][end2 - 1].id;
    }
  }
  return ptr;
};
var methods7 = {};
methods7.splitOn = function(m3, group) {
  const { splitAll: splitAll2 } = this.methods.one.pointer;
  let splits = getDoc(m3, this, group).fullPointer;
  let all4 = splitAll2(this.fullPointer, splits);
  let res = [];
  all4.forEach((o2) => {
    res.push(o2.passthrough);
    res.push(o2.before);
    res.push(o2.match);
    res.push(o2.after);
  });
  res = res.filter((p4) => p4);
  res = res.map((p4) => addIds2(p4, this));
  return this.update(res);
};
methods7.splitBefore = function(m3, group) {
  const { splitAll: splitAll2 } = this.methods.one.pointer;
  let splits = getDoc(m3, this, group).fullPointer;
  let all4 = splitAll2(this.fullPointer, splits);
  let res = [];
  all4.forEach((o2) => {
    res.push(o2.passthrough);
    res.push(o2.before);
    if (o2.match && o2.after) {
      res.push(combine(o2.match, o2.after));
    } else {
      res.push(o2.match);
      res.push(o2.after);
    }
  });
  res = res.filter((p4) => p4);
  res = res.map((p4) => addIds2(p4, this));
  return this.update(res);
};
methods7.splitAfter = function(m3, group) {
  const { splitAll: splitAll2 } = this.methods.one.pointer;
  let splits = getDoc(m3, this, group).fullPointer;
  let all4 = splitAll2(this.fullPointer, splits);
  let res = [];
  all4.forEach((o2) => {
    res.push(o2.passthrough);
    if (o2.before && o2.match) {
      res.push(combine(o2.before, o2.match));
    } else {
      res.push(o2.before);
      res.push(o2.match);
    }
    res.push(o2.after);
  });
  res = res.filter((p4) => p4);
  res = res.map((p4) => addIds2(p4, this));
  return this.update(res);
};
methods7.split = methods7.splitAfter;
var split_default = methods7;

// node_modules/compromise/src/1-one/match/api/index.js
var methods8 = Object.assign({}, match_default, lookaround_default, split_default);
methods8.lookBehind = methods8.before;
methods8.lookBefore = methods8.before;
methods8.lookAhead = methods8.after;
methods8.lookAfter = methods8.after;
methods8.notIf = methods8.ifNo;
var matchAPI = function(View2) {
  Object.assign(View2.prototype, methods8);
};
var api_default4 = matchAPI;

// node_modules/compromise/src/1-one/match/methods/parseMatch/01-parseBlocks.js
var bySlashes = /(?:^|\s)([![^]*(?:<[^<]*>)?\/.*?[^\\/]\/[?\]+*$~]*)(?:\s|$)/;
var byParentheses = /([!~[^]*(?:<[^<]*>)?\([^)]+[^\\)]\)[?\]+*$~]*)(?:\s|$)/;
var byWord = / /g;
var isBlock = (str) => {
  return /^[![^]*(<[^<]*>)?\(/.test(str) && /\)[?\]+*$~]*$/.test(str);
};
var isReg = (str) => {
  return /^[![^]*(<[^<]*>)?\//.test(str) && /\/[?\]+*$~]*$/.test(str);
};
var cleanUp = function(arr) {
  arr = arr.map((str) => str.trim());
  arr = arr.filter((str) => str);
  return arr;
};
var parseBlocks = function(txt) {
  let arr = txt.split(bySlashes);
  let res = [];
  arr.forEach((str) => {
    if (isReg(str)) {
      res.push(str);
      return;
    }
    res = res.concat(str.split(byParentheses));
  });
  res = cleanUp(res);
  let final = [];
  res.forEach((str) => {
    if (isBlock(str)) {
      final.push(str);
    } else if (isReg(str)) {
      final.push(str);
    } else {
      final = final.concat(str.split(byWord));
    }
  });
  final = cleanUp(final);
  return final;
};
var parseBlocks_default = parseBlocks;

// node_modules/compromise/src/1-one/match/methods/parseMatch/02-parseToken.js
var hasMinMax = /\{([0-9]+)?(, *[0-9]*)?\}/;
var andSign = /&&/;
var captureName = new RegExp(/^<\s*(\S+)\s*>/);
var titleCase2 = (str) => str.charAt(0).toUpperCase() + str.substring(1);
var end = (str) => str.charAt(str.length - 1);
var start = (str) => str.charAt(0);
var stripStart = (str) => str.substring(1);
var stripEnd = (str) => str.substring(0, str.length - 1);
var stripBoth = function(str) {
  str = stripStart(str);
  str = stripEnd(str);
  return str;
};
var parseToken = function(w, opts2) {
  let obj = {};
  for (let i3 = 0; i3 < 2; i3 += 1) {
    if (end(w) === "$") {
      obj.end = true;
      w = stripEnd(w);
    }
    if (start(w) === "^") {
      obj.start = true;
      w = stripStart(w);
    }
    if (start(w) === "[" || end(w) === "]") {
      obj.group = null;
      if (start(w) === "[") {
        obj.groupStart = true;
      }
      if (end(w) === "]") {
        obj.groupEnd = true;
      }
      w = w.replace(/^\[/, "");
      w = w.replace(/\]$/, "");
      if (start(w) === "<") {
        const res = captureName.exec(w);
        if (res.length >= 2) {
          obj.group = res[1];
          w = w.replace(res[0], "");
        }
      }
    }
    if (end(w) === "+") {
      obj.greedy = true;
      w = stripEnd(w);
    }
    if (w !== "*" && end(w) === "*" && w !== "\\*") {
      obj.greedy = true;
      w = stripEnd(w);
    }
    if (end(w) === "?") {
      obj.optional = true;
      w = stripEnd(w);
    }
    if (start(w) === "!") {
      obj.negative = true;
      w = stripStart(w);
    }
    if (start(w) === "~" && end(w) === "~" && w.length > 2) {
      w = stripBoth(w);
      obj.fuzzy = true;
      obj.min = opts2.fuzzy || 0.85;
      if (/\(/.test(w) === false) {
        obj.word = w;
        return obj;
      }
    }
    if (start(w) === "(" && end(w) === ")") {
      if (andSign.test(w)) {
        obj.choices = w.split(andSign);
        obj.operator = "and";
      } else {
        obj.choices = w.split("|");
        obj.operator = "or";
      }
      obj.choices[0] = stripStart(obj.choices[0]);
      let last = obj.choices.length - 1;
      obj.choices[last] = stripEnd(obj.choices[last]);
      obj.choices = obj.choices.map((s3) => s3.trim());
      obj.choices = obj.choices.filter((s3) => s3);
      obj.choices = obj.choices.map((str) => {
        return str.split(/ /g).map((s3) => parseToken(s3, opts2));
      });
      w = "";
    }
    if (start(w) === "/" && end(w) === "/") {
      w = stripBoth(w);
      if (opts2.caseSensitive) {
        obj.use = "text";
      }
      obj.regex = new RegExp(w);
      return obj;
    }
    if (start(w) === "{" && end(w) === "}") {
      w = stripBoth(w);
      obj.root = w;
      if (/\//.test(w)) {
        let split3 = obj.root.split(/\//);
        obj.root = split3[0];
        obj.pos = split3[1];
        if (obj.pos === "adj") {
          obj.pos = "Adjective";
        }
        obj.pos = obj.pos.charAt(0).toUpperCase() + obj.pos.substr(1).toLowerCase();
        if (split3[2] !== void 0) {
          obj.sense = split3[2];
        }
      }
      return obj;
    }
    if (start(w) === "<" && end(w) === ">") {
      w = stripBoth(w);
      obj.chunk = titleCase2(w);
      obj.greedy = true;
      return obj;
    }
    if (start(w) === "%" && end(w) === "%") {
      w = stripBoth(w);
      obj.switch = w;
      return obj;
    }
  }
  if (hasMinMax.test(w) === true) {
    w = w.replace(hasMinMax, (_a, b, c2) => {
      if (c2 === void 0) {
        obj.min = Number(b);
        obj.max = Number(b);
      } else {
        c2 = c2.replace(/, */, "");
        if (b === void 0) {
          obj.min = 0;
          obj.max = Number(c2);
        } else {
          obj.min = Number(b);
          obj.max = Number(c2 || 999);
        }
      }
      obj.greedy = true;
      if (!obj.min) {
        obj.optional = true;
      }
      return "";
    });
  }
  if (start(w) === "#") {
    obj.tag = stripStart(w);
    obj.tag = titleCase2(obj.tag);
    return obj;
  }
  if (start(w) === "@") {
    obj.method = stripStart(w);
    return obj;
  }
  if (w === ".") {
    obj.anything = true;
    return obj;
  }
  if (w === "*") {
    obj.anything = true;
    obj.greedy = true;
    obj.optional = true;
    return obj;
  }
  if (w) {
    w = w.replace("\\*", "*");
    w = w.replace("\\.", ".");
    if (opts2.caseSensitive) {
      obj.use = "text";
    } else {
      w = w.toLowerCase();
    }
    obj.word = w;
  }
  return obj;
};
var parseToken_default = parseToken;

// node_modules/compromise/src/1-one/match/methods/parseMatch/03-splitHyphens.js
var hasDash = /[a-z0-9][-–—][a-z]/i;
var splitHyphens = function(regs, world2) {
  let prefixes2 = world2.model.one.prefixes;
  for (let i3 = regs.length - 1; i3 >= 0; i3 -= 1) {
    let reg = regs[i3];
    if (reg.word && hasDash.test(reg.word)) {
      let words = reg.word.split(/[-–—]/g);
      if (prefixes2.hasOwnProperty(words[0])) {
        continue;
      }
      words = words.filter((w) => w).reverse();
      regs.splice(i3, 1);
      words.forEach((w) => {
        let obj = Object.assign({}, reg);
        obj.word = w;
        regs.splice(i3, 0, obj);
      });
    }
  }
  return regs;
};
var splitHyphens_default = splitHyphens;

// node_modules/compromise/src/1-one/match/methods/parseMatch/04-inflect-root.js
var addVerbs = function(token, world2) {
  let { all: all4 } = world2.methods.two.transform.verb || {};
  let str = token.root;
  if (!all4) {
    return [];
  }
  return all4(str, world2.model);
};
var addNoun = function(token, world2) {
  let { all: all4 } = world2.methods.two.transform.noun || {};
  if (!all4) {
    return [token.root];
  }
  return all4(token.root, world2.model);
};
var addAdjective = function(token, world2) {
  let { all: all4 } = world2.methods.two.transform.adjective || {};
  if (!all4) {
    return [token.root];
  }
  return all4(token.root, world2.model);
};
var inflectRoot = function(regs, world2) {
  regs = regs.map((token) => {
    if (token.root) {
      if (world2.methods.two && world2.methods.two.transform) {
        let choices = [];
        if (token.pos) {
          if (token.pos === "Verb") {
            choices = choices.concat(addVerbs(token, world2));
          } else if (token.pos === "Noun") {
            choices = choices.concat(addNoun(token, world2));
          } else if (token.pos === "Adjective") {
            choices = choices.concat(addAdjective(token, world2));
          }
        } else {
          choices = choices.concat(addVerbs(token, world2));
          choices = choices.concat(addNoun(token, world2));
          choices = choices.concat(addAdjective(token, world2));
        }
        choices = choices.filter((str) => str);
        if (choices.length > 0) {
          token.operator = "or";
          token.fastOr = new Set(choices);
        }
      } else {
        token.machine = token.root;
        delete token.id;
        delete token.root;
      }
    }
    return token;
  });
  return regs;
};
var inflect_root_default = inflectRoot;

// node_modules/compromise/src/1-one/match/methods/parseMatch/05-postProcess.js
var nameGroups = function(regs) {
  let index3 = 0;
  let inGroup = null;
  for (let i3 = 0; i3 < regs.length; i3++) {
    const token = regs[i3];
    if (token.groupStart === true) {
      inGroup = token.group;
      if (inGroup === null) {
        inGroup = String(index3);
        index3 += 1;
      }
    }
    if (inGroup !== null) {
      token.group = inGroup;
    }
    if (token.groupEnd === true) {
      inGroup = null;
    }
  }
  return regs;
};
var doFastOrMode = function(tokens) {
  return tokens.map((token) => {
    if (token.choices !== void 0) {
      if (token.operator !== "or") {
        return token;
      }
      if (token.fuzzy === true) {
        return token;
      }
      let shouldPack = token.choices.every((block) => {
        if (block.length !== 1) {
          return false;
        }
        let reg = block[0];
        if (reg.fuzzy === true) {
          return false;
        }
        if (reg.start || reg.end) {
          return false;
        }
        if (reg.word !== void 0 && reg.negative !== true && reg.optional !== true && reg.method !== true) {
          return true;
        }
        return false;
      });
      if (shouldPack === true) {
        token.fastOr = /* @__PURE__ */ new Set();
        token.choices.forEach((block) => {
          token.fastOr.add(block[0].word);
        });
        delete token.choices;
      }
    }
    return token;
  });
};
var fuzzyOr = function(regs) {
  return regs.map((reg) => {
    if (reg.fuzzy && reg.choices) {
      reg.choices.forEach((r2) => {
        if (r2.length === 1 && r2[0].word) {
          r2[0].fuzzy = true;
          r2[0].min = reg.min;
        }
      });
    }
    return reg;
  });
};
var postProcess = function(regs) {
  regs = nameGroups(regs);
  regs = doFastOrMode(regs);
  regs = fuzzyOr(regs);
  return regs;
};
var postProcess_default = postProcess;

// node_modules/compromise/src/1-one/match/methods/parseMatch/index.js
var syntax = function(input, opts2, world2) {
  if (input === null || input === void 0 || input === "") {
    return [];
  }
  opts2 = opts2 || {};
  if (typeof input === "number") {
    input = String(input);
  }
  let tokens = parseBlocks_default(input);
  tokens = tokens.map((str) => parseToken_default(str, opts2));
  tokens = splitHyphens_default(tokens, world2);
  tokens = inflect_root_default(tokens, world2);
  tokens = postProcess_default(tokens, opts2);
  return tokens;
};
var parseMatch_default = syntax;

// node_modules/compromise/src/1-one/match/methods/match/01-failFast.js
var anyIntersection = function(setA, setB) {
  for (let elem of setB) {
    if (setA.has(elem)) {
      return true;
    }
  }
  return false;
};
var failFast = function(regs, cache2) {
  for (let i3 = 0; i3 < regs.length; i3 += 1) {
    let reg = regs[i3];
    if (reg.optional === true || reg.negative === true || reg.fuzzy === true) {
      continue;
    }
    if (reg.word !== void 0 && cache2.has(reg.word) === false) {
      return true;
    }
    if (reg.tag !== void 0 && cache2.has("#" + reg.tag) === false) {
      return true;
    }
    if (reg.fastOr && anyIntersection(reg.fastOr, cache2) === false) {
      return false;
    }
  }
  return false;
};
var failFast_default = failFast;

// node_modules/compromise/src/1-one/match/methods/match/term/_fuzzy.js
var editDistance = function(strA, strB) {
  let aLength = strA.length, bLength = strB.length;
  if (aLength === 0) {
    return bLength;
  }
  if (bLength === 0) {
    return aLength;
  }
  let limit = (bLength > aLength ? bLength : aLength) + 1;
  if (Math.abs(aLength - bLength) > (limit || 100)) {
    return limit || 100;
  }
  let matrix = [];
  for (let i3 = 0; i3 < limit; i3++) {
    matrix[i3] = [i3];
    matrix[i3].length = limit;
  }
  for (let i3 = 0; i3 < limit; i3++) {
    matrix[0][i3] = i3;
  }
  let j2, a_index, b_index, cost, min2, t2;
  for (let i3 = 1; i3 <= aLength; ++i3) {
    a_index = strA[i3 - 1];
    for (j2 = 1; j2 <= bLength; ++j2) {
      if (i3 === j2 && matrix[i3][j2] > 4) {
        return aLength;
      }
      b_index = strB[j2 - 1];
      cost = a_index === b_index ? 0 : 1;
      min2 = matrix[i3 - 1][j2] + 1;
      if ((t2 = matrix[i3][j2 - 1] + 1) < min2)
        min2 = t2;
      if ((t2 = matrix[i3 - 1][j2 - 1] + cost) < min2)
        min2 = t2;
      let shouldUpdate = i3 > 1 && j2 > 1 && a_index === strB[j2 - 2] && strA[i3 - 2] === b_index && (t2 = matrix[i3 - 2][j2 - 2] + cost) < min2;
      if (shouldUpdate) {
        matrix[i3][j2] = t2;
      } else {
        matrix[i3][j2] = min2;
      }
    }
  }
  return matrix[aLength][bLength];
};
var fuzzyMatch = function(strA, strB, minLength = 3) {
  if (strA === strB) {
    return 1;
  }
  if (strA.length < minLength || strB.length < minLength) {
    return 0;
  }
  const steps = editDistance(strA, strB);
  let length2 = Math.max(strA.length, strB.length);
  let relative2 = length2 === 0 ? 0 : steps / length2;
  let similarity = 1 - relative2;
  return similarity;
};
var fuzzy_default = fuzzyMatch;

// node_modules/compromise/src/1-one/match/methods/termMethods.js
var startQuote = /([\u0022\uFF02\u0027\u201C\u2018\u201F\u201B\u201E\u2E42\u201A\u00AB\u2039\u2035\u2036\u2037\u301D\u0060\u301F])/;
var endQuote = /([\u0022\uFF02\u0027\u201D\u2019\u00BB\u203A\u2032\u2033\u2034\u301E\u00B4])/;
var hasHyphen = /^[-–—]$/;
var hasDash2 = / [-–—]{1,3} /;
var hasPost = (term, punct) => term.post.indexOf(punct) !== -1;
var hasPre = (term, punct) => term.pre.indexOf(punct) !== -1;
var methods9 = {
  hasQuote: (term) => startQuote.test(term.pre) || endQuote.test(term.post),
  hasComma: (term) => hasPost(term, ","),
  hasPeriod: (term) => hasPost(term, ".") === true && hasPost(term, "...") === false,
  hasExclamation: (term) => hasPost(term, "!"),
  hasQuestionMark: (term) => hasPost(term, "?") || hasPost(term, "\xBF"),
  hasEllipses: (term) => hasPost(term, "..") || hasPost(term, "\u2026") || hasPre(term, "..") || hasPre(term, "\u2026"),
  hasSemicolon: (term) => hasPost(term, ";"),
  hasColon: (term) => hasPost(term, ":"),
  hasSlash: (term) => /\//.test(term.text),
  hasHyphen: (term) => hasHyphen.test(term.post) || hasHyphen.test(term.pre),
  hasDash: (term) => hasDash2.test(term.post) || hasDash2.test(term.pre),
  hasContraction: (term) => Boolean(term.implicit),
  isAcronym: (term) => term.tags.has("Acronym"),
  isKnown: (term) => term.tags.size > 0,
  isTitleCase: (term) => /^\p{Lu}[a-z'\u00C0-\u00FF]/u.test(term.text),
  isUpperCase: (term) => /^\p{Lu}+$/u.test(term.text)
};
methods9.hasQuotation = methods9.hasQuote;
var termMethods_default = methods9;

// node_modules/compromise/src/1-one/match/methods/match/term/doesMatch.js
var wrapMatch = function() {
};
var doesMatch = function(term, reg, index3, length2) {
  if (reg.anything === true) {
    return true;
  }
  if (reg.start === true && index3 !== 0) {
    return false;
  }
  if (reg.end === true && index3 !== length2 - 1) {
    return false;
  }
  if (reg.id !== void 0 && reg.id === term.id) {
    return true;
  }
  if (reg.word !== void 0) {
    if (reg.use) {
      return reg.word === term[reg.use];
    }
    if (term.machine !== null && term.machine === reg.word) {
      return true;
    }
    if (term.alias !== void 0 && term.alias.hasOwnProperty(reg.word)) {
      return true;
    }
    if (reg.fuzzy === true) {
      if (reg.word === term.root) {
        return true;
      }
      let score = fuzzy_default(reg.word, term.normal);
      if (score >= reg.min) {
        return true;
      }
    }
    if (term.alias && term.alias.some((str) => str === reg.word)) {
      return true;
    }
    return reg.word === term.text || reg.word === term.normal;
  }
  if (reg.tag !== void 0) {
    return term.tags.has(reg.tag) === true;
  }
  if (reg.method !== void 0) {
    if (typeof termMethods_default[reg.method] === "function" && termMethods_default[reg.method](term) === true) {
      return true;
    }
    return false;
  }
  if (reg.pre !== void 0) {
    return term.pre && term.pre.includes(reg.pre);
  }
  if (reg.post !== void 0) {
    return term.post && term.post.includes(reg.post);
  }
  if (reg.regex !== void 0) {
    let str = term.normal;
    if (reg.use) {
      str = term[reg.use];
    }
    return reg.regex.test(str);
  }
  if (reg.chunk !== void 0) {
    return term.chunk === reg.chunk;
  }
  if (reg.switch !== void 0) {
    return term.switch === reg.switch;
  }
  if (reg.machine !== void 0) {
    return term.normal === reg.machine || term.machine === reg.machine || term.root === reg.machine;
  }
  if (reg.sense !== void 0) {
    return term.sense === reg.sense;
  }
  if (reg.fastOr !== void 0) {
    if (reg.pos && !term.tags.has(reg.pos)) {
      return null;
    }
    let str = term.root || term.implicit || term.machine || term.normal;
    return reg.fastOr.has(str) || reg.fastOr.has(term.text);
  }
  if (reg.choices !== void 0) {
    if (reg.operator === "and") {
      return reg.choices.every((r2) => wrapMatch(term, r2, index3, length2));
    }
    return reg.choices.some((r2) => wrapMatch(term, r2, index3, length2));
  }
  return false;
};
wrapMatch = function(t2, reg, index3, length2) {
  let result = doesMatch(t2, reg, index3, length2);
  if (reg.negative === true) {
    return !result;
  }
  return result;
};
var doesMatch_default = wrapMatch;

// node_modules/compromise/src/1-one/match/methods/match/steps/logic/greedy.js
var getGreedy = function(state, endReg) {
  let reg = Object.assign({}, state.regs[state.r], { start: false, end: false });
  let start2 = state.t;
  for (; state.t < state.terms.length; state.t += 1) {
    if (endReg && doesMatch_default(state.terms[state.t], endReg, state.start_i + state.t, state.phrase_length)) {
      return state.t;
    }
    let count = state.t - start2 + 1;
    if (reg.max !== void 0 && count === reg.max) {
      return state.t;
    }
    if (doesMatch_default(state.terms[state.t], reg, state.start_i + state.t, state.phrase_length) === false) {
      if (reg.min !== void 0 && count < reg.min) {
        return null;
      }
      return state.t;
    }
  }
  return state.t;
};
var greedyTo = function(state, nextReg) {
  let t2 = state.t;
  if (!nextReg) {
    return state.terms.length;
  }
  for (; t2 < state.terms.length; t2 += 1) {
    if (doesMatch_default(state.terms[t2], nextReg, state.start_i + t2, state.phrase_length) === true) {
      return t2;
    }
  }
  return null;
};
var isEndGreedy = function(reg, state) {
  if (reg.end === true && reg.greedy === true) {
    if (state.start_i + state.t < state.phrase_length - 1) {
      let tmpReg = Object.assign({}, reg, { end: false });
      if (doesMatch_default(state.terms[state.t], tmpReg, state.start_i + state.t, state.phrase_length) === true) {
        return true;
      }
    }
  }
  return false;
};

// node_modules/compromise/src/1-one/match/methods/match/_lib.js
var getGroup = function(state, term_index) {
  if (state.groups[state.inGroup]) {
    return state.groups[state.inGroup];
  }
  state.groups[state.inGroup] = {
    start: term_index,
    length: 0
  };
  return state.groups[state.inGroup];
};

// node_modules/compromise/src/1-one/match/methods/match/steps/astrix.js
var doAstrix = function(state) {
  let { regs } = state;
  let reg = regs[state.r];
  let skipto = greedyTo(state, regs[state.r + 1]);
  if (skipto === null || skipto === 0) {
    return null;
  }
  if (reg.min !== void 0 && skipto - state.t < reg.min) {
    return null;
  }
  if (reg.max !== void 0 && skipto - state.t > reg.max) {
    state.t = state.t + reg.max;
    return true;
  }
  if (state.hasGroup === true) {
    const g3 = getGroup(state, state.t);
    g3.length = skipto - state.t;
  }
  state.t = skipto;
  return true;
};
var astrix_default = doAstrix;

// node_modules/compromise/src/1-one/match/methods/match/steps/logic/and-or.js
var isArray6 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var doOrBlock = function(state, skipN = 0) {
  let block = state.regs[state.r];
  let wasFound = false;
  for (let c2 = 0; c2 < block.choices.length; c2 += 1) {
    let regs = block.choices[c2];
    if (!isArray6(regs)) {
      return false;
    }
    wasFound = regs.every((cr, w_index) => {
      let extra = 0;
      let t2 = state.t + w_index + skipN + extra;
      if (state.terms[t2] === void 0) {
        return false;
      }
      let foundBlock = doesMatch_default(state.terms[t2], cr, t2 + state.start_i, state.phrase_length);
      if (foundBlock === true && cr.greedy === true) {
        for (let i3 = 1; i3 < state.terms.length; i3 += 1) {
          let term = state.terms[t2 + i3];
          if (term) {
            let keepGoing = doesMatch_default(term, cr, state.start_i + i3, state.phrase_length);
            if (keepGoing === true) {
              extra += 1;
            } else {
              break;
            }
          }
        }
      }
      skipN += extra;
      return foundBlock;
    });
    if (wasFound) {
      skipN += regs.length;
      break;
    }
  }
  if (wasFound && block.greedy === true) {
    return doOrBlock(state, skipN);
  }
  return skipN;
};
var doAndBlock = function(state) {
  let longest = 0;
  let reg = state.regs[state.r];
  let allDidMatch = reg.choices.every((block) => {
    let allWords = block.every((cr, w_index) => {
      let tryTerm = state.t + w_index;
      if (state.terms[tryTerm] === void 0) {
        return false;
      }
      return doesMatch_default(state.terms[tryTerm], cr, tryTerm, state.phrase_length);
    });
    if (allWords === true && block.length > longest) {
      longest = block.length;
    }
    return allWords;
  });
  if (allDidMatch === true) {
    return longest;
  }
  return false;
};

// node_modules/compromise/src/1-one/match/methods/match/steps/or-block.js
var orBlock = function(state) {
  const { regs } = state;
  let reg = regs[state.r];
  let skipNum = doOrBlock(state);
  if (skipNum) {
    if (reg.negative === true) {
      return null;
    }
    if (state.hasGroup === true) {
      const g3 = getGroup(state, state.t);
      g3.length += skipNum;
    }
    if (reg.end === true) {
      let end2 = state.phrase_length;
      if (state.t + state.start_i + skipNum !== end2) {
        return null;
      }
    }
    state.t += skipNum;
    return true;
  } else if (!reg.optional) {
    return null;
  }
  return true;
};
var or_block_default = orBlock;

// node_modules/compromise/src/1-one/match/methods/match/steps/and-block.js
var andBlock = function(state) {
  const { regs } = state;
  let reg = regs[state.r];
  let skipNum = doAndBlock(state);
  if (skipNum) {
    if (reg.negative === true) {
      return null;
    }
    if (state.hasGroup === true) {
      const g3 = getGroup(state, state.t);
      g3.length += skipNum;
    }
    if (reg.end === true) {
      let end2 = state.phrase_length - 1;
      if (state.t + state.start_i !== end2) {
        return null;
      }
    }
    state.t += skipNum;
    return true;
  } else if (!reg.optional) {
    return null;
  }
  return true;
};
var and_block_default = andBlock;

// node_modules/compromise/src/1-one/match/methods/match/steps/logic/negative-greedy.js
var negGreedy = function(state, reg, nextReg) {
  let skip = 0;
  for (let t2 = state.t; t2 < state.terms.length; t2 += 1) {
    let found = doesMatch_default(state.terms[t2], reg, state.start_i + state.t, state.phrase_length);
    if (found) {
      break;
    }
    if (nextReg) {
      found = doesMatch_default(state.terms[t2], nextReg, state.start_i + state.t, state.phrase_length);
      if (found) {
        break;
      }
    }
    skip += 1;
    if (reg.max !== void 0 && skip === reg.max) {
      break;
    }
  }
  if (skip === 0) {
    return false;
  }
  if (reg.min && reg.min > skip) {
    return false;
  }
  state.t += skip;
  return true;
};
var negative_greedy_default = negGreedy;

// node_modules/compromise/src/1-one/match/methods/match/steps/negative.js
var doNegative = function(state) {
  const { regs } = state;
  let reg = regs[state.r];
  let tmpReg = Object.assign({}, reg);
  tmpReg.negative = false;
  let found = doesMatch_default(state.terms[state.t], tmpReg, state.start_i + state.t, state.phrase_length);
  if (found) {
    return false;
  }
  if (reg.optional) {
    let nextReg = regs[state.r + 1];
    if (nextReg) {
      let fNext = doesMatch_default(state.terms[state.t], nextReg, state.start_i + state.t, state.phrase_length);
      if (fNext) {
        state.r += 1;
      } else if (nextReg.optional && regs[state.r + 2]) {
        let fNext2 = doesMatch_default(state.terms[state.t], regs[state.r + 2], state.start_i + state.t, state.phrase_length);
        if (fNext2) {
          state.r += 2;
        }
      }
    }
  }
  if (reg.greedy) {
    return negative_greedy_default(state, tmpReg, regs[state.r + 1]);
  }
  state.t += 1;
  return true;
};
var negative_default = doNegative;

// node_modules/compromise/src/1-one/match/methods/match/steps/optional-match.js
var foundOptional = function(state) {
  const { regs } = state;
  let reg = regs[state.r];
  let term = state.terms[state.t];
  let nextRegMatched = doesMatch_default(term, regs[state.r + 1], state.start_i + state.t, state.phrase_length);
  if (reg.negative || nextRegMatched) {
    let nextTerm = state.terms[state.t + 1];
    if (!nextTerm || !doesMatch_default(nextTerm, regs[state.r + 1], state.start_i + state.t, state.phrase_length)) {
      state.r += 1;
    }
  }
};
var optional_match_default = foundOptional;

// node_modules/compromise/src/1-one/match/methods/match/steps/greedy-match.js
var greedyMatch = function(state) {
  const { regs, phrase_length } = state;
  let reg = regs[state.r];
  state.t = getGreedy(state, regs[state.r + 1]);
  if (state.t === null) {
    return null;
  }
  if (reg.min && reg.min > state.t) {
    return null;
  }
  if (reg.end === true && state.start_i + state.t !== phrase_length) {
    return null;
  }
  return true;
};
var greedy_match_default = greedyMatch;

// node_modules/compromise/src/1-one/match/methods/match/steps/contraction-skip.js
var contractionSkip = function(state) {
  let term = state.terms[state.t];
  let reg = state.regs[state.r];
  if (term.implicit && state.terms[state.t + 1]) {
    let nextTerm = state.terms[state.t + 1];
    if (!nextTerm.implicit) {
      return;
    }
    if (reg.word === term.normal) {
      state.t += 1;
    }
    if (reg.method === "hasContraction") {
      state.t += 1;
    }
  }
};
var contraction_skip_default = contractionSkip;

// node_modules/compromise/src/1-one/match/methods/match/steps/simple-match.js
var setGroup = function(state, startAt) {
  let reg = state.regs[state.r];
  const g3 = getGroup(state, startAt);
  if (state.t > 1 && reg.greedy) {
    g3.length += state.t - startAt;
  } else {
    g3.length++;
  }
};
var simpleMatch = function(state) {
  const { regs } = state;
  let reg = regs[state.r];
  let term = state.terms[state.t];
  let startAt = state.t;
  if (reg.optional && regs[state.r + 1] && reg.negative) {
    return true;
  }
  if (reg.optional && regs[state.r + 1]) {
    optional_match_default(state);
  }
  if (term.implicit && state.terms[state.t + 1]) {
    contraction_skip_default(state);
  }
  state.t += 1;
  if (reg.end === true && state.t !== state.terms.length && reg.greedy !== true) {
    return null;
  }
  if (reg.greedy === true) {
    let alive = greedy_match_default(state);
    if (!alive) {
      return null;
    }
  }
  if (state.hasGroup === true) {
    setGroup(state, startAt);
  }
  return true;
};
var simple_match_default = simpleMatch;

// node_modules/compromise/src/1-one/match/methods/match/02-from-here.js
var tryHere = function(terms, regs, start_i, phrase_length) {
  if (terms.length === 0 || regs.length === 0) {
    return null;
  }
  let state = {
    t: 0,
    terms,
    r: 0,
    regs,
    groups: {},
    start_i,
    phrase_length,
    inGroup: null
  };
  for (; state.r < regs.length; state.r += 1) {
    let reg = regs[state.r];
    state.hasGroup = Boolean(reg.group);
    if (state.hasGroup === true) {
      state.inGroup = reg.group;
    } else {
      state.inGroup = null;
    }
    if (!state.terms[state.t]) {
      const alive = regs.slice(state.r).some((remain) => !remain.optional);
      if (alive === false) {
        break;
      }
      return null;
    }
    if (reg.anything === true && reg.greedy === true) {
      let alive = astrix_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.choices !== void 0 && reg.operator === "or") {
      let alive = or_block_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.choices !== void 0 && reg.operator === "and") {
      let alive = and_block_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.anything === true) {
      if (reg.negative && reg.anything) {
        return null;
      }
      let alive = simple_match_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (isEndGreedy(reg, state) === true) {
      let alive = simple_match_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.negative) {
      let alive = negative_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    let hasMatch = doesMatch_default(state.terms[state.t], reg, state.start_i + state.t, state.phrase_length);
    if (hasMatch === true) {
      let alive = simple_match_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.optional === true) {
      continue;
    }
    return null;
  }
  let pntr = [null, start_i, state.t + start_i];
  if (pntr[1] === pntr[2]) {
    return null;
  }
  let groups = {};
  Object.keys(state.groups).forEach((k2) => {
    let o2 = state.groups[k2];
    let start2 = start_i + o2.start;
    groups[k2] = [null, start2, start2 + o2.length];
  });
  return { pointer: pntr, groups };
};
var from_here_default = tryHere;

// node_modules/compromise/src/1-one/match/methods/match/03-getGroup.js
var getGroup2 = function(res, group) {
  let ptrs = [];
  let byGroup = {};
  if (res.length === 0) {
    return { ptrs, byGroup };
  }
  if (typeof group === "number") {
    group = String(group);
  }
  if (group) {
    res.forEach((r2) => {
      if (r2.groups[group]) {
        ptrs.push(r2.groups[group]);
      }
    });
  } else {
    res.forEach((r2) => {
      ptrs.push(r2.pointer);
      Object.keys(r2.groups).forEach((k2) => {
        byGroup[k2] = byGroup[k2] || [];
        byGroup[k2].push(r2.groups[k2]);
      });
    });
  }
  return { ptrs, byGroup };
};
var getGroup_default = getGroup2;

// node_modules/compromise/src/1-one/match/methods/match/03-notIf.js
var notIf = function(results, not, docs) {
  results = results.filter((res) => {
    let [n3, start2, end2] = res.pointer;
    let terms = docs[n3].slice(start2, end2);
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let slice = terms.slice(i3);
      let found = from_here_default(slice, not, i3, terms.length);
      if (found !== null) {
        return false;
      }
    }
    return true;
  });
  return results;
};
var notIf_default = notIf;

// node_modules/compromise/src/1-one/match/methods/match/index.js
var addSentence = function(res, n3) {
  res.pointer[0] = n3;
  Object.keys(res.groups).forEach((k2) => {
    res.groups[k2][0] = n3;
  });
  return res;
};
var handleStart = function(terms, regs, n3) {
  let res = from_here_default(terms, regs, 0, terms.length);
  if (res) {
    res = addSentence(res, n3);
    return res;
  }
  return null;
};
var runMatch = function(docs, todo, cache2) {
  cache2 = cache2 || [];
  let { regs, group, justOne } = todo;
  let results = [];
  if (!regs || regs.length === 0) {
    return { ptrs: [], byGroup: {} };
  }
  const minLength = regs.filter((r2) => r2.optional !== true && r2.negative !== true).length;
  docs:
    for (let n3 = 0; n3 < docs.length; n3 += 1) {
      let terms = docs[n3];
      if (cache2[n3] && failFast_default(regs, cache2[n3])) {
        continue;
      }
      if (regs[0].start === true) {
        let foundStart = handleStart(terms, regs, n3, group);
        if (foundStart) {
          results.push(foundStart);
        }
        continue;
      }
      for (let i3 = 0; i3 < terms.length; i3 += 1) {
        let slice = terms.slice(i3);
        if (slice.length < minLength) {
          break;
        }
        let res = from_here_default(slice, regs, i3, terms.length);
        if (res) {
          res = addSentence(res, n3);
          results.push(res);
          if (justOne === true) {
            break docs;
          }
          let end2 = res.pointer[2];
          if (Math.abs(end2 - 1) > i3) {
            i3 = Math.abs(end2 - 1);
          }
        }
      }
    }
  if (regs[regs.length - 1].end === true) {
    results = results.filter((res) => {
      let n3 = res.pointer[0];
      return docs[n3].length === res.pointer[2];
    });
  }
  if (todo.notIf) {
    results = notIf_default(results, todo.notIf, docs);
  }
  results = getGroup_default(results, group);
  results.ptrs.forEach((ptr) => {
    let [n3, start2, end2] = ptr;
    ptr[3] = docs[n3][start2].id;
    ptr[4] = docs[n3][end2 - 1].id;
  });
  return results;
};
var match_default2 = runMatch;

// node_modules/compromise/src/1-one/match/methods/index.js
var methods10 = {
  one: {
    termMethods: termMethods_default,
    parseMatch: parseMatch_default,
    match: match_default2
  }
};
var methods_default4 = methods10;

// node_modules/compromise/src/1-one/match/lib.js
var lib_default2 = {
  parseMatch: function(str, opts2) {
    const world2 = this.world();
    let killUnicode2 = world2.methods.one.killUnicode;
    if (killUnicode2) {
      str = killUnicode2(str, world2);
    }
    return world2.methods.one.parseMatch(str, opts2, world2);
  }
};

// node_modules/compromise/src/1-one/match/plugin.js
var plugin_default6 = {
  api: api_default4,
  methods: methods_default4,
  lib: lib_default2
};

// node_modules/compromise/src/1-one/output/api/html.js
var isClass = /^\../;
var isId = /^#./;
var escapeXml = (str) => {
  str = str.replace(/&/g, "&amp;");
  str = str.replace(/</g, "&lt;");
  str = str.replace(/>/g, "&gt;");
  str = str.replace(/"/g, "&quot;");
  str = str.replace(/'/g, "&apos;");
  return str;
};
var toTag = function(k2) {
  let start2 = "";
  let end2 = "</span>";
  k2 = escapeXml(k2);
  if (isClass.test(k2)) {
    start2 = `<span class="${k2.replace(/^\./, "")}"`;
  } else if (isId.test(k2)) {
    start2 = `<span id="${k2.replace(/^#/, "")}"`;
  } else {
    start2 = `<${k2}`;
    end2 = `</${k2}>`;
  }
  start2 += ">";
  return { start: start2, end: end2 };
};
var getIndex = function(doc, obj) {
  let starts = {};
  let ends = {};
  Object.keys(obj).forEach((k2) => {
    let res = obj[k2];
    let tag = toTag(k2);
    if (typeof res === "string") {
      res = doc.match(res);
    }
    res.docs.forEach((terms) => {
      if (terms.every((t2) => t2.implicit)) {
        return;
      }
      let a2 = terms[0].id;
      starts[a2] = starts[a2] || [];
      starts[a2].push(tag.start);
      let b = terms[terms.length - 1].id;
      ends[b] = ends[b] || [];
      ends[b].push(tag.end);
    });
  });
  return { starts, ends };
};
var html = function(obj) {
  let { starts, ends } = getIndex(this, obj);
  let out2 = "";
  this.docs.forEach((terms) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let t2 = terms[i3];
      if (starts.hasOwnProperty(t2.id)) {
        out2 += starts[t2.id].join("");
      }
      out2 += t2.pre || "" + t2.text || "";
      if (ends.hasOwnProperty(t2.id)) {
        out2 += ends[t2.id].join("");
      }
      out2 += t2.post || "";
    }
  });
  return out2;
};
var html_default = { html };

// node_modules/compromise/src/1-one/output/api/lib/_text.js
var trimEnd = /[,:;)\]*.?~!\u0022\uFF02\u201D\u2019\u00BB\u203A\u2032\u2033\u2034\u301E\u00B4—-]+$/;
var trimStart = /^[(['"*~\uFF02\u201C\u2018\u201F\u201B\u201E\u2E42\u201A\u00AB\u2039\u2035\u2036\u2037\u301D\u0060\u301F]+/;
var punctToKill = /[,:;)('"\u201D\]]/;
var isHyphen = /^[-–—]$/;
var hasSpace = / /;
var textFromTerms = function(terms, opts2, keepSpace = true) {
  let txt = "";
  terms.forEach((t2) => {
    let pre = t2.pre || "";
    let post = t2.post || "";
    if (opts2.punctuation === "some") {
      pre = pre.replace(trimStart, "");
      if (isHyphen.test(post)) {
        post = " ";
      }
      post = post.replace(punctToKill, "");
      post = post.replace(/\?!+/, "?");
      post = post.replace(/!+/, "!");
      post = post.replace(/\?+/, "?");
      post = post.replace(/\.{2,}/, "");
      if (t2.tags.has("Abbreviation")) {
        post = post.replace(/\./, "");
      }
    }
    if (opts2.whitespace === "some") {
      pre = pre.replace(/\s/, "");
      post = post.replace(/\s+/, " ");
    }
    if (!opts2.keepPunct) {
      pre = pre.replace(trimStart, "");
      if (post === "-") {
        post = " ";
      } else {
        post = post.replace(trimEnd, "");
      }
    }
    let word = t2[opts2.form || "text"] || t2.normal || "";
    if (opts2.form === "implicit") {
      word = t2.implicit || t2.text;
    }
    if (opts2.form === "root" && t2.implicit) {
      word = t2.root || t2.implicit || t2.normal;
    }
    if ((opts2.form === "machine" || opts2.form === "implicit" || opts2.form === "root") && t2.implicit) {
      if (!post || !hasSpace.test(post)) {
        post += " ";
      }
    }
    txt += pre + word + post;
  });
  if (keepSpace === false) {
    txt = txt.trim();
  }
  if (opts2.lowerCase === true) {
    txt = txt.toLowerCase();
  }
  return txt;
};
var textFromDoc = function(docs, opts2) {
  let text = "";
  if (!docs || !docs[0] || !docs[0][0]) {
    return text;
  }
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    text += textFromTerms(docs[i3], opts2, true);
  }
  if (!opts2.keepSpace) {
    text = text.trim();
  }
  if (opts2.keepPunct === false) {
    if (!docs[0][0].tags.has("Emoticon")) {
      text = text.replace(trimStart, "");
    }
    let last = docs[docs.length - 1];
    if (!last[last.length - 1].tags.has("Emoticon")) {
      text = text.replace(trimEnd, "");
    }
  }
  if (opts2.cleanWhitespace === true) {
    text = text.trim();
  }
  return text;
};

// node_modules/compromise/src/1-one/output/api/_fmts.js
var fmts = {
  text: {
    form: "text"
  },
  normal: {
    whitespace: "some",
    punctuation: "some",
    case: "some",
    unicode: "some",
    form: "normal"
  },
  machine: {
    keepSpace: false,
    whitespace: "some",
    punctuation: "some",
    case: "none",
    unicode: "some",
    form: "machine"
  },
  root: {
    keepSpace: false,
    whitespace: "some",
    punctuation: "some",
    case: "some",
    unicode: "some",
    form: "root"
  },
  implicit: {
    form: "implicit"
  }
};
fmts.clean = fmts.normal;
fmts.reduced = fmts.root;
var fmts_default = fmts;

// node_modules/compromise/src/1-one/output/api/lib/hash.js
var k = [];
var i = 0;
for (; i < 64; ) {
  k[i] = 0 | Math.sin(++i % Math.PI) * 4294967296;
}
function md5(s3) {
  let b, c2, d2, h2 = [b = 1732584193, c2 = 4023233417, ~b, ~c2], words = [], j2 = decodeURI(encodeURI(s3)) + "\x80", a2 = j2.length;
  s3 = --a2 / 4 + 2 | 15;
  words[--s3] = a2 * 8;
  for (; ~a2; ) {
    words[a2 >> 2] |= j2.charCodeAt(a2) << 8 * a2--;
  }
  for (i = j2 = 0; i < s3; i += 16) {
    a2 = h2;
    for (; j2 < 64; a2 = [
      d2 = a2[3],
      b + ((d2 = a2[0] + [
        b & c2 | ~b & d2,
        d2 & b | ~d2 & c2,
        b ^ c2 ^ d2,
        c2 ^ (b | ~d2)
      ][a2 = j2 >> 4] + k[j2] + ~~words[i | [
        j2,
        5 * j2 + 1,
        3 * j2 + 5,
        7 * j2
      ][a2] & 15]) << (a2 = [
        7,
        12,
        17,
        22,
        5,
        9,
        14,
        20,
        4,
        11,
        16,
        23,
        6,
        10,
        15,
        21
      ][4 * a2 + j2++ % 4]) | d2 >>> -a2),
      b,
      c2
    ]) {
      b = a2[1] | 0;
      c2 = a2[2];
    }
    for (j2 = 4; j2; )
      h2[--j2] += a2[j2];
  }
  for (s3 = ""; j2 < 32; ) {
    s3 += (h2[j2 >> 3] >> (1 ^ j2++) * 4 & 15).toString(16);
  }
  return s3;
}

// node_modules/compromise/src/1-one/output/api/json.js
var defaults = {
  text: true,
  terms: true
};
var opts = { case: "none", unicode: "some", form: "machine", punctuation: "some" };
var merge = function(a2, b) {
  return Object.assign({}, a2, b);
};
var fns4 = {
  text: (terms) => textFromTerms(terms, { keepPunct: true }, false),
  normal: (terms) => textFromTerms(terms, merge(fmts_default.normal, { keepPunct: true }), false),
  implicit: (terms) => textFromTerms(terms, merge(fmts_default.implicit, { keepPunct: true }), false),
  machine: (terms) => textFromTerms(terms, opts, false),
  root: (terms) => textFromTerms(terms, merge(opts, { form: "root" }), false),
  hash: (terms) => md5(textFromTerms(terms, { keepPunct: true }, false)),
  offset: (terms) => {
    let len = fns4.text(terms).length;
    return {
      index: terms[0].offset.index,
      start: terms[0].offset.start,
      length: len
    };
  },
  terms: (terms) => {
    return terms.map((t2) => {
      let term = Object.assign({}, t2);
      term.tags = Array.from(t2.tags);
      return term;
    });
  },
  confidence: (_terms, view, i3) => view.eq(i3).confidence(),
  syllables: (_terms, view, i3) => view.eq(i3).syllables(),
  sentence: (_terms, view, i3) => view.eq(i3).fullSentence().text(),
  dirty: (terms) => terms.some((t2) => t2.dirty === true)
};
fns4.sentences = fns4.sentence;
fns4.clean = fns4.normal;
fns4.reduced = fns4.root;
var toJSON = function(view, option) {
  option = option || {};
  if (typeof option === "string") {
    option = {};
  }
  option = Object.assign({}, defaults, option);
  if (option.offset) {
    view.compute("offset");
  }
  return view.docs.map((terms, i3) => {
    let res = {};
    Object.keys(option).forEach((k2) => {
      if (option[k2] && fns4[k2]) {
        res[k2] = fns4[k2](terms, view, i3);
      }
    });
    return res;
  });
};
var methods11 = {
  json: function(n3) {
    let res = toJSON(this, n3);
    if (typeof n3 === "number") {
      return res[n3];
    }
    return res;
  }
};
methods11.data = methods11.json;
var json_default = methods11;

// node_modules/compromise/src/1-one/output/api/debug/client-side.js
var logClientSide = function(view) {
  console.log("%c -=-=- ", "background-color:#6699cc;");
  view.forEach((m3) => {
    console.groupCollapsed(m3.text());
    let terms = m3.docs[0];
    let out2 = terms.map((t2) => {
      let text = t2.text || "-";
      if (t2.implicit) {
        text = "[" + t2.implicit + "]";
      }
      let tags = "[" + Array.from(t2.tags).join(", ") + "]";
      return { text, tags };
    });
    console.table(out2, ["text", "tags"]);
    console.groupEnd();
  });
};
var client_side_default = logClientSide;

// node_modules/compromise/src/1-one/output/api/debug/_color.js
var reset = "\x1B[0m";
var cli = {
  green: (str) => "\x1B[32m" + str + reset,
  red: (str) => "\x1B[31m" + str + reset,
  blue: (str) => "\x1B[34m" + str + reset,
  magenta: (str) => "\x1B[35m" + str + reset,
  cyan: (str) => "\x1B[36m" + str + reset,
  yellow: (str) => "\x1B[33m" + str + reset,
  black: (str) => "\x1B[30m" + str + reset,
  dim: (str) => "\x1B[2m" + str + reset,
  i: (str) => "\x1B[3m" + str + reset
};
var color_default = cli;

// node_modules/compromise/src/1-one/output/api/debug/tags.js
var tagString = function(tags, model5) {
  if (model5.one.tagSet) {
    tags = tags.map((tag) => {
      if (!model5.one.tagSet.hasOwnProperty(tag)) {
        return tag;
      }
      const c2 = model5.one.tagSet[tag].color || "blue";
      return color_default[c2](tag);
    });
  }
  return tags.join(", ");
};
var showTags = function(view) {
  let { docs, model: model5 } = view;
  if (docs.length === 0) {
    console.log(color_default.blue("\n     \u2500\u2500\u2500\u2500\u2500\u2500"));
  }
  docs.forEach((terms) => {
    console.log(color_default.blue("\n  \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"));
    terms.forEach((t2) => {
      let tags = [...t2.tags || []];
      let text = t2.text || "-";
      if (t2.sense) {
        text = `{${t2.normal}/${t2.sense}}`;
      }
      if (t2.implicit) {
        text = "[" + t2.implicit + "]";
      }
      text = color_default.yellow(text);
      let word = "'" + text + "'";
      if (t2.reference) {
        let str2 = view.update([t2.reference]).text("normal");
        word += ` - ${color_default.dim(color_default.i("[" + str2 + "]"))}`;
      }
      word = word.padEnd(18);
      let str = color_default.blue("  \u2502 ") + color_default.i(word) + "  - " + tagString(tags, model5);
      console.log(str);
    });
  });
};
var tags_default = showTags;

// node_modules/compromise/src/1-one/output/api/debug/chunks.js
var showChunks = function(view) {
  let { docs } = view;
  console.log("");
  docs.forEach((terms) => {
    let out2 = [];
    terms.forEach((term) => {
      if (term.chunk === "Noun") {
        out2.push(color_default.blue(term.implicit || term.normal));
      } else if (term.chunk === "Verb") {
        out2.push(color_default.green(term.implicit || term.normal));
      } else if (term.chunk === "Adjective") {
        out2.push(color_default.yellow(term.implicit || term.normal));
      } else if (term.chunk === "Pivot") {
        out2.push(color_default.red(term.implicit || term.normal));
      } else {
        out2.push(term.implicit || term.normal);
      }
    });
    console.log(out2.join(" "), "\n");
  });
};
var chunks_default = showChunks;

// node_modules/compromise/src/1-one/output/api/debug/highlight.js
var split = (txt, offset2, index3) => {
  let buff = index3 * 9;
  let start2 = offset2.start + buff;
  let end2 = start2 + offset2.length;
  let pre = txt.substring(0, start2);
  let mid = txt.substring(start2, end2);
  let post = txt.substring(end2, txt.length);
  return [pre, mid, post];
};
var spliceIn = function(txt, offset2, index3) {
  let parts = split(txt, offset2, index3);
  return `${parts[0]}${color_default.blue(parts[1])}${parts[2]}`;
};
var showHighlight = function(doc) {
  if (!doc.found) {
    return;
  }
  let bySentence = {};
  doc.fullPointer.forEach((ptr) => {
    bySentence[ptr[0]] = bySentence[ptr[0]] || [];
    bySentence[ptr[0]].push(ptr);
  });
  Object.keys(bySentence).forEach((k2) => {
    let full = doc.update([[Number(k2)]]);
    let txt = full.text();
    let matches3 = doc.update(bySentence[k2]);
    let json = matches3.json({ offset: true });
    json.forEach((obj, i3) => {
      txt = spliceIn(txt, obj.offset, i3);
    });
    console.log(txt);
  });
};
var highlight_default = showHighlight;

// node_modules/compromise/src/1-one/output/api/debug/index.js
function isClientSide() {
  return typeof window !== "undefined" && window.document;
}
var debug = function(opts2 = {}) {
  let view = this;
  if (typeof opts2 === "string") {
    let tmp = {};
    tmp[opts2] = true;
    opts2 = tmp;
  }
  if (isClientSide()) {
    client_side_default(view);
    return view;
  }
  if (opts2.tags !== false) {
    tags_default(view);
    console.log("\n");
  }
  if (opts2.chunks === true) {
    chunks_default(view);
    console.log("\n");
  }
  if (opts2.highlight === true) {
    highlight_default(view);
    console.log("\n");
  }
  return view;
};
var debug_default = debug;

// node_modules/compromise/src/1-one/output/api/wrap.js
var toText = function(term) {
  let pre = term.pre || "";
  let post = term.post || "";
  return pre + term.text + post;
};
var findStarts = function(doc, obj) {
  let starts = {};
  Object.keys(obj).forEach((reg) => {
    let m3 = doc.match(reg);
    m3.fullPointer.forEach((a2) => {
      starts[a2[3]] = { fn: obj[reg], end: a2[2] };
    });
  });
  return starts;
};
var wrap = function(doc, obj) {
  let starts = findStarts(doc, obj);
  let text = "";
  doc.docs.forEach((terms, n3) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let t2 = terms[i3];
      if (starts.hasOwnProperty(t2.id)) {
        let { fn, end: end2 } = starts[t2.id];
        let m3 = doc.update([[n3, i3, end2]]);
        text += terms[i3].pre || "";
        text += fn(m3);
        i3 = end2 - 1;
        text += terms[i3].post || "";
      } else {
        text += toText(t2);
      }
    }
  });
  return text;
};
var wrap_default = wrap;

// node_modules/compromise/src/1-one/output/api/out.js
var isObject5 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var topk = function(arr) {
  let obj = {};
  arr.forEach((a2) => {
    obj[a2] = obj[a2] || 0;
    obj[a2] += 1;
  });
  let res = Object.keys(obj).map((k2) => {
    return { normal: k2, count: obj[k2] };
  });
  return res.sort((a2, b) => a2.count > b.count ? -1 : 0);
};
var out = function(method) {
  if (isObject5(method)) {
    return wrap_default(this, method);
  }
  if (method === "text") {
    return this.text();
  }
  if (method === "normal") {
    return this.text("normal");
  }
  if (method === "root") {
    return this.text("root");
  }
  if (method === "machine" || method === "reduced") {
    return this.text("machine");
  }
  if (method === "hash" || method === "md5") {
    return md5(this.text());
  }
  if (method === "json") {
    return this.json();
  }
  if (method === "offset" || method === "offsets") {
    this.compute("offset");
    return this.json({ offset: true });
  }
  if (method === "array") {
    let arr = this.docs.map((terms) => {
      return terms.reduce((str, t2) => {
        return str + t2.pre + t2.text + t2.post;
      }, "").trim();
    });
    return arr.filter((str) => str);
  }
  if (method === "freq" || method === "frequency" || method === "topk") {
    return topk(this.json({ normal: true }).map((o2) => o2.normal));
  }
  if (method === "terms") {
    let list4 = [];
    this.docs.forEach((s3) => {
      let terms = s3.terms.map((t2) => t2.text);
      terms = terms.filter((t2) => t2);
      list4 = list4.concat(terms);
    });
    return list4;
  }
  if (method === "tags") {
    return this.docs.map((terms) => {
      return terms.reduce((h2, t2) => {
        h2[t2.implicit || t2.normal] = Array.from(t2.tags);
        return h2;
      }, {});
    });
  }
  if (method === "debug") {
    return this.debug();
  }
  return this.text();
};
var methods12 = {
  debug: debug_default,
  out,
  wrap: function(obj) {
    return wrap_default(this, obj);
  }
};
var out_default = methods12;

// node_modules/compromise/src/1-one/output/api/text.js
var isObject6 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var text_default = {
  text: function(fmt2) {
    let opts2 = {};
    if (fmt2 && typeof fmt2 === "string" && fmts_default.hasOwnProperty(fmt2)) {
      opts2 = Object.assign({}, fmts_default[fmt2]);
    } else if (fmt2 && isObject6(fmt2)) {
      opts2 = Object.assign({}, fmt2);
    }
    if (opts2.keepSpace === void 0 && this.pointer) {
      opts2.keepSpace = false;
    }
    if (opts2.keepPunct === void 0 && this.pointer) {
      let ptr = this.pointer[0];
      if (ptr && ptr[1]) {
        opts2.keepPunct = false;
      } else {
        opts2.keepPunct = true;
      }
    }
    if (opts2.keepPunct === void 0) {
      opts2.keepPunct = true;
    }
    if (opts2.keepSpace === void 0) {
      opts2.keepSpace = true;
    }
    return textFromDoc(this.docs, opts2);
  }
};

// node_modules/compromise/src/1-one/output/api/index.js
var methods13 = Object.assign({}, out_default, text_default, json_default, html_default);
var addAPI3 = function(View2) {
  Object.assign(View2.prototype, methods13);
};
var api_default5 = addAPI3;

// node_modules/compromise/src/1-one/output/plugin.js
var plugin_default7 = {
  api: api_default5,
  methods: {
    one: {
      hash: md5
    }
  }
};

// node_modules/compromise/src/1-one/pointers/api/lib/_lib.js
var doesOverlap = function(a2, b) {
  if (a2[0] !== b[0]) {
    return false;
  }
  let [, startA, endA] = a2;
  let [, startB, endB] = b;
  if (startA <= startB && endA > startB) {
    return true;
  }
  if (startB <= startA && endB > startA) {
    return true;
  }
  return false;
};
var getExtent = function(ptrs) {
  let min2 = ptrs[0][1];
  let max3 = ptrs[0][2];
  ptrs.forEach((ptr) => {
    if (ptr[1] < min2) {
      min2 = ptr[1];
    }
    if (ptr[2] > max3) {
      max3 = ptr[2];
    }
  });
  return [ptrs[0][0], min2, max3];
};
var indexN = function(ptrs) {
  let byN = {};
  ptrs.forEach((ref) => {
    byN[ref[0]] = byN[ref[0]] || [];
    byN[ref[0]].push(ref);
  });
  return byN;
};
var uniquePtrs = function(arr) {
  let obj = {};
  for (let i3 = 0; i3 < arr.length; i3 += 1) {
    obj[arr[i3].join(",")] = arr[i3];
  }
  return Object.values(obj);
};

// node_modules/compromise/src/1-one/pointers/api/lib/split.js
var pivotBy = function(full, m3) {
  let [n3, start2] = full;
  let mStart = m3[1];
  let mEnd = m3[2];
  let res = {};
  if (start2 < mStart) {
    let end2 = mStart < full[2] ? mStart : full[2];
    res.before = [n3, start2, end2];
  }
  res.match = m3;
  if (full[2] > mEnd) {
    res.after = [n3, mEnd, full[2]];
  }
  return res;
};
var doesMatch2 = function(full, m3) {
  return full[1] <= m3[1] && m3[2] <= full[2];
};
var splitAll = function(full, m3) {
  let byN = indexN(m3);
  let res = [];
  full.forEach((ptr) => {
    let [n3] = ptr;
    let matches3 = byN[n3] || [];
    matches3 = matches3.filter((p4) => doesMatch2(ptr, p4));
    if (matches3.length === 0) {
      res.push({ passthrough: ptr });
      return;
    }
    matches3 = matches3.sort((a2, b) => a2[1] - b[1]);
    let carry = ptr;
    matches3.forEach((p4, i3) => {
      let found = pivotBy(carry, p4);
      if (!matches3[i3 + 1]) {
        res.push(found);
      } else {
        res.push({ before: found.before, match: found.match });
        if (found.after) {
          carry = found.after;
        }
      }
    });
  });
  return res;
};
var split_default2 = splitAll;

// node_modules/compromise/src/1-one/pointers/methods/getDoc.js
var max = 20;
var blindSweep = function(id, doc, n3) {
  for (let i3 = 0; i3 < max; i3 += 1) {
    if (doc[n3 - i3]) {
      let index3 = doc[n3 - i3].findIndex((term) => term.id === id);
      if (index3 !== -1) {
        return [n3 - i3, index3];
      }
    }
    if (doc[n3 + i3]) {
      let index3 = doc[n3 + i3].findIndex((term) => term.id === id);
      if (index3 !== -1) {
        return [n3 + i3, index3];
      }
    }
  }
  return null;
};
var repairEnding = function(ptr, document2) {
  let [n3, start2, , , endId] = ptr;
  let terms = document2[n3];
  let newEnd = terms.findIndex((t2) => t2.id === endId);
  if (newEnd === -1) {
    ptr[2] = document2[n3].length;
    ptr[4] = terms.length ? terms[terms.length - 1].id : null;
  } else {
    ptr[2] = newEnd;
  }
  return document2[n3].slice(start2, ptr[2] + 1);
};
var getDoc2 = function(ptrs, document2) {
  let doc = [];
  ptrs.forEach((ptr, i3) => {
    if (!ptr) {
      return;
    }
    let [n3, start2, end2, id, endId] = ptr;
    let terms = document2[n3] || [];
    if (start2 === void 0) {
      start2 = 0;
    }
    if (end2 === void 0) {
      end2 = terms.length;
    }
    if (id && (!terms[start2] || terms[start2].id !== id)) {
      let wild = blindSweep(id, document2, n3);
      if (wild !== null) {
        let len = end2 - start2;
        terms = document2[wild[0]].slice(wild[1], wild[1] + len);
        let startId = terms[0] ? terms[0].id : null;
        ptrs[i3] = [wild[0], wild[1], wild[1] + len, startId];
      }
    } else {
      terms = terms.slice(start2, end2);
    }
    if (terms.length === 0) {
      return;
    }
    if (start2 === end2) {
      return;
    }
    if (endId && terms[terms.length - 1].id !== endId) {
      terms = repairEnding(ptr, document2);
    }
    doc.push(terms);
  });
  doc = doc.filter((a2) => a2.length > 0);
  return doc;
};
var getDoc_default = getDoc2;

// node_modules/compromise/src/1-one/pointers/methods/index.js
var termList = function(docs) {
  let arr = [];
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t2 = 0; t2 < docs[i3].length; t2 += 1) {
      arr.push(docs[i3][t2]);
    }
  }
  return arr;
};
var methods_default5 = {
  one: {
    termList,
    getDoc: getDoc_default,
    pointer: {
      indexN,
      splitAll: split_default2
    }
  }
};

// node_modules/compromise/src/1-one/pointers/api/lib/union.js
var getUnion = function(a2, b) {
  let both = a2.concat(b);
  let byN = indexN(both);
  let res = [];
  both.forEach((ptr) => {
    let [n3] = ptr;
    if (byN[n3].length === 1) {
      res.push(ptr);
      return;
    }
    let hmm = byN[n3].filter((m3) => doesOverlap(ptr, m3));
    hmm.push(ptr);
    let range = getExtent(hmm);
    res.push(range);
  });
  res = uniquePtrs(res);
  return res;
};
var union_default = getUnion;

// node_modules/compromise/src/1-one/pointers/api/lib/difference.js
var subtract = function(refs, not) {
  let res = [];
  let found = split_default2(refs, not);
  found.forEach((o2) => {
    if (o2.passthrough) {
      res.push(o2.passthrough);
    }
    if (o2.before) {
      res.push(o2.before);
    }
    if (o2.after) {
      res.push(o2.after);
    }
  });
  return res;
};
var difference_default = subtract;

// node_modules/compromise/src/1-one/pointers/api/lib/intersection.js
var intersection = function(a2, b) {
  let start2 = a2[1] < b[1] ? b[1] : a2[1];
  let end2 = a2[2] > b[2] ? b[2] : a2[2];
  if (start2 < end2) {
    return [a2[0], start2, end2];
  }
  return null;
};
var getIntersection = function(a2, b) {
  let byN = indexN(b);
  let res = [];
  a2.forEach((ptr) => {
    let hmm = byN[ptr[0]] || [];
    hmm = hmm.filter((p4) => doesOverlap(ptr, p4));
    if (hmm.length === 0) {
      return;
    }
    hmm.forEach((h2) => {
      let overlap = intersection(ptr, h2);
      if (overlap) {
        res.push(overlap);
      }
    });
  });
  return res;
};
var intersection_default = getIntersection;

// node_modules/compromise/src/1-one/pointers/api/index.js
var isArray7 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var getDoc3 = (m3, view) => {
  if (typeof m3 === "string" || isArray7(m3)) {
    return view.match(m3);
  }
  if (!m3) {
    return view.none();
  }
  return m3;
};
var addIds3 = function(ptrs, docs) {
  return ptrs.map((ptr) => {
    let [n3, start2] = ptr;
    if (docs[n3] && docs[n3][start2]) {
      ptr[3] = docs[n3][start2].id;
    }
    return ptr;
  });
};
var methods14 = {};
methods14.union = function(m3) {
  m3 = getDoc3(m3, this);
  let ptrs = union_default(this.fullPointer, m3.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods14.and = methods14.union;
methods14.intersection = function(m3) {
  m3 = getDoc3(m3, this);
  let ptrs = intersection_default(this.fullPointer, m3.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods14.not = function(m3) {
  m3 = getDoc3(m3, this);
  let ptrs = difference_default(this.fullPointer, m3.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods14.difference = methods14.not;
methods14.complement = function() {
  let doc = this.all();
  let ptrs = difference_default(doc.fullPointer, this.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods14.settle = function() {
  let ptrs = this.fullPointer;
  ptrs.forEach((ptr) => {
    ptrs = union_default(ptrs, [ptr]);
  });
  ptrs = addIds3(ptrs, this.document);
  return this.update(ptrs);
};
var addAPI4 = function(View2) {
  Object.assign(View2.prototype, methods14);
};
var api_default6 = addAPI4;

// node_modules/compromise/src/1-one/pointers/plugin.js
var plugin_default8 = {
  methods: methods_default5,
  api: api_default6
};

// node_modules/compromise/src/1-one/sweep/lib.js
var lib_default3 = {
  buildNet: function(matches3) {
    const methods16 = this.methods();
    let net3 = methods16.one.buildNet(matches3, this.world());
    net3.isNet = true;
    return net3;
  }
};

// node_modules/compromise/src/1-one/sweep/api.js
var api = function(View2) {
  View2.prototype.sweep = function(net3, opts2 = {}) {
    const { world: world2, docs } = this;
    const { methods: methods16 } = world2;
    let found = methods16.one.bulkMatch(docs, net3, this.methods, opts2);
    if (opts2.tagger !== false) {
      methods16.one.bulkTagger(found, docs, this.world);
    }
    found = found.map((o2) => {
      let ptr = o2.pointer;
      let term = docs[ptr[0]][ptr[1]];
      let len = ptr[2] - ptr[1];
      if (term.index) {
        o2.pointer = [
          term.index[0],
          term.index[1],
          ptr[1] + len
        ];
      }
      return o2;
    });
    let ptrs = found.map((o2) => o2.pointer);
    found = found.map((obj) => {
      obj.view = this.update([obj.pointer]);
      delete obj.regs;
      delete obj.needs;
      delete obj.pointer;
      delete obj._expanded;
      return obj;
    });
    return {
      view: this.update(ptrs),
      found
    };
  };
};
var api_default7 = api;

// node_modules/compromise/src/1-one/sweep/methods/buildNet/01-parse.js
var getTokenNeeds = function(reg) {
  if (reg.optional === true || reg.negative === true) {
    return null;
  }
  if (reg.tag) {
    return "#" + reg.tag;
  }
  if (reg.word) {
    return reg.word;
  }
  if (reg.switch) {
    return `%${reg.switch}%`;
  }
  return null;
};
var getNeeds = function(regs) {
  let needs = [];
  regs.forEach((reg) => {
    needs.push(getTokenNeeds(reg));
    if (reg.operator === "and" && reg.choices) {
      reg.choices.forEach((oneSide) => {
        oneSide.forEach((r2) => {
          needs.push(getTokenNeeds(r2));
        });
      });
    }
  });
  return needs.filter((str) => str);
};
var getWants = function(regs) {
  let wants = [];
  let count = 0;
  regs.forEach((reg) => {
    if (reg.operator === "or" && !reg.optional && !reg.negative) {
      if (reg.fastOr) {
        Array.from(reg.fastOr).forEach((w) => {
          wants.push(w);
        });
      }
      if (reg.choices) {
        reg.choices.forEach((rs) => {
          rs.forEach((r2) => {
            let n3 = getTokenNeeds(r2);
            if (n3) {
              wants.push(n3);
            }
          });
        });
      }
      count += 1;
    }
  });
  return { wants, count };
};
var parse = function(matches3, world2) {
  const parseMatch = world2.methods.one.parseMatch;
  matches3.forEach((obj) => {
    obj.regs = parseMatch(obj.match, {}, world2);
    if (typeof obj.ifNo === "string") {
      obj.ifNo = [obj.ifNo];
    }
    if (obj.notIf) {
      obj.notIf = parseMatch(obj.notIf, {}, world2);
    }
    obj.needs = getNeeds(obj.regs);
    let { wants, count } = getWants(obj.regs);
    obj.wants = wants;
    obj.minWant = count;
    obj.minWords = obj.regs.filter((o2) => !o2.optional).length;
  });
  return matches3;
};
var parse_default = parse;

// node_modules/compromise/src/1-one/sweep/methods/buildNet/index.js
var buildNet = function(matches3, world2) {
  matches3 = parse_default(matches3, world2);
  let hooks2 = {};
  matches3.forEach((obj) => {
    obj.needs.forEach((str) => {
      hooks2[str] = hooks2[str] || [];
      hooks2[str].push(obj);
    });
    obj.wants.forEach((str) => {
      hooks2[str] = hooks2[str] || [];
      hooks2[str].push(obj);
    });
  });
  Object.keys(hooks2).forEach((k2) => {
    let already = {};
    hooks2[k2] = hooks2[k2].filter((obj) => {
      if (already[obj.match]) {
        return false;
      }
      already[obj.match] = true;
      return true;
    });
  });
  let always = matches3.filter((o2) => o2.needs.length === 0 && o2.wants.length === 0);
  return {
    hooks: hooks2,
    always
  };
};
var buildNet_default = buildNet;

// node_modules/compromise/src/1-one/sweep/methods/sweep/01-getHooks.js
var getHooks = function(docCaches, hooks2) {
  return docCaches.map((set, i3) => {
    let maybe = [];
    Object.keys(hooks2).forEach((k2) => {
      if (docCaches[i3].has(k2)) {
        maybe = maybe.concat(hooks2[k2]);
      }
    });
    let already = {};
    maybe = maybe.filter((m3) => {
      if (already[m3.match]) {
        return false;
      }
      already[m3.match] = true;
      return true;
    });
    return maybe;
  });
};
var getHooks_default = getHooks;

// node_modules/compromise/src/1-one/sweep/methods/sweep/02-trim-down.js
var localTrim = function(maybeList, docCache) {
  return maybeList.map((list4, n3) => {
    let haves = docCache[n3];
    list4 = list4.filter((obj) => {
      return obj.needs.every((need) => haves.has(need));
    });
    list4 = list4.filter((obj) => {
      if (obj.ifNo !== void 0 && obj.ifNo.some((no) => haves.has(no)) === true) {
        return false;
      }
      return true;
    });
    list4 = list4.filter((obj) => {
      if (obj.wants.length === 0) {
        return true;
      }
      let found = obj.wants.filter((str) => haves.has(str)).length;
      return found >= obj.minWant;
    });
    return list4;
  });
};
var trim_down_default = localTrim;

// node_modules/compromise/src/1-one/sweep/methods/sweep/04-runMatch.js
var runMatch2 = function(maybeList, document2, docCache, methods16, opts2) {
  let results = [];
  for (let n3 = 0; n3 < maybeList.length; n3 += 1) {
    for (let i3 = 0; i3 < maybeList[n3].length; i3 += 1) {
      let m3 = maybeList[n3][i3];
      let res = methods16.one.match([document2[n3]], m3);
      if (res.ptrs.length > 0) {
        res.ptrs.forEach((ptr) => {
          ptr[0] = n3;
          let todo = Object.assign({}, m3, { pointer: ptr });
          if (m3.unTag !== void 0) {
            todo.unTag = m3.unTag;
          }
          results.push(todo);
        });
        if (opts2.matchOne === true) {
          return [results[0]];
        }
      }
    }
  }
  return results;
};
var runMatch_default = runMatch2;

// node_modules/compromise/src/1-one/sweep/methods/sweep/index.js
var tooSmall = function(maybeList, document2) {
  return maybeList.map((arr, i3) => {
    let termCount = document2[i3].length;
    arr = arr.filter((o2) => {
      return termCount >= o2.minWords;
    });
    return arr;
  });
};
var sweep = function(document2, net3, methods16, opts2 = {}) {
  let docCache = methods16.one.cacheDoc(document2);
  let maybeList = getHooks_default(docCache, net3.hooks);
  maybeList = trim_down_default(maybeList, docCache, document2);
  if (net3.always.length > 0) {
    maybeList = maybeList.map((arr) => arr.concat(net3.always));
  }
  maybeList = tooSmall(maybeList, document2);
  let results = runMatch_default(maybeList, document2, docCache, methods16, opts2);
  return results;
};
var sweep_default = sweep;

// node_modules/compromise/src/1-one/sweep/methods/tagger/canBe.js
var canBe = function(terms, tag, model5) {
  let tagSet = model5.one.tagSet;
  if (!tagSet.hasOwnProperty(tag)) {
    return true;
  }
  let not = tagSet[tag].not || [];
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    let term = terms[i3];
    for (let k2 = 0; k2 < not.length; k2 += 1) {
      if (term.tags.has(not[k2]) === true) {
        return false;
      }
    }
  }
  return true;
};
var canBe_default = canBe;

// node_modules/compromise/src/1-one/sweep/methods/tagger/index.js
var tagger = function(list4, document2, world2) {
  const { model: model5, methods: methods16 } = world2;
  const { getDoc: getDoc4, setTag: setTag3, unTag: unTag2 } = methods16.one;
  const looksPlural2 = methods16.two.looksPlural;
  if (list4.length === 0) {
    return list4;
  }
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2.DEBUG_TAGS) {
    console.log(`

  \x1B[32m\u2192 ${list4.length} post-tagger:\x1B[0m`);
  }
  return list4.map((todo) => {
    if (!todo.tag && !todo.chunk && !todo.unTag) {
      return;
    }
    let reason = todo.reason || todo.match;
    let terms = getDoc4([todo.pointer], document2)[0];
    if (todo.safe === true) {
      if (canBe_default(terms, todo.tag, model5) === false) {
        return;
      }
      if (terms[terms.length - 1].post === "-") {
        return;
      }
    }
    if (todo.tag !== void 0) {
      setTag3(terms, todo.tag, world2, todo.safe, `[post] '${reason}'`);
      if (todo.tag === "Noun" && looksPlural2) {
        let term = terms[terms.length - 1];
        if (looksPlural2(term.text)) {
          setTag3([term], "Plural", world2, todo.safe, "quick-plural");
        } else {
          setTag3([term], "Singular", world2, todo.safe, "quick-singular");
        }
      }
    }
    if (todo.unTag !== void 0) {
      unTag2(terms, todo.unTag, world2, todo.safe, reason);
    }
    if (todo.chunk) {
      terms.forEach((t2) => t2.chunk = todo.chunk);
    }
  });
};
var tagger_default = tagger;

// node_modules/compromise/src/1-one/sweep/methods/index.js
var methods_default6 = {
  buildNet: buildNet_default,
  bulkMatch: sweep_default,
  bulkTagger: tagger_default
};

// node_modules/compromise/src/1-one/sweep/plugin.js
var plugin_default9 = {
  lib: lib_default3,
  api: api_default7,
  methods: {
    one: methods_default6
  }
};

// node_modules/compromise/src/1-one/tag/methods/setTag.js
var isMulti = / /;
var addChunk = function(term, tag) {
  if (tag === "Noun") {
    term.chunk = tag;
  }
  if (tag === "Verb") {
    term.chunk = tag;
  }
};
var tagTerm = function(term, tag, tagSet, isSafe) {
  if (term.tags.has(tag) === true) {
    return null;
  }
  if (tag === ".") {
    return null;
  }
  let known = tagSet[tag];
  if (known) {
    if (known.not && known.not.length > 0) {
      for (let o2 = 0; o2 < known.not.length; o2 += 1) {
        if (isSafe === true && term.tags.has(known.not[o2])) {
          return null;
        }
        term.tags.delete(known.not[o2]);
      }
    }
    if (known.parents && known.parents.length > 0) {
      for (let o2 = 0; o2 < known.parents.length; o2 += 1) {
        term.tags.add(known.parents[o2]);
        addChunk(term, known.parents[o2]);
      }
    }
  }
  term.tags.add(tag);
  term.dirty = true;
  addChunk(term, tag);
  return true;
};
var multiTag = function(terms, tagString2, tagSet, isSafe) {
  let tags = tagString2.split(isMulti);
  terms.forEach((term, i3) => {
    let tag = tags[i3];
    if (tag) {
      tag = tag.replace(/^#/, "");
      tagTerm(term, tag, tagSet, isSafe);
    }
  });
};
var isArray8 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var log = (terms, tag, reason = "") => {
  const yellow = (str) => "\x1B[33m\x1B[3m" + str + "\x1B[0m";
  const i3 = (str) => "\x1B[3m" + str + "\x1B[0m";
  let word = terms.map((t2) => {
    return t2.text || "[" + t2.implicit + "]";
  }).join(" ");
  if (typeof tag !== "string" && tag.length > 2) {
    tag = tag.slice(0, 2).join(", #") + " +";
  }
  tag = typeof tag !== "string" ? tag.join(", #") : tag;
  console.log(` ${yellow(word).padEnd(24)} \x1B[32m\u2192\x1B[0m #${tag.padEnd(22)}  ${i3(reason)}`);
};
var setTag = function(terms, tag, world2 = {}, isSafe, reason) {
  const tagSet = world2.model.one.tagSet || {};
  if (!tag) {
    return;
  }
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2 && env2.DEBUG_TAGS) {
    log(terms, tag, reason);
  }
  if (isArray8(tag) === true) {
    tag.forEach((tg) => setTag(terms, tg, world2, isSafe));
    return;
  }
  if (typeof tag !== "string") {
    console.warn(`compromise: Invalid tag '${tag}'`);
    return;
  }
  tag = tag.trim();
  if (isMulti.test(tag)) {
    multiTag(terms, tag, tagSet, isSafe);
    return;
  }
  tag = tag.replace(/^#/, "");
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    tagTerm(terms[i3], tag, tagSet, isSafe);
  }
};
var setTag_default = setTag;

// node_modules/compromise/src/1-one/tag/methods/unTag.js
var unTag = function(terms, tag, tagSet) {
  tag = tag.trim().replace(/^#/, "");
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    let term = terms[i3];
    if (tag === "*") {
      term.tags.clear();
      continue;
    }
    let known = tagSet[tag];
    if (known && known.children.length > 0) {
      for (let o2 = 0; o2 < known.children.length; o2 += 1) {
        term.tags.delete(known.children[o2]);
      }
    }
    term.tags.delete(tag);
  }
};
var unTag_default = unTag;

// node_modules/grad-school/builds/grad-school.mjs
var e = function(e2) {
  return e2.children = e2.children || [], e2._cache = e2._cache || {}, e2.props = e2.props || {}, e2._cache.parents = e2._cache.parents || [], e2._cache.children = e2._cache.children || [], e2;
};
var t = /^ *(#|\/\/)/;
var n = function(t2) {
  let n3 = t2.trim().split(/->/), r2 = [];
  n3.forEach((t3) => {
    r2 = r2.concat(function(t4) {
      if (!(t4 = t4.trim()))
        return null;
      if (/^\[/.test(t4) && /\]$/.test(t4)) {
        let n4 = (t4 = (t4 = t4.replace(/^\[/, "")).replace(/\]$/, "")).split(/,/);
        return n4 = n4.map((e2) => e2.trim()).filter((e2) => e2), n4 = n4.map((t5) => e({ id: t5 })), n4;
      }
      return [e({ id: t4 })];
    }(t3));
  }), r2 = r2.filter((e2) => e2);
  let i3 = r2[0];
  for (let e2 = 1; e2 < r2.length; e2 += 1)
    i3.children.push(r2[e2]), i3 = r2[e2];
  return r2[0];
};
var r = (e2, t2) => {
  let n3 = [], r2 = [e2];
  for (; r2.length > 0; ) {
    let e3 = r2.pop();
    n3.push(e3), e3.children && e3.children.forEach((n4) => {
      t2 && t2(e3, n4), r2.push(n4);
    });
  }
  return n3;
};
var i2 = (e2) => Object.prototype.toString.call(e2) === "[object Array]";
var c = (e2) => (e2 = e2 || "").trim();
var s = function(c2 = []) {
  return typeof c2 == "string" ? function(r2) {
    let i3 = r2.split(/\r?\n/), c3 = [];
    i3.forEach((e2) => {
      if (!e2.trim() || t.test(e2))
        return;
      let r3 = ((e3) => {
        const t2 = /^( {2}|\t)/;
        let n3 = 0;
        for (; t2.test(e3); )
          e3 = e3.replace(t2, ""), n3 += 1;
        return n3;
      })(e2);
      c3.push({ indent: r3, node: n(e2) });
    });
    let s4 = function(e2) {
      let t2 = { children: [] };
      return e2.forEach((n3, r3) => {
        n3.indent === 0 ? t2.children = t2.children.concat(n3.node) : e2[r3 - 1] && function(e3, t3) {
          let n4 = e3[t3].indent;
          for (; t3 >= 0; t3 -= 1)
            if (e3[t3].indent < n4)
              return e3[t3];
          return e3[0];
        }(e2, r3).node.children.push(n3.node);
      }), t2;
    }(c3);
    return s4 = e(s4), s4;
  }(c2) : i2(c2) ? function(t2) {
    let n3 = {};
    t2.forEach((e2) => {
      n3[e2.id] = e2;
    });
    let r2 = e({});
    return t2.forEach((t3) => {
      if ((t3 = e(t3)).parent)
        if (n3.hasOwnProperty(t3.parent)) {
          let e2 = n3[t3.parent];
          delete t3.parent, e2.children.push(t3);
        } else
          console.warn(`[Grad] - missing node '${t3.parent}'`);
      else
        r2.children.push(t3);
    }), r2;
  }(c2) : (r(s3 = c2).forEach(e), s3);
  var s3;
};
var h = (e2) => "\x1B[31m" + e2 + "\x1B[0m";
var o = (e2) => "\x1B[2m" + e2 + "\x1B[0m";
var l = function(e2, t2) {
  let n3 = "-> ";
  t2 && (n3 = o("\u2192 "));
  let i3 = "";
  return r(e2).forEach((e3, r2) => {
    let c2 = e3.id || "";
    if (t2 && (c2 = h(c2)), r2 === 0 && !e3.id)
      return;
    let s3 = e3._cache.parents.length;
    i3 += "    ".repeat(s3) + n3 + c2 + "\n";
  }), i3;
};
var a = function(e2) {
  let t2 = r(e2);
  t2.forEach((e3) => {
    delete (e3 = Object.assign({}, e3)).children;
  });
  let n3 = t2[0];
  return n3 && !n3.id && Object.keys(n3.props).length === 0 && t2.shift(), t2;
};
var p = { text: l, txt: l, array: a, flat: a };
var d = function(e2, t2) {
  return t2 === "nested" || t2 === "json" ? e2 : t2 === "debug" ? (console.log(l(e2, true)), null) : p.hasOwnProperty(t2) ? p[t2](e2) : e2;
};
var u = (e2) => {
  r(e2, (e3, t2) => {
    e3.id && (e3._cache.parents = e3._cache.parents || [], t2._cache.parents = e3._cache.parents.concat([e3.id]));
  });
};
var f = (e2, t2) => (Object.keys(t2).forEach((n3) => {
  if (t2[n3] instanceof Set) {
    let r2 = e2[n3] || /* @__PURE__ */ new Set();
    e2[n3] = /* @__PURE__ */ new Set([...r2, ...t2[n3]]);
  } else {
    if (((e3) => e3 && typeof e3 == "object" && !Array.isArray(e3))(t2[n3])) {
      let r2 = e2[n3] || {};
      e2[n3] = Object.assign({}, t2[n3], r2);
    } else
      i2(t2[n3]) ? e2[n3] = t2[n3].concat(e2[n3] || []) : e2[n3] === void 0 && (e2[n3] = t2[n3]);
  }
}), e2);
var j = /\//;
var g = class {
  constructor(e2 = {}) {
    Object.defineProperty(this, "json", { enumerable: false, value: e2, writable: true });
  }
  get children() {
    return this.json.children;
  }
  get id() {
    return this.json.id;
  }
  get found() {
    return this.json.id || this.json.children.length > 0;
  }
  props(e2 = {}) {
    let t2 = this.json.props || {};
    return typeof e2 == "string" && (t2[e2] = true), this.json.props = Object.assign(t2, e2), this;
  }
  get(t2) {
    if (t2 = c(t2), !j.test(t2)) {
      let e2 = this.json.children.find((e3) => e3.id === t2);
      return new g(e2);
    }
    let n3 = ((e2, t3) => {
      let n4 = ((e3) => typeof e3 != "string" ? e3 : (e3 = e3.replace(/^\//, "")).split(/\//))(t3 = t3 || "");
      for (let t4 = 0; t4 < n4.length; t4 += 1) {
        let r2 = e2.children.find((e3) => e3.id === n4[t4]);
        if (!r2)
          return null;
        e2 = r2;
      }
      return e2;
    })(this.json, t2) || e({});
    return new g(n3);
  }
  add(t2, n3 = {}) {
    if (i2(t2))
      return t2.forEach((e2) => this.add(c(e2), n3)), this;
    t2 = c(t2);
    let r2 = e({ id: t2, props: n3 });
    return this.json.children.push(r2), new g(r2);
  }
  remove(e2) {
    return e2 = c(e2), this.json.children = this.json.children.filter((t2) => t2.id !== e2), this;
  }
  nodes() {
    return r(this.json).map((e2) => (delete (e2 = Object.assign({}, e2)).children, e2));
  }
  cache() {
    return ((e2) => {
      let t2 = r(e2, (e3, t3) => {
        e3.id && (e3._cache.parents = e3._cache.parents || [], e3._cache.children = e3._cache.children || [], t3._cache.parents = e3._cache.parents.concat([e3.id]));
      }), n3 = {};
      t2.forEach((e3) => {
        e3.id && (n3[e3.id] = e3);
      }), t2.forEach((e3) => {
        e3._cache.parents.forEach((t3) => {
          n3.hasOwnProperty(t3) && n3[t3]._cache.children.push(e3.id);
        });
      }), e2._cache.children = Object.keys(n3);
    })(this.json), this;
  }
  list() {
    return r(this.json);
  }
  fillDown() {
    var e2;
    return e2 = this.json, r(e2, (e3, t2) => {
      t2.props = f(t2.props, e3.props);
    }), this;
  }
  depth() {
    u(this.json);
    let e2 = r(this.json), t2 = e2.length > 1 ? 1 : 0;
    return e2.forEach((e3) => {
      if (e3._cache.parents.length === 0)
        return;
      let n3 = e3._cache.parents.length + 1;
      n3 > t2 && (t2 = n3);
    }), t2;
  }
  out(e2) {
    return u(this.json), d(this.json, e2);
  }
  debug() {
    return u(this.json), d(this.json, "debug"), this;
  }
};
var _ = function(e2) {
  let t2 = s(e2);
  return new g(t2);
};
_.prototype.plugin = function(e2) {
  e2(this);
};

// node_modules/compromise/src/1-one/tag/methods/addTags/_colors.js
var colors = {
  Noun: "blue",
  Verb: "green",
  Negative: "green",
  Date: "red",
  Value: "red",
  Adjective: "magenta",
  Preposition: "cyan",
  Conjunction: "cyan",
  Determiner: "cyan",
  Hyphenated: "cyan",
  Adverb: "cyan"
};
var colors_default = colors;

// node_modules/compromise/src/1-one/tag/methods/addTags/02-fmt.js
var getColor = function(node) {
  if (colors_default.hasOwnProperty(node.id)) {
    return colors_default[node.id];
  }
  if (colors_default.hasOwnProperty(node.is)) {
    return colors_default[node.is];
  }
  let found = node._cache.parents.find((c2) => colors_default[c2]);
  return colors_default[found];
};
var fmt = function(nodes) {
  const res = {};
  nodes.forEach((node) => {
    let { not, also, is, novel } = node.props;
    let parents = node._cache.parents;
    if (also) {
      parents = parents.concat(also);
    }
    res[node.id] = {
      is,
      not,
      novel,
      also,
      parents,
      children: node._cache.children,
      color: getColor(node)
    };
  });
  Object.keys(res).forEach((k2) => {
    let nots = new Set(res[k2].not);
    res[k2].not.forEach((not) => {
      if (res[not]) {
        res[not].children.forEach((tag) => nots.add(tag));
      }
    });
    res[k2].not = Array.from(nots);
  });
  return res;
};
var fmt_default = fmt;

// node_modules/compromise/src/1-one/tag/methods/addTags/01-validate.js
var toArr = function(input) {
  if (!input) {
    return [];
  }
  if (typeof input === "string") {
    return [input];
  }
  return input;
};
var addImplied = function(tags, already) {
  Object.keys(tags).forEach((k2) => {
    if (tags[k2].isA) {
      tags[k2].is = tags[k2].isA;
    }
    if (tags[k2].notA) {
      tags[k2].not = tags[k2].notA;
    }
    if (tags[k2].is && typeof tags[k2].is === "string") {
      if (!already.hasOwnProperty(tags[k2].is) && !tags.hasOwnProperty(tags[k2].is)) {
        tags[tags[k2].is] = {};
      }
    }
    if (tags[k2].not && typeof tags[k2].not === "string" && !tags.hasOwnProperty(tags[k2].not)) {
      if (!already.hasOwnProperty(tags[k2].not) && !tags.hasOwnProperty(tags[k2].not)) {
        tags[tags[k2].not] = {};
      }
    }
  });
  return tags;
};
var validate = function(tags, already) {
  tags = addImplied(tags, already);
  Object.keys(tags).forEach((k2) => {
    tags[k2].children = toArr(tags[k2].children);
    tags[k2].not = toArr(tags[k2].not);
  });
  Object.keys(tags).forEach((k2) => {
    let nots = tags[k2].not || [];
    nots.forEach((no) => {
      if (tags[no] && tags[no].not) {
        tags[no].not.push(k2);
      }
    });
  });
  return tags;
};
var validate_default = validate;

// node_modules/compromise/src/1-one/tag/methods/addTags/index.js
var compute3 = function(allTags2) {
  const flatList = Object.keys(allTags2).map((k2) => {
    let o2 = allTags2[k2];
    const props = { not: new Set(o2.not), also: o2.also, is: o2.is, novel: o2.novel };
    return { id: k2, parent: o2.is, props, children: [] };
  });
  const graph = _(flatList).cache().fillDown();
  return graph.out("array");
};
var fromUser = function(tags) {
  Object.keys(tags).forEach((k2) => {
    tags[k2] = Object.assign({}, tags[k2]);
    tags[k2].novel = true;
  });
  return tags;
};
var addTags = function(tags, already) {
  if (Object.keys(already).length > 0) {
    tags = fromUser(tags);
  }
  tags = validate_default(tags, already);
  let allTags2 = Object.assign({}, already, tags);
  const nodes = compute3(allTags2);
  const res = fmt_default(nodes);
  return res;
};
var addTags_default = addTags;

// node_modules/compromise/src/1-one/tag/methods/index.js
var methods_default7 = {
  one: {
    setTag: setTag_default,
    unTag: unTag_default,
    addTags: addTags_default
  }
};

// node_modules/compromise/src/1-one/tag/api/tag.js
var isArray9 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var fns5 = {
  tag: function(input, reason = "", isSafe) {
    if (!this.found || !input) {
      return this;
    }
    let terms = this.termList();
    if (terms.length === 0) {
      return this;
    }
    const { methods: methods16, verbose: verbose2, world: world2 } = this;
    if (verbose2 === true) {
      console.log(" +  ", input, reason || "");
    }
    if (isArray9(input)) {
      input.forEach((tag) => methods16.one.setTag(terms, tag, world2, isSafe, reason));
    } else {
      methods16.one.setTag(terms, input, world2, isSafe, reason);
    }
    this.uncache();
    return this;
  },
  tagSafe: function(input, reason = "") {
    return this.tag(input, reason, true);
  },
  unTag: function(input, reason) {
    if (!this.found || !input) {
      return this;
    }
    let terms = this.termList();
    if (terms.length === 0) {
      return this;
    }
    const { methods: methods16, verbose: verbose2, model: model5 } = this;
    if (verbose2 === true) {
      console.log(" -  ", input, reason || "");
    }
    let tagSet = model5.one.tagSet;
    if (isArray9(input)) {
      input.forEach((tag) => methods16.one.unTag(terms, tag, tagSet));
    } else {
      methods16.one.unTag(terms, input, tagSet);
    }
    this.uncache();
    return this;
  },
  canBe: function(tag) {
    tag = tag.replace(/^#/, "");
    let tagSet = this.model.one.tagSet;
    if (!tagSet.hasOwnProperty(tag)) {
      return this;
    }
    let not = tagSet[tag].not || [];
    let nope2 = [];
    this.document.forEach((terms, n3) => {
      terms.forEach((term, i3) => {
        let found = not.find((no) => term.tags.has(no));
        if (found) {
          nope2.push([n3, i3, i3 + 1]);
        }
      });
    });
    let noDoc = this.update(nope2);
    return this.difference(noDoc);
  }
};
var tag_default = fns5;

// node_modules/compromise/src/1-one/tag/api/index.js
var tagAPI = function(View2) {
  Object.assign(View2.prototype, tag_default);
};
var api_default8 = tagAPI;

// node_modules/compromise/src/1-one/tag/lib.js
var addTags2 = function(tags) {
  const { model: model5, methods: methods16 } = this.world();
  const tagSet = model5.one.tagSet;
  const fn = methods16.one.addTags;
  let res = fn(tags, tagSet);
  model5.one.tagSet = res;
  return this;
};
var lib_default4 = { addTags: addTags2 };

// node_modules/compromise/src/1-one/tag/compute/tagRank.js
var boringTags = /* @__PURE__ */ new Set(["Auxiliary", "Possessive"]);
var sortByKids = function(tags, tagSet) {
  tags = tags.sort((a2, b) => {
    if (boringTags.has(a2) || !tagSet.hasOwnProperty(b)) {
      return 1;
    }
    if (boringTags.has(b) || !tagSet.hasOwnProperty(a2)) {
      return -1;
    }
    let kids = tagSet[a2].children || [];
    let aKids = kids.length;
    kids = tagSet[b].children || [];
    let bKids = kids.length;
    return aKids - bKids;
  });
  return tags;
};
var tagRank = function(view) {
  const { document: document2, world: world2 } = view;
  const tagSet = world2.model.one.tagSet;
  document2.forEach((terms) => {
    terms.forEach((term) => {
      let tags = Array.from(term.tags);
      term.tagRank = sortByKids(tags, tagSet);
    });
  });
};
var tagRank_default = tagRank;

// node_modules/compromise/src/1-one/tag/plugin.js
var plugin_default10 = {
  model: {
    one: { tagSet: {} }
  },
  compute: {
    tagRank: tagRank_default
  },
  methods: methods_default7,
  api: api_default8,
  lib: lib_default4
};

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/01-simple-split.js
var initSplit = /([.!?\u203D\u2E18\u203C\u2047-\u2049]+\s)/g;
var splitsOnly = /^[.!?\u203D\u2E18\u203C\u2047-\u2049]+\s$/;
var newLine = /((?:\r?\n|\r)+)/;
var basicSplit = function(text) {
  let all4 = [];
  let lines = text.split(newLine);
  for (let i3 = 0; i3 < lines.length; i3++) {
    let arr = lines[i3].split(initSplit);
    for (let o2 = 0; o2 < arr.length; o2++) {
      if (arr[o2 + 1] && splitsOnly.test(arr[o2 + 1]) === true) {
        arr[o2] += arr[o2 + 1];
        arr[o2 + 1] = "";
      }
      if (arr[o2] !== "") {
        all4.push(arr[o2]);
      }
    }
  }
  return all4;
};
var simple_split_default = basicSplit;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/02-simple-merge.js
var hasLetter = /[a-z0-9\u00C0-\u00FF\u00a9\u00ae\u2000-\u3300\ud000-\udfff]/i;
var hasSomething = /\S/;
var notEmpty = function(splits) {
  let chunks2 = [];
  for (let i3 = 0; i3 < splits.length; i3++) {
    let s3 = splits[i3];
    if (s3 === void 0 || s3 === "") {
      continue;
    }
    if (hasSomething.test(s3) === false || hasLetter.test(s3) === false) {
      if (chunks2[chunks2.length - 1]) {
        chunks2[chunks2.length - 1] += s3;
        continue;
      } else if (splits[i3 + 1]) {
        splits[i3 + 1] = s3 + splits[i3 + 1];
        continue;
      }
    }
    chunks2.push(s3);
  }
  return chunks2;
};
var simple_merge_default = notEmpty;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/03-smart-merge.js
var smartMerge = function(chunks2, world2) {
  const isSentence2 = world2.methods.one.tokenize.isSentence;
  const abbrevs = world2.model.one.abbreviations || /* @__PURE__ */ new Set();
  let sentences = [];
  for (let i3 = 0; i3 < chunks2.length; i3++) {
    let c2 = chunks2[i3];
    if (chunks2[i3 + 1] && isSentence2(c2, abbrevs) === false) {
      chunks2[i3 + 1] = c2 + (chunks2[i3 + 1] || "");
    } else if (c2 && c2.length > 0) {
      sentences.push(c2);
      chunks2[i3] = "";
    }
  }
  return sentences;
};
var smart_merge_default = smartMerge;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/04-quote-merge.js
var MAX_QUOTE = 280;
var pairs = {
  '"': '"',
  "\uFF02": "\uFF02",
  "\u201C": "\u201D",
  "\u201F": "\u201D",
  "\u201E": "\u201D",
  "\u2E42": "\u201D",
  "\u201A": "\u2019",
  "\xAB": "\xBB",
  "\u2039": "\u203A",
  "\u2035": "\u2032",
  "\u2036": "\u2033",
  "\u2037": "\u2034",
  "\u301D": "\u301E",
  "\u301F": "\u301E"
};
var openQuote = RegExp("(" + Object.keys(pairs).join("|") + ")", "g");
var closeQuote = RegExp("(" + Object.values(pairs).join("|") + ")", "g");
var closesQuote = function(str) {
  if (!str) {
    return false;
  }
  let m3 = str.match(closeQuote);
  if (m3 !== null && m3.length === 1) {
    return true;
  }
  return false;
};
var quoteMerge = function(splits) {
  let arr = [];
  for (let i3 = 0; i3 < splits.length; i3 += 1) {
    let split3 = splits[i3];
    let m3 = split3.match(openQuote);
    if (m3 !== null && m3.length === 1) {
      if (closesQuote(splits[i3 + 1]) && splits[i3 + 1].length < MAX_QUOTE) {
        splits[i3] += splits[i3 + 1];
        arr.push(splits[i3]);
        splits[i3 + 1] = "";
        i3 += 1;
        continue;
      }
      if (closesQuote(splits[i3 + 2])) {
        let toAdd = splits[i3 + 1] + splits[i3 + 2];
        if (toAdd.length < MAX_QUOTE) {
          splits[i3] += toAdd;
          arr.push(splits[i3]);
          splits[i3 + 1] = "";
          splits[i3 + 2] = "";
          i3 += 2;
          continue;
        }
      }
    }
    arr.push(splits[i3]);
  }
  return arr;
};
var quote_merge_default = quoteMerge;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/05-parens-merge.js
var MAX_LEN = 250;
var hasOpen = /\(/g;
var hasClosed = /\)/g;
var mergeParens = function(splits) {
  let arr = [];
  for (let i3 = 0; i3 < splits.length; i3 += 1) {
    let split3 = splits[i3];
    let m3 = split3.match(hasOpen);
    if (m3 !== null && m3.length === 1) {
      if (splits[i3 + 1] && splits[i3 + 1].length < MAX_LEN) {
        let m22 = splits[i3 + 1].match(hasClosed);
        if (m22 !== null && m3.length === 1 && !hasOpen.test(splits[i3 + 1])) {
          splits[i3] += splits[i3 + 1];
          arr.push(splits[i3]);
          splits[i3 + 1] = "";
          i3 += 1;
          continue;
        }
      }
    }
    arr.push(splits[i3]);
  }
  return arr;
};
var parens_merge_default = mergeParens;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/index.js
var hasSomething2 = /\S/;
var startWhitespace = /^\s+/;
var splitSentences = function(text, world2) {
  text = text || "";
  text = String(text);
  if (!text || typeof text !== "string" || hasSomething2.test(text) === false) {
    return [];
  }
  text = text.replace("\xA0", " ");
  let splits = simple_split_default(text);
  let sentences = simple_merge_default(splits);
  sentences = smart_merge_default(sentences, world2);
  sentences = quote_merge_default(sentences);
  sentences = parens_merge_default(sentences);
  if (sentences.length === 0) {
    return [text];
  }
  for (let i3 = 1; i3 < sentences.length; i3 += 1) {
    let ws = sentences[i3].match(startWhitespace);
    if (ws !== null) {
      sentences[i3 - 1] += ws[0];
      sentences[i3] = sentences[i3].replace(startWhitespace, "");
    }
  }
  return sentences;
};
var sentences_default = splitSentences;

// node_modules/compromise/src/1-one/tokenize/methods/02-terms/01-hyphens.js
var hasHyphen2 = function(str, model5) {
  let parts = str.split(/[-–—]/);
  if (parts.length <= 1) {
    return false;
  }
  const { prefixes: prefixes2, suffixes: suffixes6 } = model5.one;
  if (parts[0].length === 1 && /[a-z]/i.test(parts[0])) {
    return false;
  }
  if (prefixes2.hasOwnProperty(parts[0])) {
    return false;
  }
  parts[1] = parts[1].trim().replace(/[.?!]$/, "");
  if (suffixes6.hasOwnProperty(parts[1])) {
    return false;
  }
  let reg = /^([a-z\u00C0-\u00FF`"'/]+)[-–—]([a-z0-9\u00C0-\u00FF].*)/i;
  if (reg.test(str) === true) {
    return true;
  }
  let reg2 = /^([0-9]{1,4})[-–—]([a-z\u00C0-\u00FF`"'/-]+$)/i;
  if (reg2.test(str) === true) {
    return true;
  }
  return false;
};
var splitHyphens2 = function(word) {
  let arr = [];
  const hyphens = word.split(/[-–—]/);
  let whichDash = "-";
  let found = word.match(/[-–—]/);
  if (found && found[0]) {
    whichDash = found;
  }
  for (let o2 = 0; o2 < hyphens.length; o2++) {
    if (o2 === hyphens.length - 1) {
      arr.push(hyphens[o2]);
    } else {
      arr.push(hyphens[o2] + whichDash);
    }
  }
  return arr;
};

// node_modules/compromise/src/1-one/tokenize/methods/02-terms/03-ranges.js
var combineRanges = function(arr) {
  const startRange = /^[0-9]{1,4}(:[0-9][0-9])?([a-z]{1,2})? ?[-–—] ?$/;
  const endRange = /^[0-9]{1,4}([a-z]{1,2})? ?$/;
  for (let i3 = 0; i3 < arr.length - 1; i3 += 1) {
    if (arr[i3 + 1] && startRange.test(arr[i3]) && endRange.test(arr[i3 + 1])) {
      arr[i3] = arr[i3] + arr[i3 + 1];
      arr[i3 + 1] = null;
    }
  }
  return arr;
};
var ranges_default = combineRanges;

// node_modules/compromise/src/1-one/tokenize/methods/02-terms/02-slashes.js
var isSlash = /\p{L} ?\/ ?\p{L}+$/u;
var combineSlashes = function(arr) {
  for (let i3 = 1; i3 < arr.length - 1; i3++) {
    if (isSlash.test(arr[i3])) {
      arr[i3 - 1] += arr[i3] + arr[i3 + 1];
      arr[i3] = null;
      arr[i3 + 1] = null;
    }
  }
  return arr;
};
var slashes_default = combineSlashes;

// node_modules/compromise/src/1-one/tokenize/methods/02-terms/index.js
var wordlike = /\S/;
var isBoundary = /^[!?.]+$/;
var naiiveSplit = /(\S+)/;
var notWord = [".", "?", "!", ":", ";", "-", "\u2013", "\u2014", "--", "...", "(", ")", "[", "]", '"', "'", "`", "\xAB", "\xBB", "*"];
notWord = notWord.reduce((h2, c2) => {
  h2[c2] = true;
  return h2;
}, {});
var isArray10 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var splitWords = function(str, model5) {
  let result = [];
  let arr = [];
  str = str || "";
  if (typeof str === "number") {
    str = String(str);
  }
  if (isArray10(str)) {
    return str;
  }
  const words = str.split(naiiveSplit);
  for (let i3 = 0; i3 < words.length; i3++) {
    if (hasHyphen2(words[i3], model5) === true) {
      arr = arr.concat(splitHyphens2(words[i3]));
      continue;
    }
    arr.push(words[i3]);
  }
  let carry = "";
  for (let i3 = 0; i3 < arr.length; i3++) {
    let word = arr[i3];
    if (wordlike.test(word) === true && notWord.hasOwnProperty(word) === false && isBoundary.test(word) === false) {
      if (result.length > 0) {
        result[result.length - 1] += carry;
        result.push(word);
      } else {
        result.push(carry + word);
      }
      carry = "";
    } else {
      carry += word;
    }
  }
  if (carry) {
    if (result.length === 0) {
      result[0] = "";
    }
    result[result.length - 1] += carry;
  }
  result = slashes_default(result);
  result = ranges_default(result);
  result = result.filter((s3) => s3);
  return result;
};
var terms_default = splitWords;

// node_modules/compromise/src/1-one/tokenize/methods/03-whitespace/tokenize.js
var isLetter = /\p{Letter}/u;
var isNumber = /[\p{Number}\p{Currency_Symbol}]/u;
var hasAcronym = /^[a-z]\.([a-z]\.)+/i;
var chillin = /[sn]['’]$/;
var normalizePunctuation = function(str, model5) {
  let { prePunctuation: prePunctuation2, postPunctuation: postPunctuation2, emoticons: emoticons2 } = model5.one;
  let original = str;
  let pre = "";
  let post = "";
  let chars = Array.from(str);
  if (emoticons2.hasOwnProperty(str.trim())) {
    return { str: str.trim(), pre, post: " " };
  }
  let len = chars.length;
  for (let i3 = 0; i3 < len; i3 += 1) {
    let c2 = chars[0];
    if (prePunctuation2[c2] === true) {
      continue;
    }
    if ((c2 === "+" || c2 === "-") && isNumber.test(chars[1])) {
      break;
    }
    if (c2 === "'" && c2.length === 3 && isNumber.test(chars[1])) {
      break;
    }
    if (isLetter.test(c2) || isNumber.test(c2)) {
      break;
    }
    pre += chars.shift();
  }
  len = chars.length;
  for (let i3 = 0; i3 < len; i3 += 1) {
    let c2 = chars[chars.length - 1];
    if (postPunctuation2[c2] === true) {
      continue;
    }
    if (isLetter.test(c2) || isNumber.test(c2)) {
      break;
    }
    if (c2 === "." && hasAcronym.test(original) === true) {
      continue;
    }
    if (c2 === "'" && chillin.test(original) === true) {
      continue;
    }
    post = chars.pop() + post;
  }
  str = chars.join("");
  if (str === "") {
    original = original.replace(/ *$/, (after2) => {
      post = after2 || "";
      return "";
    });
    str = original;
    pre = "";
  }
  return { str, pre, post };
};
var tokenize_default = normalizePunctuation;

// node_modules/compromise/src/1-one/tokenize/methods/03-whitespace/index.js
var parseTerm = (txt, model5) => {
  let { str, pre, post } = tokenize_default(txt, model5);
  const parsed = {
    text: str,
    pre,
    post,
    tags: /* @__PURE__ */ new Set()
  };
  return parsed;
};
var whitespace_default2 = parseTerm;

// node_modules/compromise/src/1-one/tokenize/methods/unicode.js
var killUnicode = function(str, world2) {
  const unicode2 = world2.model.one.unicode || {};
  str = str || "";
  let chars = str.split("");
  chars.forEach((s3, i3) => {
    if (unicode2[s3]) {
      chars[i3] = unicode2[s3];
    }
  });
  return chars.join("");
};
var unicode_default = killUnicode;

// node_modules/compromise/src/1-one/tokenize/compute/normal/01-cleanup.js
var clean = function(str) {
  str = str || "";
  str = str.toLowerCase();
  str = str.trim();
  let original = str;
  str = str.replace(/[,;.!?]+$/, "");
  str = str.replace(/\u2026/g, "...");
  str = str.replace(/\u2013/g, "-");
  if (/^[:;]/.test(str) === false) {
    str = str.replace(/\.{3,}$/g, "");
    str = str.replace(/[",.!:;?)]+$/g, "");
    str = str.replace(/^['"(]+/g, "");
  }
  str = str.replace(/[\u200B-\u200D\uFEFF]/g, "");
  str = str.trim();
  if (str === "") {
    str = original;
  }
  str = str.replace(/([0-9]),([0-9])/g, "$1$2");
  return str;
};
var cleanup_default = clean;

// node_modules/compromise/src/1-one/tokenize/compute/normal/02-acronyms.js
var periodAcronym = /([A-Z]\.)+[A-Z]?,?$/;
var oneLetterAcronym = /^[A-Z]\.,?$/;
var noPeriodAcronym = /[A-Z]{2,}('s|,)?$/;
var lowerCaseAcronym = /([a-z]\.)+[a-z]\.?$/;
var isAcronym = function(str) {
  if (periodAcronym.test(str) === true) {
    return true;
  }
  if (lowerCaseAcronym.test(str) === true) {
    return true;
  }
  if (oneLetterAcronym.test(str) === true) {
    return true;
  }
  if (noPeriodAcronym.test(str) === true) {
    return true;
  }
  return false;
};
var doAcronym = function(str) {
  if (isAcronym(str)) {
    str = str.replace(/\./g, "");
  }
  return str;
};
var acronyms_default = doAcronym;

// node_modules/compromise/src/1-one/tokenize/compute/normal/index.js
var normalize = function(term, world2) {
  const killUnicode2 = world2.methods.one.killUnicode;
  let str = term.text || "";
  str = cleanup_default(str);
  str = killUnicode2(str, world2);
  str = acronyms_default(str);
  term.normal = str;
};
var normal_default = normalize;

// node_modules/compromise/src/1-one/tokenize/methods/parse.js
var parse2 = function(input, world2) {
  const { methods: methods16, model: model5 } = world2;
  const { splitSentences: splitSentences2, splitTerms, splitWhitespace } = methods16.one.tokenize;
  input = input || "";
  let sentences = splitSentences2(input, world2);
  input = sentences.map((txt) => {
    let terms = splitTerms(txt, model5);
    terms = terms.map((t2) => splitWhitespace(t2, model5));
    terms.forEach((t2) => {
      normal_default(t2, world2);
    });
    return terms;
  });
  return input;
};
var parse_default2 = parse2;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/is-sentence.js
var isAcronym2 = /[ .][A-Z]\.? *$/i;
var hasEllipse = /(?:\u2026|\.{2,}) *$/;
var hasLetter2 = /\p{L}/u;
var leadInit = /^[A-Z]\. $/;
var isSentence = function(str, abbrevs) {
  if (hasLetter2.test(str) === false) {
    return false;
  }
  if (isAcronym2.test(str) === true) {
    return false;
  }
  if (str.length === 3 && leadInit.test(str)) {
    return false;
  }
  if (hasEllipse.test(str) === true) {
    return false;
  }
  let txt = str.replace(/[.!?\u203D\u2E18\u203C\u2047-\u2049] *$/, "");
  let words = txt.split(" ");
  let lastWord = words[words.length - 1].toLowerCase();
  if (abbrevs.hasOwnProperty(lastWord) === true) {
    return false;
  }
  return true;
};
var is_sentence_default = isSentence;

// node_modules/compromise/src/1-one/tokenize/methods/index.js
var methods_default8 = {
  one: {
    killUnicode: unicode_default,
    tokenize: {
      splitSentences: sentences_default,
      isSentence: is_sentence_default,
      splitTerms: terms_default,
      splitWhitespace: whitespace_default2,
      fromString: parse_default2
    }
  }
};

// node_modules/compromise/src/1-one/tokenize/model/aliases.js
var aliases = {
  "&": "and",
  "@": "at",
  "%": "percent",
  "plz": "please",
  "bein": "being"
};
var aliases_default = aliases;

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/misc.js
var misc_default = [
  "approx",
  "apt",
  "bc",
  "cyn",
  "eg",
  "esp",
  "est",
  "etc",
  "ex",
  "exp",
  "prob",
  "pron",
  "gal",
  "min",
  "pseud",
  "fig",
  "jd",
  "lat",
  "lng",
  "vol",
  "fm",
  "def",
  "misc",
  "plz",
  "ea",
  "ps",
  "sec",
  "pt",
  "pref",
  "pl",
  "pp",
  "qt",
  "fr",
  "sq",
  "nee",
  "ss",
  "tel",
  "temp",
  "vet",
  "ver",
  "fem",
  "masc",
  "eng",
  "adj",
  "vb",
  "rb",
  "inf",
  "situ",
  "vivo",
  "vitro",
  "wr"
];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/honorifics.js
var honorifics_default = [
  "adj",
  "adm",
  "adv",
  "asst",
  "atty",
  "bldg",
  "brig",
  "capt",
  "cmdr",
  "comdr",
  "cpl",
  "det",
  "dr",
  "esq",
  "gen",
  "gov",
  "hon",
  "jr",
  "llb",
  "lt",
  "maj",
  "messrs",
  "mlle",
  "mme",
  "mr",
  "mrs",
  "ms",
  "mstr",
  "phd",
  "prof",
  "pvt",
  "rep",
  "reps",
  "res",
  "rev",
  "sen",
  "sens",
  "sfc",
  "sgt",
  "sir",
  "sr",
  "supt",
  "surg"
];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/months.js
var months_default = ["jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "sept", "oct", "nov", "dec"];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/nouns.js
var nouns_default = [
  "ad",
  "al",
  "arc",
  "ba",
  "bl",
  "ca",
  "cca",
  "col",
  "corp",
  "ft",
  "fy",
  "ie",
  "lit",
  "ma",
  "md",
  "pd",
  "tce"
];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/organizations.js
var organizations_default = ["dept", "univ", "assn", "bros", "inc", "ltd", "co"];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/places.js
var places_default = [
  "rd",
  "st",
  "dist",
  "mt",
  "ave",
  "blvd",
  "cl",
  "cres",
  "hwy",
  "ariz",
  "cal",
  "calif",
  "colo",
  "conn",
  "fla",
  "fl",
  "ga",
  "ida",
  "ia",
  "kan",
  "kans",
  "minn",
  "neb",
  "nebr",
  "okla",
  "penna",
  "penn",
  "pa",
  "dak",
  "tenn",
  "tex",
  "ut",
  "vt",
  "va",
  "wis",
  "wisc",
  "wy",
  "wyo",
  "usafa",
  "alta",
  "ont",
  "que",
  "sask"
];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/units.js
var units_default = [
  "dl",
  "ml",
  "gal",
  "qt",
  "pt",
  "tbl",
  "tsp",
  "tbsp",
  "km",
  "dm",
  "cm",
  "mm",
  "mi",
  "td",
  "hr",
  "hrs",
  "kg",
  "hg",
  "dg",
  "cg",
  "mg",
  "\xB5g",
  "lb",
  "oz",
  "sq ft",
  "hz",
  "mps",
  "mph",
  "kmph",
  "kb",
  "mb",
  "tb",
  "lx",
  "lm",
  "fl oz",
  "yb"
];

// node_modules/compromise/src/1-one/tokenize/model/lexicon.js
var list = [
  [misc_default],
  [units_default, "Unit"],
  [nouns_default, "Noun"],
  [honorifics_default, "Honorific"],
  [months_default, "Month"],
  [organizations_default, "Organization"],
  [places_default, "Place"]
];
var abbreviations = {};
var lexicon2 = {};
list.forEach((a2) => {
  a2[0].forEach((w) => {
    abbreviations[w] = true;
    lexicon2[w] = "Abbreviation";
    if (a2[1] !== void 0) {
      lexicon2[w] = [lexicon2[w], a2[1]];
    }
  });
});

// node_modules/compromise/src/1-one/tokenize/model/prefixes.js
var prefixes_default = [
  "anti",
  "bi",
  "co",
  "contra",
  "de",
  "extra",
  "infra",
  "inter",
  "intra",
  "macro",
  "micro",
  "mis",
  "mono",
  "multi",
  "peri",
  "pre",
  "pro",
  "proto",
  "pseudo",
  "re",
  "sub",
  "supra",
  "trans",
  "tri",
  "un",
  "out",
  "ex"
].reduce((h2, str) => {
  h2[str] = true;
  return h2;
}, {});

// node_modules/compromise/src/1-one/tokenize/model/suffixes.js
var suffixes_default = {
  "like": true,
  "ish": true,
  "less": true,
  "able": true,
  "elect": true,
  "type": true,
  "designate": true
};

// node_modules/compromise/src/1-one/tokenize/model/unicode.js
var compact = {
  "!": "\xA1",
  "?": "\xBF\u0241",
  '"': '\u201C\u201D"\u275D\u275E',
  "'": "\u2018\u201B\u275B\u275C\u2019",
  "-": "\u2014\u2013",
  a: "\xAA\xC0\xC1\xC2\xC3\xC4\xC5\xE0\xE1\xE2\xE3\xE4\xE5\u0100\u0101\u0102\u0103\u0104\u0105\u01CD\u01CE\u01DE\u01DF\u01E0\u01E1\u01FA\u01FB\u0200\u0201\u0202\u0203\u0226\u0227\u023A\u0386\u0391\u0394\u039B\u03AC\u03B1\u03BB\u0410\u0430\u0466\u0467\u04D0\u04D1\u04D2\u04D3\u019B\xE6",
  b: "\xDF\xFE\u0180\u0181\u0182\u0183\u0184\u0185\u0243\u0392\u03B2\u03D0\u03E6\u0411\u0412\u042A\u042C\u0432\u044A\u044C\u0462\u0463\u048C\u048D",
  c: "\xA2\xA9\xC7\xE7\u0106\u0107\u0108\u0109\u010A\u010B\u010C\u010D\u0186\u0187\u0188\u023B\u023C\u037B\u037C\u03F2\u03F9\u03FD\u03FE\u0421\u0441\u0454\u0480\u0481\u04AA\u04AB",
  d: "\xD0\u010E\u010F\u0110\u0111\u0189\u018A\u0221\u018B\u018C",
  e: "\xC8\xC9\xCA\xCB\xE8\xE9\xEA\xEB\u0112\u0113\u0114\u0115\u0116\u0117\u0118\u0119\u011A\u011B\u0190\u0204\u0205\u0206\u0207\u0228\u0229\u0246\u0247\u0388\u0395\u039E\u03A3\u03AD\u03B5\u03BE\u03F5\u0400\u0401\u0415\u0435\u0450\u0451\u04BC\u04BD\u04BE\u04BF\u04D6\u04D7",
  f: "\u0191\u0192\u03DC\u03DD\u04FA\u04FB\u0492\u0493\u017F",
  g: "\u011C\u011D\u011E\u011F\u0120\u0121\u0122\u0123\u0193\u01E4\u01E5\u01E6\u01E7\u01F4\u01F5",
  h: "\u0124\u0125\u0126\u0127\u0195\u01F6\u021E\u021F\u0389\u0397\u0402\u040A\u040B\u041D\u043D\u0452\u045B\u04A2\u04A3\u04A4\u04A5\u04BA\u04BB\u04C9\u04CA",
  I: "\xCC\xCD\xCE\xCF",
  i: "\xEC\xED\xEE\xEF\u0128\u0129\u012A\u012B\u012C\u012D\u012E\u012F\u0130\u0131\u0196\u0197\u0208\u0209\u020A\u020B\u038A\u0390\u03AA\u03AF\u03B9\u03CA\u0406\u0407\u0456\u0457",
  j: "\u0134\u0135\u01F0\u0237\u0248\u0249\u03F3\u0408\u0458",
  k: "\u0136\u0137\u0138\u0198\u0199\u01E8\u01E9\u039A\u03BA\u040C\u0416\u041A\u0436\u043A\u045C\u049A\u049B\u049C\u049D\u049E\u049F\u04A0\u04A1",
  l: "\u0139\u013A\u013B\u013C\u013D\u013E\u013F\u0140\u0141\u0142\u019A\u01AA\u01C0\u01CF\u01D0\u0234\u023D\u0399\u04C0\u04CF",
  m: "\u039C\u03FA\u03FB\u041C\u043C\u04CD\u04CE",
  n: "\xD1\xF1\u0143\u0144\u0145\u0146\u0147\u0148\u0149\u014A\u014B\u019D\u019E\u01F8\u01F9\u0220\u0235\u039D\u03A0\u03AE\u03B7\u03DE\u040D\u0418\u0419\u041B\u041F\u0438\u0439\u043B\u043F\u045D\u048A\u048B\u04C5\u04C6\u04E2\u04E3\u04E4\u04E5\u03C0",
  o: "\xD2\xD3\xD4\xD5\xD6\xD8\xF0\xF2\xF3\xF4\xF5\xF6\xF8\u014C\u014D\u014E\u014F\u0150\u0151\u019F\u01A0\u01A1\u01D1\u01D2\u01EA\u01EB\u01EC\u01ED\u01FE\u01FF\u020C\u020D\u020E\u020F\u022A\u022B\u022C\u022D\u022E\u022F\u0230\u0231\u038C\u0398\u039F\u03B8\u03BF\u03C3\u03CC\u03D5\u03D8\u03D9\u03EC\u03F4\u041E\u0424\u043E\u0472\u0473\u04E6\u04E7\u04E8\u04E9\u04EA\u04EB",
  p: "\u01A4\u03A1\u03C1\u03F7\u03F8\u03FC\u0420\u0440\u048E\u048F\xDE",
  q: "\u024A\u024B",
  r: "\u0154\u0155\u0156\u0157\u0158\u0159\u01A6\u0210\u0211\u0212\u0213\u024C\u024D\u0403\u0413\u042F\u0433\u044F\u0453\u0490\u0491",
  s: "\u015A\u015B\u015C\u015D\u015E\u015F\u0160\u0161\u01A7\u01A8\u0218\u0219\u023F\u0405\u0455",
  t: "\u0162\u0163\u0164\u0165\u0166\u0167\u01AB\u01AC\u01AD\u01AE\u021A\u021B\u0236\u023E\u0393\u03A4\u03C4\u03EE\u0422\u0442",
  u: "\xD9\xDA\xDB\xDC\xF9\xFA\xFB\xFC\u0168\u0169\u016A\u016B\u016C\u016D\u016E\u016F\u0170\u0171\u0172\u0173\u01AF\u01B0\u01B1\u01B2\u01D3\u01D4\u01D5\u01D6\u01D7\u01D8\u01D9\u01DA\u01DB\u01DC\u0214\u0215\u0216\u0217\u0244\u03B0\u03C5\u03CB\u03CD",
  v: "\u03BD\u0474\u0475\u0476\u0477",
  w: "\u0174\u0175\u019C\u03C9\u03CE\u03D6\u03E2\u03E3\u0428\u0429\u0448\u0449\u0461\u047F",
  x: "\xD7\u03A7\u03C7\u03D7\u03F0\u0425\u0445\u04B2\u04B3\u04FC\u04FD\u04FE\u04FF",
  y: "\xDD\xFD\xFF\u0176\u0177\u0178\u01B3\u01B4\u0232\u0233\u024E\u024F\u038E\u03A5\u03AB\u03B3\u03C8\u03D2\u03D3\u03D4\u040E\u0423\u0443\u0447\u045E\u0470\u0471\u04AE\u04AF\u04B0\u04B1\u04EE\u04EF\u04F0\u04F1\u04F2\u04F3",
  z: "\u0179\u017A\u017B\u017C\u017D\u017E\u01B5\u01B6\u0224\u0225\u0240\u0396"
};
var unicode = {};
Object.keys(compact).forEach(function(k2) {
  compact[k2].split("").forEach(function(s3) {
    unicode[s3] = k2;
  });
});
var unicode_default2 = unicode;

// node_modules/compromise/src/1-one/tokenize/model/punctuation.js
var prePunctuation = {
  "#": true,
  "@": true,
  "_": true,
  "\xB0": true,
  "\u200B": true,
  "\u200C": true,
  "\u200D": true,
  "\uFEFF": true
};
var postPunctuation = {
  "%": true,
  "_": true,
  "\xB0": true,
  "\u200B": true,
  "\u200C": true,
  "\u200D": true,
  "\uFEFF": true
};
var emoticons = {
  "<3": true,
  "</3": true,
  "<\\3": true,
  ":^P": true,
  ":^p": true,
  ":^O": true,
  ":^3": true
};

// node_modules/compromise/src/1-one/tokenize/model/index.js
var model_default2 = {
  one: {
    aliases: aliases_default,
    abbreviations,
    prefixes: prefixes_default,
    suffixes: suffixes_default,
    prePunctuation,
    postPunctuation,
    lexicon: lexicon2,
    unicode: unicode_default2,
    emoticons
  }
};

// node_modules/compromise/src/1-one/tokenize/compute/alias.js
var hasSlash = /\//;
var hasDomain = /[a-z]\.[a-z]/i;
var isMath = /[0-9]/;
var addAliases = function(term, world2) {
  let str = term.normal || term.text || term.machine;
  const aliases3 = world2.model.one.aliases;
  if (aliases3.hasOwnProperty(str)) {
    term.alias = term.alias || [];
    term.alias.push(aliases3[str]);
  }
  if (hasSlash.test(str) && !hasDomain.test(str) && !isMath.test(str)) {
    let arr = str.split(hasSlash);
    if (arr.length <= 2) {
      arr.forEach((word) => {
        word = word.trim();
        if (word !== "") {
          term.alias = term.alias || [];
          term.alias.push(word);
        }
      });
    }
  }
  return term;
};
var alias_default = addAliases;

// node_modules/compromise/src/1-one/tokenize/compute/machine.js
var hasDash3 = /^\p{Letter}+-\p{Letter}+$/u;
var doMachine = function(term) {
  let str = term.implicit || term.normal || term.text;
  str = str.replace(/['’]s$/, "");
  str = str.replace(/s['’]$/, "s");
  str = str.replace(/([aeiou][ktrp])in'$/, "$1ing");
  if (hasDash3.test(str)) {
    str = str.replace(/-/g, "");
  }
  str = str.replace(/^[#@]/, "");
  if (str !== term.normal) {
    term.machine = str;
  }
};
var machine_default = doMachine;

// node_modules/compromise/src/1-one/tokenize/compute/freq.js
var freq = function(view) {
  let docs = view.docs;
  let counts = {};
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t2 = 0; t2 < docs[i3].length; t2 += 1) {
      let term = docs[i3][t2];
      let word = term.machine || term.normal;
      counts[word] = counts[word] || 0;
      counts[word] += 1;
    }
  }
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t2 = 0; t2 < docs[i3].length; t2 += 1) {
      let term = docs[i3][t2];
      let word = term.machine || term.normal;
      term.freq = counts[word];
    }
  }
};
var freq_default = freq;

// node_modules/compromise/src/1-one/tokenize/compute/offset.js
var offset = function(view) {
  let elapsed = 0;
  let index3 = 0;
  let docs = view.document;
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t2 = 0; t2 < docs[i3].length; t2 += 1) {
      let term = docs[i3][t2];
      term.offset = {
        index: index3,
        start: elapsed + term.pre.length,
        length: term.text.length
      };
      elapsed += term.pre.length + term.text.length + term.post.length;
      index3 += 1;
    }
  }
};
var offset_default = offset;

// node_modules/compromise/src/1-one/tokenize/compute/reindex.js
var index2 = function(view) {
  let document2 = view.document;
  for (let n3 = 0; n3 < document2.length; n3 += 1) {
    for (let i3 = 0; i3 < document2[n3].length; i3 += 1) {
      document2[n3][i3].index = [n3, i3];
    }
  }
};
var reindex_default = index2;

// node_modules/compromise/src/1-one/tokenize/compute/wordCount.js
var wordCount2 = function(view) {
  let n3 = 0;
  let docs = view.docs;
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t2 = 0; t2 < docs[i3].length; t2 += 1) {
      if (docs[i3][t2].normal === "") {
        continue;
      }
      n3 += 1;
      docs[i3][t2].wordCount = n3;
    }
  }
};
var wordCount_default = wordCount2;

// node_modules/compromise/src/1-one/tokenize/compute/index.js
var termLoop = function(view, fn) {
  let docs = view.docs;
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t2 = 0; t2 < docs[i3].length; t2 += 1) {
      fn(docs[i3][t2], view.world);
    }
  }
};
var methods15 = {
  alias: (view) => termLoop(view, alias_default),
  machine: (view) => termLoop(view, machine_default),
  normal: (view) => termLoop(view, normal_default),
  freq: freq_default,
  offset: offset_default,
  index: reindex_default,
  wordCount: wordCount_default
};
var compute_default6 = methods15;

// node_modules/compromise/src/1-one/tokenize/plugin.js
var plugin_default11 = {
  compute: compute_default6,
  methods: methods_default8,
  model: model_default2,
  hooks: ["alias", "machine", "index", "id"]
};

// node_modules/compromise/src/1-one/typeahead/compute.js
var typeahead = function(view) {
  const prefixes2 = view.model.one.typeahead;
  const docs = view.docs;
  if (docs.length === 0 || Object.keys(prefixes2).length === 0) {
    return;
  }
  let lastPhrase = docs[docs.length - 1] || [];
  let lastTerm = lastPhrase[lastPhrase.length - 1];
  if (lastTerm.post) {
    return;
  }
  if (prefixes2.hasOwnProperty(lastTerm.normal)) {
    let found = prefixes2[lastTerm.normal];
    lastTerm.implicit = found;
    lastTerm.machine = found;
    lastTerm.typeahead = true;
    if (view.compute.preTagger) {
      view.last().unTag("*").compute(["lexicon", "preTagger"]);
    }
  }
};
var compute_default7 = { typeahead };

// node_modules/compromise/src/1-one/typeahead/api.js
var autoFill = function() {
  const docs = this.docs;
  if (docs.length === 0) {
    return this;
  }
  let lastPhrase = docs[docs.length - 1] || [];
  let term = lastPhrase[lastPhrase.length - 1];
  if (term.typeahead === true && term.machine) {
    term.text = term.machine;
    term.normal = term.machine;
  }
  return this;
};
var api2 = function(View2) {
  View2.prototype.autoFill = autoFill;
};
var api_default9 = api2;

// node_modules/compromise/src/1-one/typeahead/lib/allPrefixes.js
var getPrefixes = function(arr, opts2, world2) {
  let index3 = {};
  let collisions = [];
  let existing = world2.prefixes || {};
  arr.forEach((str) => {
    str = str.toLowerCase().trim();
    let max3 = str.length;
    if (opts2.max && max3 > opts2.max) {
      max3 = opts2.max;
    }
    for (let size = opts2.min; size < max3; size += 1) {
      let prefix6 = str.substring(0, size);
      if (opts2.safe && world2.model.one.lexicon.hasOwnProperty(prefix6)) {
        continue;
      }
      if (existing.hasOwnProperty(prefix6) === true) {
        collisions.push(prefix6);
        continue;
      }
      if (index3.hasOwnProperty(prefix6) === true) {
        collisions.push(prefix6);
        continue;
      }
      index3[prefix6] = str;
    }
  });
  index3 = Object.assign({}, existing, index3);
  collisions.forEach((str) => {
    delete index3[str];
  });
  return index3;
};
var allPrefixes_default = getPrefixes;

// node_modules/compromise/src/1-one/typeahead/lib/index.js
var isObject7 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var defaults2 = {
  safe: true,
  min: 3
};
var prepare = function(words = [], opts2 = {}) {
  let model5 = this.model();
  opts2 = Object.assign({}, defaults2, opts2);
  if (isObject7(words)) {
    Object.assign(model5.one.lexicon, words);
    words = Object.keys(words);
  }
  let prefixes2 = allPrefixes_default(words, opts2, this.world());
  Object.keys(prefixes2).forEach((str) => {
    if (model5.one.typeahead.hasOwnProperty(str)) {
      delete model5.one.typeahead[str];
      return;
    }
    model5.one.typeahead[str] = prefixes2[str];
  });
  return this;
};
var lib_default5 = {
  typeahead: prepare
};

// node_modules/compromise/src/1-one/typeahead/plugin.js
var model3 = {
  one: {
    typeahead: {}
  }
};
var plugin_default12 = {
  model: model3,
  api: api_default9,
  lib: lib_default5,
  compute: compute_default7,
  hooks: ["typeahead"]
};

// node_modules/compromise/src/one.js
nlp_default.extend(plugin_default2);
nlp_default.extend(plugin_default7);
nlp_default.extend(plugin_default6);
nlp_default.extend(plugin_default8);
nlp_default.extend(plugin_default10);
nlp_default.plugin(plugin_default3);
nlp_default.extend(plugin_default11);
nlp_default.plugin(plugin_default);
nlp_default.extend(plugin_default5);
nlp_default.extend(plugin_default12);
nlp_default.extend(plugin_default4);
nlp_default.extend(plugin_default9);
var one_default = nlp_default;

// node_modules/compromise/src/2-two/preTagger/model/irregulars/plurals.js
var plurals_default = {
  addendum: "addenda",
  corpus: "corpora",
  criterion: "criteria",
  curriculum: "curricula",
  genus: "genera",
  memorandum: "memoranda",
  opus: "opera",
  ovum: "ova",
  phenomenon: "phenomena",
  referendum: "referenda",
  alga: "algae",
  alumna: "alumnae",
  antenna: "antennae",
  formula: "formulae",
  larva: "larvae",
  nebula: "nebulae",
  vertebra: "vertebrae",
  analysis: "analyses",
  axis: "axes",
  diagnosis: "diagnoses",
  parenthesis: "parentheses",
  prognosis: "prognoses",
  synopsis: "synopses",
  thesis: "theses",
  neurosis: "neuroses",
  appendix: "appendices",
  index: "indices",
  matrix: "matrices",
  ox: "oxen",
  sex: "sexes",
  alumnus: "alumni",
  bacillus: "bacilli",
  cactus: "cacti",
  fungus: "fungi",
  hippopotamus: "hippopotami",
  libretto: "libretti",
  modulus: "moduli",
  nucleus: "nuclei",
  octopus: "octopi",
  radius: "radii",
  stimulus: "stimuli",
  syllabus: "syllabi",
  cookie: "cookies",
  calorie: "calories",
  auntie: "aunties",
  movie: "movies",
  pie: "pies",
  rookie: "rookies",
  tie: "ties",
  zombie: "zombies",
  leaf: "leaves",
  loaf: "loaves",
  thief: "thieves",
  foot: "feet",
  goose: "geese",
  tooth: "teeth",
  beau: "beaux",
  chateau: "chateaux",
  tableau: "tableaux",
  bus: "buses",
  gas: "gases",
  circus: "circuses",
  crisis: "crises",
  virus: "viruses",
  database: "databases",
  excuse: "excuses",
  abuse: "abuses",
  avocado: "avocados",
  barracks: "barracks",
  child: "children",
  clothes: "clothes",
  echo: "echoes",
  embargo: "embargoes",
  epoch: "epochs",
  deer: "deer",
  halo: "halos",
  man: "men",
  woman: "women",
  mosquito: "mosquitoes",
  mouse: "mice",
  person: "people",
  quiz: "quizzes",
  rodeo: "rodeos",
  shoe: "shoes",
  sombrero: "sombreros",
  stomach: "stomachs",
  tornado: "tornados",
  tuxedo: "tuxedos"
};

// node_modules/compromise/src/2-two/preTagger/model/lexicon/_data.js
var data_default = {
  "Comparative": "true\xA6better",
  "Superlative": "true\xA6earlier",
  "PresentTense": "true\xA6sounds",
  "Condition": "true\xA6lest,unless",
  "PastTense": "true\xA6be2came,d1had,lied,mea0sa1taken,we0;nt;id;en,gan",
  "Gerund": "true\xA6accord0be0go0result0stain0;ing",
  "Expression": "true\xA6a0Sb0Oc0Md0Ie0Gg0AhVjeez,lSmRnPoKpHshGtFuCvoi0Uw6y0;a4e3i1u0;ck,p;kZp0;ee,pee;ah,p,s;!a,y;ahoo,h2o1t0;af,f;rd up,w;e1o0;a,ops;e,w;gh,h0;! 0h,m;huh,oh;here nNsk,ut tut;eesh,hh,it,oo;ff,h1l0ow,sst;ease,z;ew,ooey;h1i,o0uch,w,y;h,o,ps;! 0h;h0w0;ell;ah,o0;!pe;eh,mm;ah,m1ol0;!s;ao,fao;aBeAi8o2u0;h,mph,rra0zzB;h,y;ly1o0;r5y8;! 0;c1moCsmok0;es;ow;!p hip hoor0;ay;ck,e,llo,y;ha1i,lleluj0;ah;!ha;ah,ee4o1r0;eat scott,r;l1od0sh; grief,bye;ly;! whiz;e0h,t cetera,ww,xcuse me;k,p;'oh,a0rat,uh;m0ng;mit,n0;!it;mon,o0;ngratulations,wabunga;a2oo1r0ye;avo,r;!ya;h,m; 1h0las,men,rgh,ye;!a,em,oy;la",
  "Negative": "true\xA6n0;ever,o0;n,t",
  "QuestionWord": "true\xA6how3wh0;at,e1ich,o0y;!m,se;n,re; come,'s",
  "Reflexive": "true\xA6h4it5my5o1the0your2;ir1m1;ne3ur0;sel0;f,ves;er0im0;self",
  "Plural": "true\xA6dick0gre0ones,records;ens",
  "Unit|Noun": "true\xA6cEfDgChBinchAk9lb,m6newt5oz,p4qt,t1y0;ardEd;able1b0ea1sp;!l,sp;spo1;a,oundAt,x;on9;!b,g,i1l,m,p0;h,s;!les;!b,elvin,g,m;!es;g,z;al,b;eet,oot,t;m,up0;!s",
  "Value": "true\xA6a few",
  "Imperative": "true\xA6come here",
  "Demonym": "true\xA60:15;1:12;a0Vb0Oc0Dd0Ce08f07g04h02iYjVkTlPmLnIomHpEqatari,rCs7t5u4v3welAz2;am0Gimbabwe0;enezuel0ietnam0I;gAkrai1;aiwTex0hai,rinida0Ju2;ni0Prkmen;a5cotti4e3ingapoOlovak,oma0Spaniard,udRw2y0W;ede,iss;negal0Cr09;sh;mo0uT;o5us0Jw2;and0;a2eru0Fhilippi0Nortugu07uerto r0S;kist3lesti1na2raguay0;ma1;ani;ami00i2orweP;caragu0geri2;an,en;a3ex0Lo2;ngo0Drocc0;cedo1la2;gasy,y07;a4eb9i2;b2thua1;e0Cy0;o,t01;azakh,eny0o2uwaiI;re0;a2orda1;ma0Ap2;anO;celandic,nd4r2sraeli,ta01vo05;a2iB;ni0qi;i0oneU;aiAin2ondur0unO;di;amEe2hanai0reek,uatemal0;or2rm0;gi0;ilipino,ren8;cuadoVgyp4mira3ngli2sto1thiopi0urope0;shm0;ti;ti0;aPominUut3;a9h6o4roat3ub0ze2;ch;!i0;lom2ngol5;bi0;a6i2;le0n2;ese;lifor1m2na3;bo2eroo1;di0;angladeshi,el6o4r3ul2;gaE;azi9it;li2s1;vi0;aru2gi0;si0;fAl7merBngol0r5si0us2;sie,tr2;a2i0;li0;genti2me1;ne;ba1ge2;ri0;ni0;gh0r2;ic0;an",
  "Organization": "true\xA60:4D;a3Gb2Yc2Ed26e22f1Xg1Ph1Ki1Hj1Fk1Dl18m0Wn0Jo0Gp09qu08r01sTtGuBv8w3xiaomi,y1;amaha,m13ou1w13;gov,tu2Z;a3e1orld trade organizati2S;lls fargo,st1;fie28inghou2I;l1rner br3I;gree37l street journ29m17;an halOeriz2Nisa,o1;dafo2Ol1;kswagMvo;b4kip,n2ps,s1;a tod2Yps;es3Ai1;lev33ted natio30;er,s; mobi2Qaco beQd bNeAgi frida9h3im horto2Ymz,o1witt31;shi3Xy1;ota,s r 00;e 1in lizzy;b3carpen37daily ma31guess w2holli0rolling st1Rs1w2;mashing pumpki2Tuprem0;ho;ea1lack eyed pe3Lyrds;ch bo1tl0;ys;l2n3Ds1xas instrumen1J;co,la m15;efoni0Cus;a7e4ieme2Lnp,o2pice gir5quare04ta1ubaru;rbucks,to2R;ny,undgard1;en;a2x pisto1;ls;g1Nrs;few2Ainsbury2QlesforYmsu22;.e.m.,adiohead,b6e3oyal 1yana30;b1dutch she4;ank;aders dige1Gd 1max,vl1R;bu1c1Zhot chili peppe2Nlobst2C;ll;c,s;ant30izno2I;a5bs,e3fiz28hilip morrCi2r1;emier2Audenti16;nk floyd,zza hut;psi2Btro1uge0A;br2Vchina,n2V;lant2Nn1yp12; 2ason20da2I;ld navy,pec,range juli2xf1;am;us;aAb9e6fl,h5i4o1sa,vid3wa;k2tre dame,vart1;is;ia;ke,ntendo,ss0L;l,s;c,st1Htflix,w1; 1sweek;kids on the block,york09;a,c;nd1Vs2t1;ional aca2Io,we0Q;a,cYd0O;aBcdonaldAe7i5lb,o3tv,y1;spa1;ce;b1Mnsanto,ody blu0t1;ley crue,or0O;crosoft,t1;as,subisM;dica2rcedes benz,talli1;ca;id,re;'s,s;c's milk,tt14z1Z;'ore08a3e1g,ittle caesa1K;novo,x1;is,mark; 1bour party;pres0Bz boy;atv,fc,kk,m1od1J;art;iffy lu0Moy divisi0Gpmorgan1sa;! cha07;bm,hop,n1tv;g,te1;l,rpol;asbro,ewlett pack1Ri3o1sbc,yundai;me dep1n1L;ot;tac1zbollah;hi;eneral 6hq,ithub,l5mb,o2reen d0Lu1;cci,ns n ros0;ldman sachs,o1;dye1g0E;ar;axo smith kli03encoV;electr0Km1;oto0W;a4bi,da,edex,i2leetwood mac,o1rito l0D;rd,xcX;at,nancial1restoY; tim0;cebook,nnie mae;b08sa,u3xxon1; m1m1;ob0H;!rosceptics;aiml0Be6isney,o4u1;nkin donu2po0Xran dur1;an;ts;j,w j1;on0;a,f lepp0Zll,peche mode,r spiegZstiny's chi1;ld;aIbc,hEiCloudflaBnn,o3r1;aigsli5eedence clearwater reviv1ossra06;al;ca c7inba6l4m1o0Bst06;ca2p1;aq;st;dplPg1;ate;se;ola;re;a,sco1tigroup;! systems;ev2i1;ck fil-a,na daily;r1y;on;dbury,pital o1rl's jr;ne;aEbc,eBf9l5mw,ni,o1p,rexiteeU;ei3mbardiIston 1;glo1pizza;be;ng;o2ue c1;roV;ckbuster video,omingda1;le; g1g1;oodriL;cht2e ge0rkshire hathaw1;ay;el;idu,nana republ3s1xt5y5;f,kin robbi1;ns;ic;bYcTdidSerosmith,iRlKmEnheuser-busDol,pple9r6s3utodesk,v2y1;er;is,on;hland1sociated F; o1;il;by4g2m1;co;os; compu2bee1;'s;te1;rs;ch;c,d,erican3t1;!r1;ak; ex1;pre1;ss; 5catel2ta1;ir;!-lu1;ce1;nt;jazeera,qae1;da;g,rbnb;as;/dc,a3er,tivision1;! blizz1;ard;demy of scienc0;es;ba",
  "Possessive": "true\xA6its,my,none,our0;!s",
  "Noun|Verb": "true\xA60:9C;1:8O;2:7T;3:97;4:9K;5:9N;6:9J;7:86;8:8L;9:9R;a92b86c70d6Be61f5Eg52h4Ti4Lj4Ik4Fl43m3Rn3No3Jp2Hques94r1Ss0EtYuWvRwDyCzA;ip,oA;ne,om;awn,e60ie5T;aKeIhFiDoBrA;ap,e92;nd0rA;k,ry,sh54th;ck,mp,nApe,re,sh,tne9N;!d,g;e7OiA;p,sA;k,t1;aAed;r,th0;it,lk,rBsAt3ve,x;h,te;!ehou2ra9;aDiCoA;iAlunte0m8te,w;ce,d;be,ew,s8;cuum,l40;pAr7sh0;da6gra5Zlo5V;aNeMhrLiKoIrDuBwiAy5K;n,st;nArn;e,n76;aCeBiAot,u8H;bu6ck47gg0m,p;at,k,nd;ck,de,in,nsAp,v72;f0i87;ll,ne,p,r4Mss,t8JuA;ch,r;ck,de,e,le,me,p,re;e5Iow,u89;ar,e,ll,mp0st,xt;g,lAng1rg77s6x;k,ly;a0Lc0Fe0Ch07i05k03l01m00nZou7JpSqua70tGuCwA;ea7PiA;ng,pe,t3;b2Eit,m,ppBrAspe5;ge,pri2v2M;lAo6A;e67y;aJeIiHoErBuAy1;dy,ff,mb1;a7MeBiAo5Cugg1;ke,ng;am,ss,t3;ckBop,p,rA;e,m;ing,pi1;ck,nk,t3;m,p;ck,ge,in,ke,ll,mp,nd,p1rAte,y;!e,t;aFeed,iElDoCrAur,y;ay,e4UinAu4;g,k1;ns7St;a6Kit;ll,n,r7Ote;n,rk;ap,ee1Qow;a6Ge47i1o4U;eep,iAou3;ce,p,t;ateboa74iA;!p;de,gnAp,ze;!al;aDeCiBoAuff1;ck,p,re,t,w;ft,p,v0;d,i3Q;ck,de,pe,re,ve;aBed,nArv1Ht;se,t2I;l,r3t;aEhedu1oDrA;aBeAo3R;en,w;pe,t3;re,ut;le,n,r0N;cAil;k,rifi4;aWeEiDoBuA;b,in,le,n,s5J;a6Pck,ll,oApe,u6;f,t;de,ng,p,s1Q;aQcPdo,el,fNgMje5lLmJnIo14pGque6MsCturn,vAwa6F;eAi21;al,r2;er6NoCpe5tBuA;lt,me;!a4R;l6Krt;air,eaAly,o4P;l,t;dezvo2Rt;aAedy;ke,rk;ea2i5C;a62ist0r59;act6Her1Po6KuA;nd,se;a2Zo5Zru8;ch,s60;c17ge,i2ke,l53nApXtX;ge,k;a03eZhXiUlQoKrBsy3uA;mp,n3rcha2sh;aHeFiEoAu4C;be,ceCdu4fi1grAje5mi2p,te5Z;amAe6J;!me;ed,ss;ce,de,nt;sAy;er5Xs;cti4i2;iElCoBp,re,sAw0;e,i5Kt;l,p;iAl;ce,sh;nt,s5H;aBce,e2UuA;g,mp,n7;ce,nAy;!t;ck,lBnApe,t,vot;!e;e,ot;a2oA;ne,tograph;ak,eCnBrAt;fu4Qm8;!c2S;!l,r;ckGiFnErCsBtAu2;ch,e9;s,te;e9tA;!y;!ic;nt,r;!a7;bCff0il,oBrAutli3C;b8d0ie9;ze;je5;a4BeCoA;d,tA;e,i4;ed,gle5rd,t;aHeFiEoBuA;rd0;ck,d3Eld,nAp,uth,ve;it4YkA;ey;lk,n3Yrr4Wss,x;asu3Hn4GrAss;ge,it;il,nCp,rk3KsBtA;ch,t0;h,k;da6n0oeuv3C;aIeGiEoBuA;mp,st;aBbby,ck,g,oAve;k,t;d,n;cAft,m8nEst;en2k;aAc0Je3vG;ch,d,k,p,se;bBcAnd,p,t3un3;e,k;el,o2J;eBiAno41;ck,ll,ss;el,y;aBo1HuA;d7i4mp;m,zz;mpGnBr3TssA;ue;cr1Jdex,fluDha1k,se26teAvoi4;nt,rA;e3Ufa4viA;ew;en4;a5le1Z;aFeDiCoBuA;g,nt;l2Zno22ok,p,r2st,u2;ghlight,ke,re,t;aAd7lp;d,t;ck,m,ndBrAsh,te;bo3Lm,ne44ve3J;!le;aKeek,loJoHrCuA;arAe41i0Tn;antee,d;aCiBoAumb1;om,u2R;nd,p;dAsp;e,ua6;of,ssA;ip;ss,w;in,me,ng,s,te,ze;aVeSiNlKoGrCuA;ck,el,nAss,zz;c2Xd;aBoAy;st,wn;cAgme,me;tu1U;cCg,il,ld,ol,rA;ce,e20mA;!at;us;aBe1Wip,oAy;at,ck,od,w;g,ke,me,re,sh,vo16;eDgClBnAre,sh,t,x;an4i1S;e,m,t0;ht,u1J;ld;aBeAn4;d,l;r,tu1F;ce,il,ll,rm,vo2L;cho,d7ffe5nIsGxCyeA;!baA;ll;cCerci2hib8pAtra5;eriAo0O;en4me9;el,han7u2;caAtima6;pe;count0d,gine0vy;aWePiJoGrBuAye;b,el,mp,pli2O;aDeCiBoA;ne,p;ft,nk,p,ve;am,ss;ft,g,in;cBd7ubt,wnloA;ad;k,u07;p,sCt3vA;e,iAor4;de;char7h,liBpA;at3lay,u6;ke;al,ba6cEfeDlCma16pos8siBtaA;il;gn,re;ay,ega6;at,ct;liZrA;ea2;b,ma7n4rAte;e,t;a0Aent09h02irc1lZoGrCuA;be,e,rAt;e,l,ve;aCeBoAu0Iy;p,ss,wd;d8ep;ck,ft,sh;aRde,in,lPmInCok,py,re,st,uAv0;gh,nAp1;sYt;ceDdu5fli5glomeEsCtAveJ;a5rA;a17ol;e9tru5;ntArn;ra6;bEfoDmCpA;leAou0Gromi2;me9;a0Ee9it,u6;rt;at,iA;ne;lap2oA;r,ur;ch,t;aBiA;ck,p;im,w;aBeAip;at,ck,er;iDllen7mpi0JnBrAuffe0Q;ge,m,t;ge,nA;el;n,r;er,re;ke,ll,mp,noe,pCrTsBt3u2ve;se;h,t;!tuA;re;aZeViTlQoMrEuAypa0Y;bb1ck1dgCff0lBmp,rAst,zz;den,n;ly;et;anGeEiCoadBuA;sh;ca06;be,d7;ge;aAed;ch,k;ch,d;aCg,mb,nBoAss,tt1x,ycott;k,st,t;d,e;rd,st;aBeAitz,oTur;nd;me;as,d,ke,nd,opsy,tA;ch,e;aCef,lt,nAt;d,ef8;it;r,t;ck,il,lan4nErgCsBtt1;le;e,h;aAe;in;!d,g,k;c04dWffilVge,iUlRnPppMrIsFttDucBwaA;rd;tiA;on;aAempt;ck;k,sA;iAocO;st;chBmoA;ur;!iA;ve;eBroa3;ch;al;chAg0sw0;or;aBt0;er;rm;d,m,r;ia6;dEvA;an4oA;ca6;te;ce;i5reA;ss;ct;cAe,he,t;eCoA;rd,u9;nt;nt,ss",
  "Actor": "true\xA60:1O;a1Lb1Dc0Zd0Rex0Qf0Kg0Dh0Ci08journ07l04mXnurse,oVpMquKrEs4t3underwrHv2w1;ork0rG;eterinari12iceH;aoiseach,echn0Rherapi1MranscriF;ail1Scienti1Le8i7ki0ol1Ep5t3u1;lt0Zperv1Mr1;f0ge4;aff0ep1rang0;fa08mo08;eciYokespers1;on;ng0st0;cretary,rgeant1;! maj1J;abbi,e1oof0unning 7;ar4c1port0sear0Zverend;e2ru1;it0;ptioni17; admir1A;arter1een;back;ast1Ah8l6oli5r1sychologi13;actition0eside1Bi2o1;duc0fess18gramm0spe05;me minCnce1;!ss;c06t03;a1umb0;nn0y0;otograph0ys00;ffic0p1rganiz0;er0Ztometri0T;a6e5i2o1usX;m,th0;n2s1;sus,t0;ist0;chanic,rcha0W;gistrate,k0nag0y0T;a2e05ieutenant1ord;! gener0O;bor0dy,wy0;ali0I;llu0Mn1;s1vestig0M;peJt1;all0ruI;airdress0ousek7;arden0o4rand1;fa2m1pa;a,o1;th0;al1lf0;ie,k1teO;eep0;a5i1;eld marsh08g3nanci0r1tt0;e1st lady;fig1mH;ht0;rm0th0;amin0cellency;a7e4i1o2riv0utcheT;et2re1;ct03;iciA;al0fenc2put1sign0tective,velop0;ee,y;em7;d,nc0;aCeo,fo,h9le8o1;lonel,m5n2ordinVrporTu1wboy;nci9ri0;gress1stable;m1wom1;an;ma1pos0;nd0;an0rk;ance2eerle1;ad0;llM;ptain,r1shi0;etak0pent0;aron6r2ut1;ch0;i2o1;k0th0;cklay0ga1;di0;!e1;ss;ccounCd5geDn2r1ssisCttendaDyatullah;chitect,ti3;aly2im8nounc0;er;st;mi2v1;is5;ni2r1;al;str1;at1;or;ta1;nt",
  "Person|Noun": "true\xA6a07b01cYdRePfOgMhJjFkiElDmBolive,p7r4s3trini00v1wa0;ng,rd;an,enus,iol0;a,et;ky,on5umm02;ay,e1o0uby;bin,d,se;ed,x;a2e0ol;aHn0;ny;ge,tM;a0eloR;x,ya;a9eo,iE;ng,tL;a2e1o0;lDy;an,w3;de,smi4y;a0iKol8;ll,z0;el;ail,e0;ne;aith,ern,lo;a0dDmir,ula,ve;rl;a4e3i1ol0;ly;ck,x0;ie;an,ja;i0wn;sy;h0liff,rystal;ari0in,ristian;ty;ak4e3i2r0;an0ook;dy;ll;nedict,rg;er;l0rt;fredo,ma",
  "Person|Verb": "true\xA6b8ch7dr6foster,gra5hope,ja9lan4ma2ni9ollie,p1rob,s0tra4wade;pike,t5ue;at,eg,ier2;ck,r0;k,shal;ce;ce,nt;ew;ase,u1;iff,l1ob,u0;ck;aze,ossom",
  "Adj|Noun": "true\xA60:13;1:1A;a13b0Xc0Mde0Le0Gf0Ag09h08i06ju05l03mXnVoTpOrKsDt9u6v3w2;atershed,elcome;a2ision0P;gabo5nilla,ria2;b0Mnt;ndergr2pstairs;adua0Tou2;nd;a4e2oken,ri0;en,r2;min0rori0S;boo,n;e6ilv08o4quat,ta3u2well;bordina0Mper6;b0Cndard;ciali0Nl2vereign;e,ve1;cret,n2ri0;ior;a4e2outiSubbiL;ar,bCla0Mnt0p2side1;resenta0Lublican;ci0Gsh;a5eriodic0otenti0r2;emi3incip0o2;!fession0;er,um;rall5st,tie1;ff2pposi07v0;ensi0Ei03;aggTov2;el;aUe5in4o2;biTderYr2;al,t0;iature,or;di2tr0C;an,um;attIiber0u2;sh;stice,veniM;de0mpressioQn2;cumbe1dividu0no04sta1;alf,omelBumdrum;enious,old,raZ;a5e3i2luid;ne;llow,m2;aEiJ;ir,t,vo2;riLuriL;l4pXx2;c2ecuQpeS;ess;d2iH;er;mographSrivaM;hiFlassRo3rude,unn2;ing;m5n2operaJ;creBstitue1tempor3vertab2;le;ary;m3p2;anion,lex;er3u2;ni8;ci0;e6lank,o5r2;i3u2;te;ef;ttom,urgeois;st;cademAd7l3nim0rab;al;e4terna2;ti2;ve;rt;oles2ult;ce1;nt;ic",
  "Pronoun": "true\xA6'em,elle,h3i2me,she4th0us,we,you;e0ou;m,y;!l,t;e0im;!'s",
  "Singular": "true\xA60:5B;1:59;2:4H;3:4N;4:4U;5:5D;6:4Z;a4Pb46c38d2Se2Mf2Eg26h1Uin1Rj1Qk1Pl1Jm1Bn18o14p0Jqu0Ir08sTtIuFvAw7x 4Y;a7ha3Aom2A;f2i4Tt09y7;! arou4D;arAe8o7;cabula3Cl52;gKr7;di4Qt1L;iety,n4A;nc32p2Or8s 7;do3Qs54;bani1in0; rex,aGeFhing3XiDoCr9u8v7;! show;m2Dn3rntHto13;age2Sib7o42;e,u7;n0ta30;p3rq3A;c,er,m7;etB;am,mp36;ct3le5x return;aKcIeHhor4KiGkEoDpin off,tBu9weethe1Hy7;ll7n22st4N;ab2M;b7nri1Aper bowl,rroga1;st3Ctot0;at32ipe3Oo1Brate4Cudent7;! lo1I;ft ser4Gloi41meo19;elet6i7;ll,rm3M;s3Ute;ab0Ycurity gu2Emin33;e5ho7;l31ol;la2Gndwi0Kpi6;av6eBhetor3i8o7;de5om,w;t8v7;erb0R;e,u0;bAc9f7publ3r0Rspi1;er7orm2;e5r0;it0ord label;a1u42;estion mark,ot28;aOeLhKiHlFoDr8u7yram1A;ddi3ApDrpo0Ms3D;eAie3Go7;bl3Vs7;pe3Gt7;a1itu1;diction,mi0Hroga3Qss relea0H;p7rt0;py;a7ebisci1;q25te;cn3e8g7;!gy;!r;armaci34otocoG;anut,d8r7t0;cen3Esp3F;al,est0;n8r2Nt7;e,hog6;el2Mop4;bj3Ac8pia1rde0thers,ve7wn2;n,rview;cu7e0B;pi2;a8it21ot7umb2;a1Ehi2L;n26rra35;aBeAi9o8u7\xE90C;m0Lr0;m0Knopo4pPrni2Hsq1Lti33;li0Tn07tt6;d3nu,t0;mm0n8te7yf4;ri0;!d0Y;aAegBi9os2u7;ddi1n7;ch;ght bulb,p07ving room;bor0Zurea1y7; up;eyno1itt6;el4ourn0;c8dices,itia2Oni23se2Ctel0Hvert7;eb1H;en2Mi2V;aHeaDighBo7uman right,ygie0V;me8sp1Ftb7;ed;! r7;un; scho0Xri7;se;d7v6; st8pho7;ne;art;ndful,sh brown,v6ze;aCeAirl1Flaci2od,r8u7;l4y;an7enadi2id;a0Ed slam;lat0Antlem7;an;df4r7;l3n1B;aDeCiref4lBol4r8un7;er0;ee market,i8on7;ti2;e14ga1;ow2u1;lla,t14;br3mi4n0V;conoBffi1Ogg,lecto0Nmbas1BnApidem3s1Yth3ven9x8yel7;id;ampTempl0Jte5;i15t;er1K;my;aKeHiDoAr8u7;de,mp truck;agonf4i7;er,ve thru;c8g1Ei4or,ssi2wn7;si0L;to0Bumen9;a9gni8nn2s7vide0N;conte5incen1Ftri13;taM;le11;ath,c8f7ni0terre5;ault 05err0;al,im0;d7rX;dy;aWeThMiLlJoBr7;edit c9it3uc7;ib7;le;ard;efficDke,lBmmuniqLns8pi2rr0t10us7yo1;in;erv7uI;ato7;ry;ic,lPum7;ni0I;ie5;er7ie5;gy,ic;ty,vil wK;aBeqAick6oco9r7;istmas car7ysanthemum;ol;la1;ue;ndeli2racter7;ist3;i8llCr7;e0tifica1;liX;hi2naDpCrAt7ucus;erpi7hedr0;ll7;ar;!bohyd7ri2;ra1;it0;l,ry;aLeKicycJlemIoErBu7;ddhiUn9r7tterf4;glar7i0;!y;ny;eak8i7o;de;faOthroA;dy,ro9wl,y7;!frie7;nd;ugh;ish;liI;an,l4;nki9r7;!ri2;er;ng;cTdNlJnGppeti1rFsDt9u7;nt,top7;sy;h8t3;ic;ie7le1;st;ce5pe7;ct;ray;ec8oma4ti8;ly;do1;i6l7;er7y;gy;en; hominBj8van7;tage;ec7;ti7;ve;em;cAe8qui7;tt0;ta1;te;i8ru0;al;de5;nt",
  "Preposition": "true\xA6-,aPbMcLdKexcept,fIinGmid,notwithstandiWoDpXqua,sCt7u4v2w0;/o,hereSith0;! whHin,oW;ersus,i0;a,s-a-vis;n1p0;!on;like,til;h1ill,oward0;!s;an,r0;ough0u;!oM;ans,ince,o that,uch G;f1n0ut;!to;!f;! 0to;effect,part;or,r0;om;espite,own,u3;hez,irca;ar1e0oBy;sides,tween;ri7;bo8cross,ft7lo6m4propos,round,s1t0;!op;! 0;a whole,long 0;as;id0ong0;!st;ng;er;ut",
  "SportsTeam": "true\xA60:1A;1:1H;2:1G;a1Eb16c0Td0Kfc dallas,g0Ihouston 0Hindiana0Gjacksonville jagua0k0El0Bm01newToQpJqueens parkIreal salt lake,sAt5utah jazz,vancouver whitecaps,w3yW;ashington 3est ham0Rh10;natio1Oredski2wizar0W;ampa bay 6e5o3;ronto 3ttenham hotspur;blue ja0Mrapto0;nnessee tita2xasC;buccanee0ra0K;a7eattle 5heffield0Kporting kansas0Wt3;. louis 3oke0V;c1Frams;marine0s3;eah15ounG;cramento Rn 3;antonio spu0diego 3francisco gJjose earthquak1;char08paA; ran07;a8h5ittsburgh 4ortland t3;imbe0rail blaze0;pirat1steele0;il3oenix su2;adelphia 3li1;eagl1philNunE;dr1;akland 3klahoma city thunder,rlando magic;athle0Mrai3;de0; 3castle01;england 7orleans 6york 3;city fc,g4je0FknXme0Fred bul0Yy3;anke1;ian0D;pelica2sain0C;patrio0Brevolut3;ion;anchester Be9i3ontreal impact;ami 7lwaukee b6nnesota 3;t4u0Fvi3;kings;imberwolv1wi2;rewe0uc0K;dolphi2heat,marli2;mphis grizz3ts;li1;cXu08;a4eicesterVos angeles 3;clippe0dodDla9; galaxy,ke0;ansas city 3nE;chiefs,roya0E; pace0polis colU;astr06dynamo,rockeTtexa2;olden state warrio0reen bay pac3;ke0;.c.Aallas 7e3i05od5;nver 5troit 3;lio2pisto2ti3;ge0;broncZnuggeM;cowbo4maver3;ic00;ys; uQ;arCelKh8incinnati 6leveland 5ol3;orado r3umbus crew sc;api5ocki1;brow2cavalie0india2;bengaWre3;ds;arlotte horAicago 3;b4cubs,fire,wh3;iteB;ea0ulR;diff3olina panthe0; c3;ity;altimore 9lackburn rove0oston 5rooklyn 3uffalo bilN;ne3;ts;cel4red3; sox;tics;rs;oriol1rave2;rizona Ast8tlanta 3;brav1falco2h4u3;nited;aw9;ns;es;on villa,r3;os;c5di3;amondbac3;ks;ardi3;na3;ls",
  "Uncountable": "true\xA60:28;1:2R;2:2F;3:35;4:2W;a2Qb2Hc26d1Xe1Nf1Hg19h12i0Xjewel15k0Vl0Qm0Gn0Eo0Dp04rZsMtBv9w5you guys;a7hisky,i6oo5;d,l;ldlife,ne;rmAt2;ernacul25i5;neg24ol1Ktae;eEhCime off,oBr6un5yranny;a,gst15;aff2Jea1Go6ue nor5;th;o07u5;ble5se1Ot;!shoot1;night,othpas1P;er5und2;e,mod2O;a,nnis;aFcEeDhBilk,kiAo9p8t6u5weepstak0;g1Rnshi2Dshi;ati08e5;am,el;ace2Geci0;ap,cc2meth1;n,ttl0;eep,ingl0o5;pp1r18;lf,na1Cri0;ene0Disso18;d0Sfe4l5nd,t0F;m1St;a8e6ic5;e,ke12;c5ins,laxa0Zsearch;ogni0Yrea0Y;bi0in;aBeAhys9last1So7re5;amble,mis0s5ten1W;en1Vsu0H;l5rk;i24yH; 14i3;a20tr0A;nt5ti0J;i0s;bstetri3vercrowd1xyg04;a5ews;il polXtional securi4;aCeAo7u5;m5s1F;ps;n5o1I;ey,o5;gamy;a5cha0Drchandi1Ftallurgy;sl0t;chine5thema1O; learn1ry;aught2e8i7ogi6u5;ck,g11;c,s1K;ce,ghtn1nguis1JteraTv2;ath2isuTss;ara0CindergartMn5;icke08owled0X;ce,gnor8mp7n5;forma02ter5;net,sta08;atiUort5rov;an19;a8eListo7o5ung2;ckey,mework,ne5rserad9spitali4use arrest;s4y;ry;ir,lib03ppiJs5;h5te;ish;ene9l7o6r5um,ymnas13;aGe03;lf,re;ut5yce0J;en; 5ti3;edit1po5;ol;aQicJlour,o7urni5;tu5;re;od,rgive5uri2wl;ne5;ss;cono0MducaDlectrBn9quipAthi3very8x5;ist6per5;ti0C;en0K;body,o09th1;joy5tertain5;ment;ici4o5;ni3;tiU;eBi8o6raugh5ynas4;ts;pe,wnstai5;rs;abet0s5;hon01repu5;te;b5miX;ut;aEelciDhBivi3l9o5urrency;al,ld w7n5ral,ttJuscoC;fusiIt 5;ed;ar;assi3oth0;es;aos,e5;eNw1;us;d,rP;aAi8lood,read7u5;nt1tt2;er;!th;lliarKs5;on;g5ss;ga5;ge;cLdviKeroHirGmCn7ppeal court,rithmet6spi5thleM;rin;ic;i8y5;o6th1;ing;ne;se;en7n5;es4;ty;ds;craft;bi3d5nau9;yna5;mi3;ce;id,ous5;ti3;cs",
  "Unit": "true\xA6a09b06cZdYexXfTgRhePin00joule0DkMlJmDnan0AoCp9quart0Dsq ft,t7volts,w6y2ze3\xB01\xB50;g,s;c,f,n;dXear1o0;ttT; 0s 0;old;att06b;erPon0;!ne04;ascals,e1i0;cZnt02;rcent,tL;hms,uI;/s,e4i0m\xB2,\xB2,\xB3;/h,cro2l0;e0liM;!\xB2;grNsT;gEtL;it1u0;menSx;erRreR;b5elvins,ilo1m0notQ;/h,ph,\xB2;!byIgrGmEs;ct0rtzN;aLogrE;allonLb0ig5rD;ps;a2emtGl0t6; oz,uid ou0;nceH;hrenheit,radG;aby9;eci3m1;aratDe1m0oulombD;\xB2,\xB3;lsius,nti0;gr2lit1m0;et0;er8;am7;b1y0;te5;l,ps;c2tt0;os0;econd1;re0;!s",
  "Noun|Gerund": "true\xA60:26;1:25;2:1W;3:1I;4:1Y;5:1O;a25b1Oc1Cd17en15f0Zg0Xh0Ui0Sjog20k0Ql0Mm0Jn0Ho0Dp06ques09rXsHtCuAvolunt16w6yEzo2;a8ed5i3or7r6;ap1Oest1Ci1;ki0r1O;i1r2s1Utc1U;nder6pri23;st1Mta4;al4e9hin4i8ra6y1J;c4di0i2v6;el15;mi0p1G;a1Xs1;ai12cIeHhFin1OkatDlZmo4nowCpeBt9u7w6;ea3im1T;f02r6;fi0vi0J;a1Kretc1Iu6;d1AfJ;l0Wn5;b7i0;eb6i0;oar5;ip14o6;rte2u1;a1r0At1;h7o3re6;a1Ge2;edu0Noo0N;aDe9i5o7u6;li0n2;o6wi0;fi0;a8c7hear1Cnde3por1struct6;r1Au3;or5yc0G;di0so2;p0Qti0;aBeacekAla9o7r6ublis0X;a0Peten5in1oces16;iso2si6;tio2;n2yi0;ee0K;cka0Tin1rt0K;f8pe7rgani6vula1;si0zi0;ni0ra1;fe3;e6ur0W;gotia1twor4;a7e6i2onito3;e1ssa0L;nufactu3rke1;a8ea7i6od0Jyi0;cen0Qf1s1;r2si0;n5ug0E;i6n0J;c4lS;ci0magi2n6ro2;nova1terac1;andPea1i7o6un1;l5wO;ki0ri0;athe3rie6ui5;vi0;ar0CenHi8l7or6ros1un5;ecas1mat1;ir1oo5;l7n6;anDdi0;i0li0;di0gin6;ee3;a8eba1irec1oub1r6umO;awi0es05i6;n4vi0;n6ti0;ci0;aFelebra1hDlBo8r6ur7;aw6os00;li0;a7di0lo3mplai2n6o4pi0ve3;duc1sul1;cMti0;apDea3imIo6ubI;ni0tK;a6ee3;n1t1;m9s1te3;ri0;aJeGitElDoBr9u6;il5ll7r6;pi0;yi0;an5;di0;a1m6o4;bi0;esHoa1;c6i0;hi0;gin2lon6t1;gi0;ni0;bys7c4ki0;ki0;it1;c9dverti8gi0rg7ssu6;mi0;ui0;si0;coun1ti0;ti0;ng",
  "PhrasalVerb": "true\xA60:93;1:97;2:8I;3:8W;4:8B;5:84;6:86;7:99;8:91;9:8H;A:8Y;B:8S;C:8V;D:8T;E:71;F:98;G:8Z;H:82;I:7I;J:7A;K:4H;a9Hb7Wc6Td6Ne6Lf5Jg52h4Diron0j49k42l3Gm33n30o2Yp2Equiet Hr1Zs0Lt00uYvacuu6SwOyammerBzL;ero Dip MonL;e0k0;by,ov9up;aReNhMiLor0Nrit1B;mp0n3Hpe0r5s5;ackAeel Di0U;aMiLn35;gh 3Yrd0;n Dr L;do1in,oJ;it 7Bk5lk Mrm 6Bsh Lt85v61;aw3do1o7up;aw3in,oC;rgeBsL;e 2herE;a01eZhWiSoRrNuLypQ;ckErn L;do1in,oJup;aMiLot0y 32;ckl81p F;ck HdL;e 60;n7Yp 3Gs5L;ck NdMe Lghten 6me0p o0Tre0;aw3ba4do1in,up;e Iy 2;by,oG;ink Mrow L;aw3ba4in,up;ba4ov9up;aLe 79ll64;m 2r 5O;ckBke Mlk L;ov9shit,u49;aLba4do1in,leave,o67up;ba4ft9pa6Bw3;a0Xc0Ve0Oh0Ki0Hl0Bm0An09o08p03quar5ItRuPwL;earNiL;ngMtch L;aw3ba4o8M; by;cLi6Dm 2ss0;k 66;aTeSiRoPrMuL;cKd36;aigh2Eet76iL;ke 7Tng L;al6Zup;p Lrm2G;by,in,oG;nKr 2tc4O;p F;cKmp0nd MrLveAy 2P;e Ht 2M;ba4do1up;arKeOiNlMrLurB;ead0ingBuc5;a49it 6I;c5ll o3Dn 2;ak Fe73ll0;aKber 2rt0und like;ap 5Wow Duggl5;ash 6Ooke0;eep OiLow 6;cMp L;o6Eup;e 69;in,oL;ff,v9;de1Agn 4OnLt 6Hz5;gLkE; al6Ble0;aNoLu5X;ot Lut0w 7N;aw3ba4f48oC;cKdeEk6FveA;e Qll1Ond Prv5tL; Ltl5K;do1foMin,o7upL;!on;ot,r60;aw3ba4do1in,o4Wup;oCto;al67out0rL;ap66ew 6K;ilAv5;aYeViToPuL;b 5Zle0n Lstl5;aMba4do1inLo2Jth4Ou5Q;!to;c2Xr8w3;ll Not MuL;g3IndA;a2Wf3Po7;ar8in,o7up;ng 69p oLs5;ff,p19;aLelAinEnt0;c6Id L;o3Oup;cKt0;a00eZiXlUoRrPsyc35uL;ll Nn5Lt L;aLba4do1in,oJto48up;pa4Ew3;a3Kdo1in,o22to46up;attleBess LiOop 2;ah2Fon;iMp Lr50u1Hwer 6O;do1in,o6Oup;nt0;aMuL;gEmp 6;ce u21y 6E;ck Lg0le 4Bn 6p5C;oJup;el 5OncilE;c54ir 3An0ss NtMy L;ba4oG; Hc2R;aw3ba4in,oJ;pLw4Z;e4Yt D;aMerd0oL;dAt54;il Hrrow H;aUeRiQoMuL;ddl5ll I;cKnkeyNp 6uthAve L;aLdo1in,o4Mup;l4Ow3; wi4L;ss0x 2;asur5e3TlMss L;a21up;t 6;ke Mn 6rLs2Ax0;k 6ryA;do,fun,oCsure,up;a03eWiRoMuL;ck0st I;aOc4Gg NoLse0;k Lse4E;aft9ba4do1forw38in57o10u47;in,oJ;d 6;e OghtNnMsLve 01;ten F;e 2k 2; 2e47;ar8do1in;aNt MvelL; oC;do1go,in,o7up;nEve L;in,oL;pLut;en;c5p 2sh MtchBughAy L;do1o5A;in4Qo7;eNick Mnock L;do1oCup;oCup;eMy L;in,up;l Ip L;aw3ba4do1f05in,oJto,up;aNoMuL;ic5mpE;ke3Tt H;c44zz 2;a02eXiUoQuL;nMrrLsh 6;y 2;keMt L;ar8do1;r H;lLneErse3L;d Le 2;ba4dLfast,o25up;ear,o1;de Mt L;ba4on,up;aw3o7;aLlp0;d Nl Ir Lt 2;fLof;rom;f11in,o1WuX;cKm 2nMsh0ve Lz2Q;at,it,to;d Mg LkerQ;do1in,o2Uup;do1in,oL;ut,v9;k 2;aZeUive Sloss IoNrMunL; f0S;ab hold,in44ow 2V; Lof 2J;aNb1Nit,oMr8th1JuL;nd9;ff,n,v9;bo7ft9hQw3;aw3bLdo1in,oJrise,up,w3;a4ir2I;ar 6ek0t L;aLb1Gdo1in,o1Dr8up;cMhLl2Hr8t,w3;ead;ross;d aLng 2;bo7;a0Fe08iZlVoRrNuL;ck Le2P;ar8up;eMighten LownBy 2;aw3oG;eLshe29; 2z5;g 2lNol Lrk I;aLwi22;bo7r8;d 6low 2;aMeLip0;sh0;g 6ke0mLrLtten H;e F;gSlQnOrMsLzzle0;h F;e Lm 2;aw3ba4up;d0isL;h 2;e Ll 1V;aw3fQin,o7;ht ba4ure0;eQnMsL;s 2;cNd L;fLoG;or;e D;d06l 2;cPll Lrm0t1I;aNbMdo1in,oLsho0Gth0Avictim;ff,ut,v9;a4ehi2P;pa0D;e L;do1oGup;at Ldge0nd 13y5;in,o7up;aPi1IoOrL;aMess 6op L;aw3b04in,oC;gBwB; Iubl1C;m 2;a0Bh06l03oPrMut L;aw3ba4do1oCup;ackBeep MoLy0;ss Dwd0;by,do1in,o0Vup;me OoMuntL; o2B;k 6l L;do1oG;aSbRforPin,oOtLu0P;hMoLrue;geth9;rough;ff,n,ut,v9;th,wL;ard;a4y;paLr8w3;rt;eaMose L;in,oCup;n 6r F;aOeMiL;ll0pE;ck Der Lw F;on,up;t 2;lSncel0rPsNtch MveE; in;o1Oup;h Dt L;doubt,oG;ry MvL;e 09;aw3oJ;l Lm H;aMba4do1oJup;ff,n,ut;r8w3;a0We0NiteAl0Go05rRuL;bblOckl06il0Elk 6ndl06rMsLtNy FzzA;t 01;n 0IsL;t D;e I;ov9;anXeaViMush L;oGup;ghRng L;aOba4do1forNin,oMuL;nd9p;n,ut;th;bo7lLr8w3;ong;teL;n 2;k L;do1in,o7up;ch0;arUg 6iSn5oQrOssNttlMunce Lx D;aw3ba4;e 6; ar8;e H;do1;k Dt 2;e 2;l 6;do1up;d 2;aQeed0oLurt0;cNw L;aw3ba4do1o7up;ck;k L;in,oC;ck0nk0stA; oRaOef 2lt0nd L;do1ov9up;er;up;r Mt L;do1in,oCup;do1o7;ff,nL;to;ck Qil0nNrgMsL;h D;ainBe D;g DkB; on;in,o7;aw3do1in,oCup;ff,ut;ay;ct FdRir0sk NuctionA; oG;ff;ar8o7;ouL;nd; o7;d L;do1oLup;ff,n;wn;o7up;ut",
  "ProperNoun": "true\xA6barbie,c4diego,e3f2iron maiden,kirby,m0nis,riel,stevens;ercedes,i0;ckey,ssy;inn,lorence,ranco;lmo,uro;atalina,hristi",
  "Ordinal": "true\xA6eBf7nin5s3t0zeroE;enDhir1we0;lfCn7;d,t3;e0ixt8;cond,vent7;et0th;e6ie7;i2o0;r0urt3;tie4;ft1rst;ight0lev1;e0h,ie1;en0;th",
  "Cardinal": "true\xA6bEeBf5mEnine7one,s4t0zero;en,h2rDw0;e0o;lve,n5;irt6ousands,ree;even2ix2;i3o0;r1ur0;!t2;ty;ft0ve;e2y;ight0lev1;!e0y;en;illions",
  "Multiple": "true\xA6b3hundred,m3qu2se1t0;housand,r2;pt1xt1;adr0int0;illion",
  "City": "true\xA60:76;1:64;2:6J;3:6M;4:5V;a6Bb56c4Ld4Be47f3Zg3Kh3Ci33j2Yk2Hl25m1Nn1Do1Ap0Xq0Vr0Os05tRuQvLwDxiBy9z5;a7h5i4Puri4R;a5e5ongsh0;ng3K;greb,nzib5J;ang2e5okoha3Vunfu;katerin3Krev0;a5n0R;m5Kn;arsBeAi6roclBu5;h0xi,zh5S;c7n5;d5nipeg,terth4;hoek,s1N;hi62kl3D;l66xford;aw;a8e6i5ladivost5Polgogr6N;en3lni6U;ni24r5;n2o3saill4Q;lenc4Zncouv3Vr3ughn;lan bat1Erumqi,trecht;aFbilisi,eEheDiBo9r7u5;l23n66r5;in,ku;i5ondh65;es54poli;kyo,m32ron1Rulo5;n,uS;an5jua3l2Wmisoa6Dra3;j4Wshui; hag64ssaloni2K;gucigal28hr0l av1W;briz,i6llinn,mpe59ng5rtu,shk2U;i3Hsh0;an,chu1n0p2Hyu0;aEeDh8kopje,owe1It7u5;ra5zh50;ba0It;aten is58ockholm,rasbou69uttga2Y;an8e6i5;jiazhua1llo1m5Zy0;f53n5;ya1zh4K;gh3Nt4T;att48o1Yv47;cramen18int ClBn5o paulo,ppo3Urajevo; 7aa,t5;a 5o domin3H;a3fe,m1O;antonBdie3Ffrancisco,j5ped3Qsalvad0L;o5u0;se;em,z28;lou5Bpeters27;aAe9i7o5;me,sar5t5C;io;ga,o5yadh;! de janei3H;cife,im3Lnn3Lykjavik;b4Uip4lei2Knc2Rwalpindi;ingdao,u5;ez2i0R;aFeEhDiCo9r7u6yong5;ya1;eb5Aya1;a5etor3O;g53to;rt5zn0; 5la4Eo;au prin0Nelizabe26sa04;ls3Rrae5Btts28;iladelph3Inom pe1Coenix;r23tah tik3G;dua,lerZnaji,r4Qt5;na,r34;ak46des0Lm1Or6s5ttawa;a3Xlo;an,d07;a7ew5ing2Hovosibir1Lyc; 5cast38;del26orlea46taip16;g8iro4Xn5pl2Yshv35v0;ch6ji1t5;es,o1;a1o1;a6o5p4;ya;no,sa0Y;aFeCi9o6u5;mb2Cni28sc40;gadishu,nt6s5;c15ul;evideo,pelli1Tre31;ami,l6n16s5;kolc,sissauga;an,waukee;cca,d5lbour2Omph43ndo1Essi3;an,ell5i3;in,\xEDn;cau,drAkass2Tl9n8r5shh4A;aca6ib5rakesh,se2M;or;i1Ty;a4EchFdal10i47;mo;id;aDeAi8o6u5vSy2;anMckn0Pdhia3;n5s angel27;d2g bea1O;brev2Ce3Mma5nz,sb2verpo29;!ss28; ma3Ai5;c5pzig;est17; p6g5ho2Xn0Dusan25;os;az,la34;aHharFiClaipeBo9rak0Eu7y5;iv,o5;to;ala lump4n5;mi1sh0;hi0Ilka2Ypavog4si5wlo2;ce;da;ev,n5rkuk;gst2sha5;sa;k5toum;iv;bIdu3llakuric0Rmpa3Fn6ohsiu1ra5un1Jwaguc0R;c0Qj;d5o,p4;ah1Uy;a7e6i5ohannesW;l1Wn0;dd36rusalem;ip4k5;ar2I;bad0mph1PnBrkutVs8taYz5\u0307zm7;m6tapala5;pa;ir;fah0l6tanb5;ul;am2Yi2H;che2d5;ianap2Mo20;aAe7o5yder2V; chi mi5ms,nolulu;nh;f6lsin5rakli2;ki;ei;ifa,lifax,mCn5rb1Dva3;g8nov01oi;aFdanEenDhCiPlasgBo9raz,u5;a5jr23;dal6ng5yaquil;zh1J;aja2Nupe;ld coa1Bthen5;bu2R;ow;ent;e0Uoa;sk;lw7n5za;dhi5gt1E;nag0U;ay;aisal28es,o8r6ukuya5;ma;ankfu5esno;rt;rt5sh0; wor6ale5;za;th;d5indhov0Pl paso;in5mont2;bur5;gh;aBe8ha0Xisp4o7resd0Lu5;b5esseldorf,nkirk,rb0shanbe;ai,l0I;ha,nggu0rtmu13;hradSl6nv5troit;er;hi;donghIe6k09l5masc1Yr es sala1KugavpiY;i0lU;gu,je2;aJebu,hAleve0Vo5raio02uriti1P;lo7n6penhag0Ar5;do1Nk;akKst0V;gUm5;bo;aBen8i6ongqi1ristchur5;ch;ang m7ca5ttago1;go;g6n5;ai;du,zho1;ng5ttogr14;ch8sha,zh07;gliari,i9lga8mayenJn6pe town,r5tanO;acCdiff;ber19c5;un;ry;ro;aWeNhKirmingh0WoJr9u5;chareTdapeTenos air7r5s0tu0;g5sa;as;es;a9is6usse5;ls;ba6t5;ol;ne;sil8tisla7zzav5;il5;le;va;ia;goZst2;op6ubaneshw5;ar;al;iCl9ng8r5;g6l5n;in;en;aluru,hazi;fa6grade,o horizon5;te;st;ji1rut;ghd0AkFn9ot8r7s6yan n4;ur;el,r06;celo3i,ranquil08;ou;du1g6ja lu5;ka;alo6k5;ok;re;ng;ers5u;field;a04b01cc00ddis abaZgartaYhmedWizawl,lSmPnHqaZrEsBt7uck5;la5;nd;he7l5;an5;ta;ns;h5unci2;dod,gab5;at;li5;ngt2;on;a8c5kaNtwerp;hora6o3;na;ge;h7p5;ol5;is;eim;aravati,m0s5;terd5;am; 6buquerq5eppo,giers,maty;ue;basrah al qadim5mawsil al jadid5;ah;ab5;ad;la;ba;ra;idj0u dha5;bi;an;lbo6rh5;us;rg",
  "Region": "true\xA60:2N;1:2T;2:2K;a2Qb2Dc1Zd1Ues1Tf1Rg1Lh1Hi1Cj18k13l10m0Pn07o05pZqWrTsKtFuCv9w5y3zacatec2U;akut0o0Du3;cat2k07;a4est 3isconsin,yomi1M;bengal,vi6;rwick2Bshington3;! dc;er4i3;rgin0;acruz,mont;dmurt0t3;ah,tar3; 2La0X;a5e4laxca1Rripu1Xu3;scaDva;langa1nnessee,x2F;bas0Vm3smNtar25;aulip2Dil nadu;a8i6o4taf11u3ylh1F;ffYrr04s1A;me1Cno1Quth 3;cVdU;ber0c3kkim,naloa;hu2ily;n4skatchew2xo3;ny; luis potosi,ta catari1;a3hode9;j3ngp07;asth2shahi;ingh25u3;e3intana roo;bec,en5reta0R;ara7e5rince edward3unjab; i3;sl0B;i,nnsylv3rnambu0B;an0;!na;axa0Ydisha,h3klaho20ntar3reg6ss0Bx0G;io;aJeDo5u3;evo le3nav0W;on;r3tt17va scot0;f8mandy,th3; 3ampton16;c5d4yo3;rk14;ako1N;aroli1;olk;bras1Mva0Cw3; 4foundland3;! and labrador;brunswick,hamp0Xjers4mexiSyork3;! state;ey;galOyarit;a9eghala0Mi5o3;nta1r3;dov0elos;ch5dlanCn4ss3zor11;issippi,ouri;as geraOneso18;ig2oac2;dhy12harasht0Gine,ni4r3ssachusetts;anhao,i el,ylF;p3toba;ur;anca0Ie3incoln0IouisH;e3iR;ds;a5e4h3omi;aka06ul1;ntucky,ra01;bardino,lmyk0ns0Qr3;achay,el0nata0X;alis5har3iangxi;kh3;and;co;daho,llino6n3owa;d4gush3;et0;ia1;is;a5ert4i3un2;dalFm0D;fordZ;mpYrya1waii;ansu,eorg0lou7oa,u3;an4erre3izhou,jarat;ro;ajuato,gdo3;ng;cesterS;lori3uji2;da;sex;ageTe6o4uran3;go;rs3;et;lawaLrbyK;aEeaDh8o3rimea ,umbr0;ahui6l5nnectic4rsi3ventry;ca;ut;i02orado;la;e4hattisgarh,i3uvash0;apQhuahua;chn4rke3;ss0;ya;ra;lFm3;bridge6peche;a8ihar,r7u3;ck3ryat0;ingham3;shi3;re;emen,itish columb0;h0ja cal7lk6s3v6;hkorto3que;st2;an;ar0;iforn0;ia;dygea,guascalientes,lAndhr8r4ss3;am;izo1kans4un3;achal 6;as;na;a 3;pradesh;a5ber4t3;ai;ta;ba4s3;ka;ma",
  "Country": "true\xA60:39;1:2M;a2Xb2Ec22d1Ye1Sf1Mg1Ch1Ai14j12k0Zl0Um0Gn05om3DpZqat1KrXsKtCu6v4wal3yemTz2;a25imbabwe;es,lis and futu2Y;a2enezue32ietnam;nuatu,tican city;.5gTkraiZnited 3ruXs2zbeE;a,sr;arab emirat0Kkingdom,states2;! of am2Y;k.,s.2; 28a.;a7haBimor-les0Bo6rinidad4u2;nis0rk2valu;ey,me2Ys and caic1U; and 2-2;toba1K;go,kel0Znga;iw2Wji2nz2S;ki2U;aCcotl1eBi8lov7o5pa2Cri lanka,u4w2yr0;az2ed9itzerl1;il1;d2Rriname;lomon1Wmal0uth 2;afr2JkLsud2P;ak0en0;erra leoEn2;gapo1Xt maart2;en;negKrb0ychellY;int 2moa,n marino,udi arab0;hele25luc0mart20;epublic of ir0Dom2Duss0w2;an26;a3eHhilippinTitcairn1Lo2uerto riM;l1rtugE;ki2Cl3nama,pua new0Ura2;gu6;au,esti2;ne;aAe8i6or2;folk1Hth3w2;ay; k2ern mariana1C;or0N;caragua,ger2ue;!ia;p2ther19w zeal1;al;mib0u2;ru;a6exi5icro0Ao2yanm05;ldova,n2roc4zamb9;a3gol0t2;enegro,serrat;co;c9dagasc00l6r4urit3yot2;te;an0i15;shall0Wtin2;ique;a3div2i,ta;es;wi,ys0;ao,ed01;a5e4i2uxembourg;b2echtenste11thu1F;er0ya;ban0Hsotho;os,tv0;azakh1Ee3iriba03o2uwait,yrgyz1E;rWsovo;eling0Jnya;a2erF;ma15p1B;c6nd5r3s2taly,vory coast;le of m19rael;a2el1;n,q;ia,oI;el1;aiSon2ungary;dur0Mg kong;aAermany,ha0Pibralt9re7u2;a5ern4inea2ya0O;!-biss2;au;sey;deloupe,m,tema0P;e2na0M;ce,nl1;ar;bTmb0;a6i5r2;ance,ench 2;guia0Dpoly2;nes0;ji,nl1;lklandTroeT;ast tim6cu5gypt,l salv5ngl1quatorial3ritr4st2thiop0;on0; guin2;ea;ad2;or;enmark,jibou4ominica3r con2;go;!n B;ti;aAentral african 9h7o4roat0u3yprQzech2; 8ia;ba,racao;c3lo2morPngo-brazzaville,okFsta r03te d'ivoiK;mb0;osD;i2ristmasF;le,na;republic;m2naTpe verde,yman9;bod0ero2;on;aFeChut00o8r4u2;lgar0r2;kina faso,ma,undi;azil,itish 2unei;virgin2; is2;lands;liv0nai4snia and herzegoviGtswaGuvet2; isl1;and;re;l2n7rmuF;ar2gium,ize;us;h3ngladesh,rbad2;os;am3ra2;in;as;fghaFlCmAn5r3ustr2zerbaijH;al0ia;genti2men0uba;na;dorra,g4t2;arct6igua and barbu2;da;o2uil2;la;er2;ica;b2ger0;an0;ia;ni2;st2;an",
  "Place": "true\xA6aVbTcPdOeNfMgIhHiFjfk,kDlBm9new eng8or7p5s4t2u1vostok,wake is8y0;akutDyz;laanbaatar,pP;ahiti,he 0;bronx,hamptons;akhalGfo,oho,under3yd;acifUek,h0itcairn;l,x;ange county,d;land;a0co,idHuc;gadRlibu,nhattR;a0gw,hr;s,x;osrae,rasnoyar0ul;sk;ax,cn,nd0st;ianKochina;arlem,kg,nd,ovd;ay village,re0;at 0enwich;brita0lakB;in;co,ra;urope,verglad8;en,fw,own2xb;dg,gk,h0lt;a1ina0uuk;town;morro,tham;cn,e0kk,rooklyn;l air,verly hills;frica,m7n2r3sia,tl1zor0;es;!ant2;adyr,tar0;ct0;ic0; oce0;an;ericas,s",
  "WeekDay": "true\xA6fri2mon2s1t0wednesd3;hurs1ues1;aturd1und1;!d0;ay0;!s",
  "Month": "true\xA6dec0february,july,nov0octo1sept0;em0;ber",
  "Date": "true\xA6ago,t0week end,yesterd2;mr2o0;d0morrow;ay;!w",
  "Duration": "true\xA6century,dAh9m6q5se4w1y0;ear,r;eek1k0;!s;!e4;ason,c;tr,uarter;i0onth;lliseco0nute;nd;our,r;ay,ecade",
  "FemaleName": "true\xA60:IS;1:IW;2:I5;3:I4;4:IM;5:I9;6:JD;7:GQ;8:J9;9:J5;A:HD;B:HN;C:IE;D:J2;E:II;F:H2;G:C4;H:HP;aGIbFDcDJdCSeBIfB0gAAh9Qi9Dj8Ck7Cl5Wm46n3Ko3Gp34qu33r2Bs16t0Fu0Dv03wWxiUyPzI;aMeJineb,oIsof2;e3Rf2la,ra;h3iLlJna,ynI;ab,ep;da,ma;da,h3iIra;nab;aLeKi0GolB3uJvI;etAonDH;i0na;le0sen2;el,gm3Gn,rGAs8T;aoIme0nyi;m5YyAA;aNendDRhiD8iI;dele9lKnI;if45niIo0;e,f44;a,helmi0lIma;a,ow;ka0nB;aOeLiIusa5;ck82kJlAole7viI;anGenIQ;ky,toriBE;da,lA5rIs0;a,nIoniGV;a,iFH;leInesGV;nI7rI;i1y;g9rIxGW;su5te;aZeVhSiOoMrJuIy3;i,la;acIPiIu0L;c2na,sI;hGta;nIr0H;iGya;aKffaEGnIs6;a,gtiI;ng;!nFHra;aJeIomasi0;a,l9Lo87res1;l2ndolwethu;g9Co85rJssI;!a,ie;eIi,ri8;sa,za;bPlNmLnJrIs6tia0wa0;a60yn;iIya;a,ka,s6;arGe3iIm75ra;!ka;a,iI;a,t6;at6it6;a0Gcarlett,e0ChYiUkye,neza0oStOuJyI;bI2lvi1;ha,mayI5ni7sJzI;an3KetAie,y;anIi8;!a,e,nI;aCe;aKeI;fIl5DphI;an4;cHQr5;b2fiA3m0MnIphi1;d3ia,ja,ya;er3lKmon1nJobh8MtI;a,i;dy;lEHv2;aNeJirIo0risEZy5;a,lDD;ba,e0i5lKrI;iIr6Gyl;!d8Efa;ia,lDP;hd,iNki3nKrJu0w0yI;la,ma,na;i,le9on,ron;aJda,ia,nIon;a,on;!ya;k6mI;!aa;lKrJtaye7YvI;da,inj;e0ife;en1i0ma;anA0bMd3Kh1PiBkLlKmJnd3rIs6vannaC;aCi0;ant6i3;lDEma,ome;ee0in8Ou3;in1ri0;a05e00hYiVoIuthDC;bTcSghRl8GnQsKwJxI;anAUie,y;an,e0;aJeIie,lD; merBIann8ll1marD6t7;!lInn1;iIyn;e,nI;a,dG;da,i,na;ayy8B;hel63io;bDFer7yn;a,cJkImas,nGta,ya;ki,o;helHki;ea,iannG7oI;da,n1L;an0bKemGgi0iJnIta,y0;a86ee;han81na;a,eI;cE5kaC;bi0chJe,i0mo0nIquEFy0;di,ia;aEDelIiB;!e,le;een4ia0;aOeNhLipaluk,oKrIute67;iIudenCL;scil3LyamvaB;lly,rt2;ilome0oebe,ylI;is,lis;ggy,nelope,r5t3;ige,m0UnLo5rvaDBtJulI;a,etAin1;ricIt4T;a,e,ia;do3i07;ctav2dJfCUis6lIphCUumBYyunbileg;a,ga,iv2;eIvA9;l2tA;aXeViNoJurIy5;!ay,ul;a,eKor,rJuI;f,r;aCeEma;ll1mi;aOcMhariBJkLlaKna,sIta,vi;anIha;ur;!y;a,iDNki;hoHk9SolI;a,eDE;!mh;hir,lIna,risFsreE;!a,lBO;asuMdLh2i6CnKomi8rgEJtIzanin zah3;aIhal4;li1s6;cy,etA;e9iEP;nngu30;a0Ackenz4e02iNoKrignayani,uriD8yI;a,rI;a,lOna,tH;bi0i3llBDnI;a,iI;ca,ka,qCY;a,cUkaTlOmi,nMrJtzi,yI;ar;aJiam,lI;anEI;!l,nB;dy,eIh,n4;nhHrva;aLdKiCKlI;iIy;cent,e;red;!gros;!e5;ae5hI;ae5el40;ag5EgOi,lLrI;edi77iJjem,on,yI;em,l;em,sF;an4iIliF;nIsC9;a,da;!an,han;b0DcANd0Be,g09ha,i08ja,l06n04rMsoum5YtLuJv80x9FyIz4;bell,ra,soB4;de,rI;a,eE;h8Cild1t4;a,cYgUiLjor4l7Qn4s6tKwa,yI;!aIbe6Uja9lA9;m,nBC;a,ha,in1;!aKbC6eJja,lDna,sIt62;!a,ol,sa;!l1H;! Kh,mJnI;!a,e,n1;!awit,i;aliACcJeduarBfern5EjIlui5W;o6Dul2;ecil2la3;arKeJie,oIr46ueriA;!t;!ry;et44i39;el4Vi75y;dIon,ue5;akran7y;ak,en,iIlo3Q;a,ka,nB;a,re,s4te;daIg4;!l3C;alDd4elIge,isD6on0;ei9in1yn;el,le;a0Oe0DiZoRuMyI;d2la,nI;!a,dJeBCnIsCG;!a,eBB;a,sCE;aCRcKel0QiFlJna,pIz;e,i7;a,u,wa;iIy;a0Te,ja,l2LnB;is,l1TrKttJuIvel4;el5is1;e,ie;aLeJi8na,rI;a84i8;lIn1t7;ei;!in1;aTbb98dSepa,lNnKsJv2zI;!a,be5KetAz4;a,etA;!a,dI;a,sIy;ay,ey,i,y;a,iKja,lI;iIy;a9We;!aI;!nG;ia,ya;!nI;!a,ne;aQda,e0iOjZla,nNoLsKtIx4y5;iIt4;c2t2;e2NlCB;la,nIra;a,ie,o3;a,or1;a,gh,laI;!ni;!h,nI;a,d3e,n5O;cPdon93iOkes6mi96na,rNtKurJvIxmi,y5;ern1in2;a,e53ie,yn;as6iJoI;nya,ya;fa,s6;a,isF;a,la;ey,ie,y;a05e00hYiPlAFoOrKyI;lIra;a,ee,ie;istIy6B;a,en,iJyI;!na;!e,n58;nul,ri,urtnAV;aPerOlAUmKrIzzy;a,stI;en,in;!berlJmernI;aq;eIi,y;e,y;a,stE;!na,ra;aIei3ongordzol;dij1w5;el7MiLjsi,lKnJrI;a,i,ri;d3na,za;ey,i,lB8s4y;ra,s6;bi7cAEdiat7EeAXiSlRmQnyakuma1BrOss6HtLvi7yI;!e,lI;a,eI;e,i8H;a6BeJhIi4MlDri0y;ar69er69ie,leErAXy;!lyn8Cri0;a,en,iIl5Qoli0yn;!ma,nGsF;a5il1;ei8Ai,l4;a,tl6I;a09eZiWoOuI;anMdLliIst61;a8DeIsF;!n9tI;!a,te;e5Hi3Iy;a,i7;!anOcelDdNelHhan7NleMni,sJva0yI;a,ce;eIie;fIlDph5S;a,in1;en,n1;i8y;!a,e,n40;lIng;!i1DlI;!i1C;anOle0nLrKsI;i88sI;!e,i87;i,ri;!a,elHif2AnI;a,etAiIy;!e,f28;a,e89iJnI;a,e88iI;e,n1;cNda,mi,nJque4UsminGvie3y9zI;min8;a8eJiI;ce,e,n1s;!lIsFt0G;e,le;inJk4lDquelI;in1yn;da,ta;da,lSmQnPo0rOsJvaIzaro;!a0lu,na;aKiJlaIob7Z;!n9H;do3;belIdo3;!a,e,l37;a72en1i0ma;di3es,gr6Tji;a9elBogI;en1;a,e9iIo0se;a0na;aTePiKoIusFyacin29;da,ll4rten21snI;a,i9K;lJmaI;ri;aJdIlaJ;a,egard;ry;ath1AiKlJnriet7rmi9sI;sa,t19;en2Qga,mi;di;bi2Bil8ClOnNrKsJtIwa,yl8C;i5Nt4;n5Tti;iImo4Xri4Y;etI;!te;aCnaC;a,ey,l4;a03eXiSlQoOrLunKwI;enIyne1O;!dolD;ay,el;acieJetIiselB;a,chE;!la;ld19ogooI;sh;adys,enIor2yn2G;a,da,na;aLgi,lJna,ov84selIta;a,e,le;da,liI;an;!n0;mMnKorgJrI;ald3Ni,m3Atru86;etAi4S;a,eIna;s25vieve;ma;bJle,mIrnet,yH;al5Ji5;i5BrielI;a,l1;aUeRiQlorPoz2rI;anKeJiI;da,eB;da,ja;!cI;esJiIoi0N;n1s5X;!ca;a,enc2;en,o0;lJn0rnI;anB;ec2ic2;jr,n7rLtIy8;emJiIma,ouma7;ha,ma,n;eh;ah,iBrah,za0;cr4Ld0Oe0Ni0Mk7l05mXn4WrUsOtNuMvI;aKelJiI;!e,ta;inGyn;!ngel2S;geni1ni43;h5Qta;mMperanLtI;eJhIrel5;er;l2Zr8;za;a,eralB;iIma,nest2Jyn;cIka,n;a,ka;a,eNiKmI;aIie,y;!li9;lIn1;ee,iIy;a,e,ja;lIrald;da,y;aXeViOlNma,no3oLsKvI;a,iI;na,ra;a,ie;iIuiI;se;a,en,ie,y;a0c2da,f,nNsKzaI;!betIve7;e,h;aIe,ka;!beI;th;!a,or;anor,nG;!a;!in1na;leEs6;vi;eJiIna,wi0;e,th;l,n;aZeNh2iMjeneLoI;lor5Qminiq4Gn3DrItt4;a,eEis,la,othIthy;ea,y;ba;an0AnaCon9ya;anRbQde,ePiNlKmetr2nIsir5H;a,iI;ce,se;a,iJla,orIphi9;es,is;a,l6A;dIrdI;re;!d59na;!b2ForaCraC;a,d3nI;!a,e;hl2i0l0HmOnMphn1rJvi1WyI;le,na;a,by,cJia,lI;a,en1;ey,ie;a,etAiI;!ca,el1Bka,z;arIia;is;a0Se0Oh05i03lVoKristJynI;di,th2;al,i0;lQnNrJurI;tn1E;aKd2MiIn2Mri9;!nI;a,e,n1;!l4;cepci57n4sI;tanIuelo;ce,za;eIleE;en,tA;aKeoJotI;il4Z;!pat3;ir8rKudI;etAiI;a,ne;a,e,iI;ce,s00;a3er3ndI;i,y;aSeOloe,rI;isKyI;stI;al;sy,tI;a1Qen,iIy;an1e,n1;deKlseJrI;!i8yl;a,y;li9;nNrI;isLlJmI;ai9;a,eIotA;n1tA;!sa;d3elHtI;al,elH;cJlI;esAi42;el2ilI;e,ia,y;itlZlYmilXndWrOsMtIy5;aKeKhIri0;erIleErDy;in1;ri0;a32sI;a31ie;a,iOlMmeKolJrI;ie,ol;!e,in1yn;lIn;!a,la;a,eIie,o7y;ne,y;na,sF;a0Hi0H;a,e,l1;is7l4;in,yn;a0Ie02iZlXoUrI;andi8eRiKoJyI;an0nn;nwDoke;an3CdgMg0XtI;n2WtI;!aJnI;ey,i,y;ny;etI;!t8;an0e,nI;da,na;bbi8glarJlo06nI;i7n4;ka;ancIythe;a,he;an18lja0nIsm3I;i7tI;ou;aVcky,linUni7rQssPtKulaCvI;!erlI;ey,y;hKsy,tI;e,iIy8;e,na;!anI;ie,y;!ie;nIt6yl;adJiI;ce;etAi9;ay,da;!triI;ce,z;rbKyaI;rmI;aa;a3o3ra;a2Sb2Md23g1Zi1Qj5l16m0Xn0Aoi,r05sVtUuQvPwa,yJzI;ra,u0;aLes6gKlJseI;!l;in;un;!nI;a,na;a,i2I;drKgus1RrJsteI;ja;el2;a,ey,i,y;aahua,he0;hJi2Gja,mi7s2DtrI;id;aNlJraqIt21;at;eJi8yI;!n;e,iIy;gh;!nI;ti;iKleJo6pi7;ta;en,n1tA;aIelH;!n1J;a01dje5eZgViTjRnKohito,toIya;inetAnI;el5ia;!aLeJiImK;e,ka;!mItA;ar4;!belJliFmV;sa;!le;a,eliI;ca;ka,sIta;a,sa;elIie;a,iI;a,ca,n1qI;ue;!tA;te;!bJmIstasiNya;ar2;el;aMberLeliKiIy;e,l2naI;!ta;a,ja;!ly;hHiJl2nB;da;a,ra;le;aXba,eQiNlLthKyI;a,c2sI;a,on,sa;ea;iIys0O;e,s0N;a,cJn1sIza;a,e,ha,on,sa;e,ia,ja;c2is6jaLksaLna,sKxI;aIia;!nd3;ia,saI;nd3;ra;ia;i0nJyI;ah,na;a,is,naCoud;la;c6da,leEmOnMsI;haClI;inIyZ;g,n;!h;a,o,slI;ey;ee;en;at6g4nJusI;ti0;es;ie;aXdiUelNrI;eKiI;anNenI;a,e,ne;an0;na;!aMeLiJyI;nn;a,n1;a,e;!ne;!iI;de;e,lDsI;on;yn;!lI;i9yn;ne;aLbJiIrM;!gaL;ey,i8y;!e;gaI;il;dLliyKradhJs6;ha;ya;ah;a,ya",
  "FirstName": "true\xA6aLblair,cHdevGgabrieFhinaEjCk9l8m4nelly,quinn,re3s0;h0umit;ay,e0iloh;a,lby;g6ne;a1el0ina,org5;!okuh9;naia,r0;ion,lo;ashawn,uca;asCe1ir0rE;an;lsAnyat2rry;am0ess6ie,ude;ie,m5;ta;le;an,on;as2h0;arl0eyenne;ie;ey,sidy;lex2ndr1ubr0;ey;a,ea;is",
  "LastName": "true\xA60:9G;1:9W;2:9Y;3:9O;4:9I;5:8L;6:9L;7:A1;8:9F;9:8A;A:78;B:6G;C:6K;a9Vb8Nc7Ld6Ye6Tf6Fg5Wh59i55j4Qk45l3Nm2Sn2Fo27p1Oquispe,r18s0Ft05vVwOxNyGzD;aytsAEhD;aDou,u;ng,o;aGeun81iDoshiAAun;!lD;diDmaz;rim,z;maDng;da,guc98mo6VsDzaA;aAhiA8;iao,u;aHeGiEoDright,u;jc8Tng;lDmm0nkl0sniewsA;liA2s2;b0iss,lt0;a5Tgn0lDtanabe;k0sh;aHeGiEoDukB;lk5roby5;dBllalDnogr2Zr10ss0val37;ba,obos;lasEsel7P;lGn dFrg8FsEzD;qu7;ily9Pqu7silj9P;en b35ijk,yk;enzue96verde;aLeix1KhHi3j6ka3IoGrFsui,uD;om50rD;c3n0un1;an,embl8UynisA;dor96lst31m4rr9th;at5Ni7NoD;mErD;are70laci65;ps2s0Z;hirBkah8Enaka;a01chXeUhQiNmKoItFuEvDzabo;en8Bobod34;ar7bot4lliv3zuA;aEein0oD;i68j3Myan8W;l6rm0;kol5lovy5re6Rsa,to,uD;ng,sa;iDy60;rn5tD;!h;l5ZmEnDrbu;at8gh;mo6Eo6K;aFeDimizu;hu,vchD;en7Duk;la,r17;gu8mDoh,pulve8Trra4S;jDyD;on5;evi6Giltz,miDneid0roed0ulz,warz;dEtD;!z;!t;ar42h6ito,lFnDr4saAto,v4;ch7d0AtDz;a4Pe,os;as,ihBm3Zo0Q;aOeNiKoGuEyD;a67oo,u;bio,iz,sD;so,u;bEc7Bdrigue57g03j73mDosevelt,ssi,ta7Nux,w3Z;a4Ce0O;ertsDins2;!on;bei0LcEes,vDzzo;as,e8;ci,hards2;ag3es,it0ut0y9;dFmEnDsmu7Zv5F;tan1;ir7os;ic,u;aSeLhJiGoErDut6;asad,if60ochazk1V;lishc23pDrti63u55we67;e2Tov48;cEe09nD;as,to;as61hl0;aDillips;k,m,n5L;de3AetIna,rGtD;ersErovDtersC;!a,ic;en,on;eDic,ry,ss2;i8ra,tz,z;ers;h71k,rk0tEvD;ic,l3T;el,t2O;bJconnor,g2ClGnei5QrEzD;demir,turk;ella3MtDwe5O;ega,iz;iDof6GsC;vDyn1E;ei8;aPri1;aLeJguy1iFoDune44ym3;rodahl,vDwak;ak3Uik5otn57;eEkolDlsCx2;ic,ov6X;ls1miD;!n1;ils2mD;co42ec;gy,kaEray3varD;ro;jiDmu8shiD;ma;aWcUeQiPoIuD;lGnFrDssoli5T;atDpTr68;i,ov4;oz,te4C;d0l0;h3lInr13o0GrEsDza0Y;er,s;aFeEiDoz5r3Ete4C;!n6F;au,i8no,t4N;!l9;i2Rl0;crac5Ohhail5kke3Qll0;hmeFij0j2FlEn2Xrci0ssiDyer19;!er;n0Io;dBti;cartDlaughl6;hy;dMe6Egnu5Fi0jer35kLmJnci5ArFtEyD;er,r;ei,ic,su1O;iEkBqu9roqu6tinD;ez,s;a55c,nD;!o;a53mD;ad5;e5Pin1;rig4Ps1;aSeMiIoGuEyD;!nch;k4nDo;d,gu;mbarDpe2Svr4;di;!nDu,yana1T;coln,dD;bDholm;erg;bed5UfeGhtFitn0kaEn6rDw2H;oy;!j;in1on1;bvDvD;re;iDmmy,rsCu,voie;ne,t12;aTennedy,h3iSlQnez48oJrGuEvar3woD;k,n;cerDmar59znets5;a,o2H;aDem0i31yeziu;sni3RvD;ch3W;bay4Grh0Ksk0UvaFwalDzl5;czDsA;yk;cFlD;!cDen3S;huk;!ev4ic,s;e6uiveD;rt;eff0l4mu8nnun1;hn,llFminsArEstra33to,ur,yDzl5;a,s0;j0HlsC;oe;aMenLha2Qim0RoEuD;ng,r4;e2KhFnErge2Ku2OvD;anB;es,ss2;anEnsD;en,on,t2;nesDsC;en,s1;ki27s1;cGkob3RnsDrv06;en,sD;enDon;!s;ks2obs1;brahimBglesi3Ake4Ll0DnoZoneFshikEto,vanoD;u,v4A;awa;scu;aPeIitchcock,jaltal6oFrist46uD;!aDb0gh9ynh;m3ng;a24dz4fEjga2Tk,rDx3B;ak0Yvat;er,fm3B;iGmingw3NnErD;nand7re8;dDriks1;ers2;kkiEnD;on1;la,n1;dz4g1lvoLmJnsCqIrr0SsFuEyD;as36es;g1ng;anEhiD;mo0Q;i,ov08;ue;alaD;in1;rs1;aNeorgMheorghe,iKjonJoGrEuDw2;o,staf2Utierr7zm3;ayDg4iffitVub0;li1H;lub3Rme0JnEodD;e,m3;calv9zale0H;aj,i;bs2l,mDordaL;en7;iev3A;gnJlGmaFnd2Mo,rDs2Muthi0;cDza;ia;ge;eaElD;agh0i,o;no;e,on;ab0erLiHjeldsted,lor9oFriedm3uD;cDent9ji3E;hs;ntaDrt6urni0;na;lipEsD;ch0;ovD;!ic;hatBnanFrD;arDei8;a,i;deS;ov4;dGinste6riksCsDva0D;cob2YpDtra2W;inoza,osiL;en,s2;er,is2wards;aUeMiKjurhuJoHrisco0ZuEvorakD;!oQ;arte,boEmitru,rDt2U;and,ic;is;g3he0Imingu7n2Ord1AtD;to;us;aDmitr29ssanayake;s,z; GbnaFlEmirDrvis1Lvi,w3;!ov4;gado,ic;th;bo0groot,jo04lEsilDvri9;va;a cruz,e2uD;ca;hl,mcevsAnEt2EviD;d5es,s;ieDku1S;ls1;ki;a06e01hOiobNlarkMoFrD;ivDuz;elli;h1lHntGoFrDs26x;byn,reD;a,ia;ke,p0;i,rer0N;em3liD;ns;!e;anu;aLeIiu,oGriDuJwe;stD;eDiaD;ns1;i,ng,uFwDy;!dhury;!n,onEuD;ng;!g;kEnDpm3tterjee,v7;!d,g;ma,raboD;rty;bGl08ng4rD;eghetEnD;a,y;ti;an,ota0L;cer9lder2mpbeIrFstDvadi07;iDro;llo;doEt0uDvalho;so;so,zo;ll;es;a08eWhTiRlNoGrFyD;rne,tyD;qi;ank5iem,ooks,yant;gdan5nFruya,su,uchEyHziD;c,n5;ard;darDik;enD;ko;ov;aEondD;al;nco,zD;ev4;ancRshwD;as;a01oDuiy3;umDwmD;ik;ckNethov1gu,ktLnJrD;gGisFnD;ascoDds1;ni;ha;er,mD;ann;gtDit7nett;ss2;asD;hi;er,ham;b4ch,ez,hMiley,kk0nHrDu0;bEnDua;es,i0;ieDosa;ri;dDik;a8yopadhyD;ay;ra;er;k,ng;ic;cosZdYguilXkhtXlSnJrGsl3yD;aEd6;in;la;aEsl3;an;ujo,ya;dFgelD;ovD;!a;ersGov,reD;aDjL;ss1;en;en,on,s2;on;eksejGiyGmeiFvD;ar7es;ez;da;ev;ar;ams;ta",
  "MaleName": "true\xA60:DN;1:CO;2:D6;3:AJ;4:CK;5:BZ;6:CF;7:D2;8:BS;9:AR;A:DA;B:D3;C:94;D:BM;aC9bB7cA7d98e8If82g7Fh6Si6Cj5Ek52l4Fm37n2Uo2Op2Gqu2Er1Ms12t0Gu0Fv08wUxTyJzE;aEor0;cEh9Jkaria,n0C;hFkE;!aC7;ar5UeC6;aMoGuE;sEu2LvBJ;if,uf;nGsFusE;ouf,sE;ef;aEg;s,tE;an,h0;hli,nB8ssY;avi3ho4;aNeLiGoEyaBN;jcie87lfgang,odrow,utE;!er;lEnst1;bGey,fredAlE;aAZiE;am,e,s;e97ur;i,nde9sE;!l8t1;lFyE;l1ne;lEt3;a9Xy;aHiEladimir,ojte7U;cFha0kt67nceErgA5va0;!nt;e3Xt65;lentEn9S;inE;!e;ghBElyss59nax,sm0;aXeShOiMoIrGuFyE;!l3ro6s1;n7r59;avAHeEist0oy,um0;ntA9v5Wy;bGd8RmEny;!as,mEoharu;aCBie,y;iCy;mEt5;!my,othy;adGeoFia0KomE;!as;!do8G;!de5;dHrE;en98rE;an97eEy;ll,n96;!dy;dgh,ha,iEnn3req,tsu4R;cAPka;aUcotSeQhMiKoIpenc3tEur1Xylve96zym1;anGeEua85;f0phBCvEwa84;e5Zie;!islaw,l8;lom1uE;leyma6ta;dElCm1yabonga;!dhart74n8;aGeE;lErm0;d1t1;h7Kne,qu11un,wn,y6;aEbasti0k2Cl4Prg4Mth,ymoAE;m5n;!tE;!ie,y;lFmEnti2Gq58ul;!ke5JmDu4;ik,vato7O;aZeVhe9ViRoIuFyE;an,ou;b7DdFf5pe7KssE;!elBI;ol3Fy;an,bLc62dJel,geIh0landAmHnGry,sFyE;!ce;coe,s;!aA1nD;an,eo;l45r;er78g3n8olfo,riE;go;bDeAQ;cEl8;ar6Ic6HhFkEo;!ey,ie,y;a8Vie;gFid,ubByEza;an1KnZ;g9SiE;na9Os;ch6Qfa4lImHndGpha4sFul,wi2HyE;an,mo6U;h7Jm5;alAWol2Uy;iACon;f,ph;ent2inE;cy,t1;aJeHhilGier6TrE;aka18eE;m,st1;!ip,lip;dA4rcy,tE;ar,e3Er1Y;b4Hdra73tr6JulE;!o19;ctav3Di3liv3m9Yndrej,rIsFtEum7wB;is,to;aFc7k7m0vE;al5S;ma;i,vM;aMeKiGoEu38;aEel,j5l0ma0r3I;h,m;cFg4i46kEl2R;!au,h7Gola;hEkEolC;olC;al,d,il,ls1vE;il8J;hom,tE;e,hE;anEy;!a4i4;a00eXiNoIuFyE;l2Gr1;hamFr6KstaE;fa,p54;ed,mI;di0Xe,hamGis2CntFsEussa;es,he;e,y;ad,ed,mE;ad,ed;cJgu4hai,kHlGnFtchE;!e9;a7Uik;house,o0Ct1;ae5Oe9MolE;aj;ah,hE;aFeE;al,l;el,l;hFlv2rE;le,ri9v2;di,met;ay0hUjd,ks2AlSmadXnRrLs1tGuricFxE;imilianAwe9;e,io;eHhFiCtEus,yC;!eo,hew,ia;eEis;us,w;j,o;cIio,kHlGqu6Ysha9tEv2;iEy;!m,n;in,on;el,oQus;!el90oPus;iHu4;achEcolm,ik;ai,y;amFdi,eEmoud;sh;adEm5G;ou;aXeRiPlo39oLuFyE;le,nd1;cHiGkEth3uk;aEe;!s;gi,s,z;as,iaE;no;g0nn7BrenGuEv81we9;!iE;e,s;!zo;am,oE;n4r;a7Uevi,la4AnIonHst3thaGvE;eEi;nte;bo;!a6Del;!ny;mFnd1rEur54wr54;ry,s;ar,o4Y;aMeIhal7GiFristEu4Ky6J;i0o54;er0p,rE;k,ollE;os;en0iGnErmit,v3U;!dr3XnEt1;e18y;r,th;cp3j5m5Sna6OrFsp7them,uE;ri;im,l;a01eViToHuE;an,lEst2;en,iE;an,en,o,us;aOeMhnLkubCnJrHsE;eFhEi7Vue;!ua;!ph;dEge;i,on;!aEny;h,s,th55;!ath54ie,nD;!l,sEy;ph;o,qu2;an,mE;!mD;d,ffHrEs5;a5YemFmai6oEry;me,ni0Y;i7Fy;!e5OrE;ey,y;cLdBkJmIrGsFvi3yE;dBs1;on,p3;ed,od,rEv4V;e5Bod;al,es4Mis1;a,e,oEub;b,v;ob,quE;es;aXbRchiQgOkeNlija,nuMonut,rKsGtEv0;ai,suE;ki;aFha0i6ZmaEsac;el,il;ac,iaE;h,s;a,vinEw2;!g;k,nngu5F;!r;nacEor;io;ka;ai,rahE;im;aQeKoJuEyd7;be2FgHmber4KsE;eyFsE;a2e2;in,n;h,o;m3ra36sse2wa40;aIctHitHnrFrE;be28m0;iEy;!q0Z;or;th;bMlLmza,nKo,rGsFyE;a47dB;an,s0;lGo4Nry,uEv8;hi44ki,tE;a,o;an,ey;k,s;!im;ib;aWeSiQlenPoMrIuE;ilFsE;!tavo;herme,lerE;mo;aGegEov3;!g,orE;io,y;dy,h5J;nzaFrE;an,d1;lo;!n;lbe4Xno,oE;rg37van4X;oGrE;aEry;ld,rdA;ffr8rge;brFlBrEv2;la14r3Hth,y;e33ielE;!i5;aSePiNlLorrest,rE;anFedEitz;!dDer11r11;cGkE;!ie,lE;in,yn;esLisE;!co,z2W;etch3oE;yd;d4lEonn;ip;deriFliEng,rnan05;pe,x;co;bi0di,hd;dYfrXit0lSmLnIo2rGsteb0th0uge6vEymBzra;an,eE;ns,re2X;gi,i0AnErol,v2w2;estAie;oFriqEzo;ue;ch;aJerIiFmE;aIe2Q;lErh0;!iE;o,s;s1y;nu4;be0Bd1iGliFm3t1viEwood;n,s;ot1Ss;!as,j4EsE;ha;a2en;!d2Vg7mHoFuFwE;a26in;arE;do;oWuW;a02eRiPoHrag0uGwFylE;an,l0;ay6ight;a6dl8nc0st2;minHnFri0ugEvydCy29;!lC;!a2HnEov0;e9ie,y;go,iFykC;as;cEk;!k;armuEll1on,rk;id;andNj0lbeMmetri5nKon,rIsGvFwExt3;ay6ey;en,in;hawn,moE;nd;ek,rE;ick;is,nE;is,y;rt;re;an,le,mLnKrGvE;e,iE;!d;en,iGne9rEyl;eEin,yl;l35n;n,o,us;!i4ny;iEon;an,en,on;a08e06hYiar0lOoJrHuFyrE;il,us;rtE;!is;aEistob0S;ig;dy,lHnFrE;ey,neli5y;or,rE;ad;by,e,in,l2t1;aIeGiEyK;fEnt;fo0Et1;meEt5;nt;rGuFyE;!t1;de;enE;ce;aIeGrisE;!toE;ph3;st3;er;d,rEs;b4leE;s,y;cEdric,s7;il;lHmer1rE;ey,lFro9y;ll;!os,t1;eb,v2;a07eZiVlaUoSrFuEyr1;ddy,rtL;aMeHiGuFyE;an,ce,on;ce,no;an,ce;nFtE;!t;dFtE;!on;an,on;dFndE;en,on;!foEl8y;rd;bby,rEyd;is;i6ke;bGlFshE;al;al,lD;ek;nIrEshoi;at,nFtE;!r1B;aEie;rdA;!iFjam2nD;ie,y;to;kaNlazs,nIrE;n8rEt;eEy;tt;ey;dEeF;ar,iE;le;ar16b0Ud0Qf0Ogust2hm0Li0Ija0Hl03mZnSputsiRrIsaHugust5veFyEziz;a0kh0;ry;us;hi;aLchKiJjun,maInGon,tEy0;hEu09;ur;av,oE;ld;an,ndA;!el,ki;ie;ta;aq;as,dIgelAtE;hony,oE;i6nE;!iAy;ne;er,reEy;!as,i,s,w;iGmaEos;nu4r;el;ne,r,t;an,beQdBeKfIi,lHonGphYt1vE;aOin;on;so,zo;an,en;onUrE;ed;c,jaHksandGssaHxE;!andE;er,ru;ar,er;ndE;ro;rtA;ni;dBm7;ar;en;ad,eE;d,t;in;onE;so;aFi,olfAri0vik;!o;mEn;!a;dIeHraFuE;!bakr,lfazl;hEm;am;!l;allJelGoulaye,ulE;!lErG;ah,o;! rE;ahm0;an;ah;av,on",
  "Person": "true\xA6ashton kutchYbXcSdQeOgastThMinez,jLkKleJmFnEoDpBr5s4t2va1w0;arrHednesday adams,oode;lentino rossi,n go5;a0heresa may,iger woods,yra banks;tum,ylor;addam hussain,carlett johanssOlobodan milosevic;ay romano,e4o2u0;n dmc,sh limbau0;gh;d stewart,nald0;inho,o;ese witherspoIil6;a0ipM;lmLris hiltG;prah winfrIra;ettAiles crane;essia2i0ubarek;randa ju0tt romnF;ly;en;bron james,e;anye west,endall,iefer sutherland,obe bryant;aime,effers7k rowling;a0itlBulk hogan;lle berry,rris5;ff0meril lagasse,zekiel;ie;a0enzel washingt2ick wolf;lt1nte;ar1lint0;on;dinal wols1son0;! palm2;ey;arack obama,rock;er",
  "Adjective": "true\xA60:8H;1:9N;2:8E;3:9E;4:8B;5:98;6:8M;7:8T;8:86;9:99;A:8W;B:7Z;C:60;D:9D;E:7J;a80b7Ic6Wd6Fe5Xf5Cg54h4Ui3Ujuni49k3Rl3Hm34n2Uo2Fp20quart6Ar1Qs0Ut0MuRvNwFye1M;ast58eKhIiHoF;man4oFrthwhi7u0I;dBzy;despr8Zn w7Cs6N;acked0XoleF;!sa7;ather14eFll o5Pste2Q;!k4;aHeGiFola5J;b9Qce versa,gi2Qle;ng4Yrsa5H;ca1lu8U;lt08nLpHrGsFttermo9I;efEu5;b7Age1; Hb2ApGsFti8H;ca7et,ide d3P;er,i4O;f3Xto da3;aYbecom2cXdSeRfPiOkn3MmNpMrJsGto49us0wF;a08iel2N;eBi2Fo47pGuF;pervis0spect2;e1okB;eFu4;cognTgul0NlFsolv0;at0ent2;aArecede01;arri0et;que,vers5;air,orF;eseBtun7S;mploy0nd2xpect0;eFisclos0ue;cid0rF;!a75covCly2sJwF;aFei7W;tCy;heck0onvinc2;ppeal2ssum2tteGuthorF;iz0;nd0;im4Bra;aKeHhough5Jip 1RoGrF;anspare1i3;gethCle8Qp notch,rpA;ena6UmpGrF;r3Ktia8;e9o76;leFst3V;nt0;a09c05e02h01iZkiYle5Mmug,nobbi46oTpQqueami46tKuFymb7L;bHi generis,pFr4;erFre69;! dupCb,vi00;du0p5HsFurb65;eq7Rtanda8C;atu6OeJi0WrFy3Z;aightGin4LungF; o25; fFfF;or6C;adfa84ri7;arGeFirit0lendAot on;c33e1F;k4se; call0lub7mbCphisticIrHuFviT;ndFth10;proof;dAry;at0;ll0n d6C;g22nF;ce5Mg7;am36eC;co1Lem4lfGnFre6;so8; suf45i3G;aGholFient2P;ar4;rlFth2;et;cr0me,tisfac5Z;aNeIheumatoAiGoF;bu7IttBy5;ghtFv5;-w2fE;cIdu79lHnown0sFtard0;is3JoF;lu3na1;e1Duc3H;e1ondi3;bAci5;aQeOicayu6laNopuli79rGuF;bl6Fnjabi;eKiIoF;b6HfGmi3IpFvBx23;er,ort6N;a6u6Q;maFor,sti6va3;!ry;ci6Nexist2ma1UpaA;cAid;ac2Dnt2XrFti3;feDma3Ati3Av6J;i2DrtFss6F;-4RiF;al,s4P;bQffOkNld MnKrJthCutIverF;!aGni5Vseas,t,wF;ei5Urou5U;ll;do14er,si51;d34g1U; bFbFe on o6go2li6;oa6P;fashion0school;!ay; gua6MbFli6;eat;eGsF;ce6er0Io0Z;dia1se;aNeMiLoFuanc0; mo47nHrthFt5P;!eF;rn;chaGdescri6Aprof2JsF;top;la1;ght4;arby,cessa8ighbor4xt;k0usiat2;aNeMiKoGuF;dHltip7;deHlGnFot,st;ochro3Yth4;dy;rn,st;ddle ag0nF;dblVi;ga,nac2re;cHgenta,in,j0Akeshift,mmGnFscu50;da4Ay;ali3Ooth;ab3Mho;aNeKiIoFumber2;ngFuti1I;stand2tF;erm,i3L;ghtwei4QteraF;l,te;ft-w2gFssCth5;al,eFit0I;nda8;nguAps0te4;apGind4nF;ow2;ut;ce co0Dgno5Kll09m01nHpso 2ErF;a3releF;va1; WaVcoSdPe2MfOgrNhibi3Ri02nMoLsHtFvalu4N;aDeF;n4Wrdep24;a6iGolFuboI;ub7ve1;de,gF;nifica1;rdi4O;a3er;own;eriGluenSreq4J;eGiIoFul1E;or;fini3p1Ttermi4I;mpGnside9rF;reD;le3;ccu9deq4Jppropr3Q;fFsitu,vitro;ro1;mJpF;arHeGl0YoFropC;li3r0V;nd2rfeD;ti5;aGeFi0Z;d3Hn48;tu2E;egGiF;c0Rte9;al,itF;ima3;ld;aMelLiJoFuma6;meHnGrrFs0Bur4;if3K;e4Co30; ma2Msick;ghfalut1VspF;an3G;liZpfE;i8llow0ndFrd05tL;sy,y;aiLener3Ciga2Jlob5oKraHuF;ilFng ho;ty;cGtF;efEis;efE;ldBod;nfE;aWeTiRlPoIrF;aGeFil4ozB;q3CtfE;gi7nt31;lk0WoJrF; keeps,eHge0OmCtunFwa3U;ateF;!ly;go2i1Os2Z;liF;sh;ag3Rowe8uF;e1oresce1;e8nF;al,i3;dGmini6rF;ti7; up;bl0l31mili0Lr Fux;oFreach2;ff;aTfSlQmNnLqu5reDthere5veryday,xF;aDem3AplIquisi3traHuF;be3FlF;ta1;!va1V;icF;it; Fti0Y;rou3sui3;erGiF;ne1;ge1;dFe1N;er4;ficie1;gCsF;t,ygo2;er;aUeMiHoGrFue;ea8owW;mina1ne,rma1ubO;dact1Yfficult,m,sGverF;ge1se;creGeNjoi1pa9tF;a1inD;et,te; Ladp0GceKfiJgene9liHpGreliDspe9voF;id,ut;ende1;ca3ghF;tfE;a1ni3;as0;facto;i4ngero05;arZeXhWivil,oMrHuF;stoma8teF;sy;aIeHu0WystalF; cleFli6;ar;epy;vBz0;erNgniza1loMmLnGrpo9veF;rt;cIduLgr1KjHsGtraF;dic0Hry;eq1Ita1;oi1ug5;a1Ci1L;mensu9pass1G;ni5ss5;ci19;ee8intzy;leba3rtaF;in;diac,efE;aUeOiJliSoGrFuck nak0;and new,isk,on1U;gGldface,naF; fiZfiZ;us;gHpartisGzarF;re;an;tiF;me;autifEhiIloHnFsiSyoI;e01iFt;gn;v0w;nd;ul;ckwards,rF;e,rB; priori,b12c0Zd0Tf0Ng0Ih0Hl0Amp7nt07pZrSsPttracti0MuLvIwF;aGkF;wa19;ke,re;ant garGeraF;ge;de;diHtF;heFoimmu6;nt07;to8;hBlF;eep;en;bitJchiv5roItF;iFsy;fiF;ci5;ga1;ra8;ry;pFt;aJetiz2roF;prHximF;ate4;ly;ia3;ll2re1;ing;iquFsy;at0e;ed;cohJiQkaHl,oGriFterW;ght;ne,of;li6;ne;olF;ic;ead;ain05ed,gressiIrF;eeF;ab7;le;ve;fGraA;id;ectGlF;ue1;ioF;na3; JeHvF;erF;se;pt,qF;ua3;hoc,infinitum;cu9tu5u3;al;ra3;erQlOoMrJsGuF;nda1;e1olu3traD;ct;te;eaGuF;pt;st;aFve;rd;aFe;ze;ra1;nt",
  "Adverb": "true\xA6a08b05d01eXfRhePinOjustNkinda,likewi00mLnIoDpBquite,r8s4t1up0very,well; to,wards5;h1iny bit,o0wiO;o,t6;en,us;eldom,o0uch;!me1rt0; of;how,times,w0A;a1e0;alT;ndomSthN;ar excellenEer0oint blank; Nhaps;f3n0;ce0ly;! 0;ag03moX; courIten;ewKo0; longEt 0;onIwithstanding;aybe,eanwhiAore0;!ovB;! aboV;deed,steW;lla,n0;ce;or2u0;lArther0;!moK; 0ev3;examp0good,suI;le;n1v0;er; mas0ough;se;e0irect1; 1finite0;ly;ju9trop;ackward,y 0;far,no0; means,w; DbroCd nauseam,gBl6ny3part,s2t 0w4;be6l0mo6wor6;arge,ea5; soon,ide;mo1w0;ay;re;l 1mo0ready,so,ways;st;b1t0;hat;ut;ain;ad;lot,posteriori",
  "Conjunction": "true\xA6aVbRcuz,eNhowMiEjustYnoBo9p8supposing,t5wh0yet;e1il0o3;e,st;n1re0thN; if,vM;evL;h0o;erefMo0;!uS;lus,rovided th9;r0therwiK;! not; mattEr,w0;! 0;since,th4w7;f4n0; 0asmuch;as mGcaDorder t0;h0o;at;! 0;only,t0w0;hen;!ev3;ith2ven0;! 0;if,t9;er;e0ut,y the time;cau1f0;ore;se;lt3nd,s 0;far1if,m0soon1t2;uch0; as;hou0;gh",
  "Currency": "true\xA6$,aud,bQcOdJeurIfHgbp,hkd,iGjpy,kElDp8r7s3usd,x2y1z0\xA2,\xA3,\xA5,\u0434\u0435\u043D,\u043B\u0432,\u0440\u0443\u0431,\u0E3F,\u20A1,\u20A8,\u20AC,\u20AD,\uFDFC;lotyQ\u0142;en,uanP;af,of;h0t5;e0il5;k0q0;elK;oubleJp,upeeJ;e2ound st0;er0;lingG;n0soF;ceEnies;empi7i7;n,r0wanzaCyatC;!onaBw;ls,nr;ori7ranc9;!os;en3i2kk,o0;b0ll2;ra5;me4n0rham4;ar3;e0ny;nt1;aht,itcoin0;!s",
  "Determiner": "true\xA6aAboth,d8e5few,le4mu7neiCplenty,s3th2various,wh0;at0ich0;evB;at,e3is,ose;everal,ome;!ast,s;a1l0very;!se;ch;e0u;!s;!n0;!o0y;th0;er",
  "Adj|Present": "true\xA6a06b03cUdPeNfJhollIidQlEmCnarrIoBp9qua8r7s4t2utt3w0;aKet,ound,ro0;ng,ug07;end0hin;er;e1hort,l0mooth,our,pa8tray,u8;i2ow;cu6da01leRpaM;eplica00ig01;ck;aGr0;eseTime,omU;bscu1pen,wn;atu0e3odeG;re;a2e1i0;gTve;an;st,y;ow;a2i1oul,r0;ee,inge;rm;iHke,ncy,st;l0mpty,xpress;abo4ic7;amp,e2i1oub0ry,ull;le;ffu9re6;fu8libe0;raE;alm,l5o0;mpleCn3ol,rr1unterfe0;it;e0u7;ct;juga8sum7;ea1o0;se;n,r;ankru1lu0;nt;pt;lig2pproxi0;ma0;te;ht",
  "Comparable": "true\xA60:38;1:3N;2:3C;3:2E;a3Rb39c30d2Re2Kf28g1Wh1Mi1Gj1Fk1Cl15m0Zn0Uo0Tp0Kqu0Ir09sJtEuDvBw5y4za0S;el12ouP;a8e6hi1Ii4ry;ck0Ede,l4n1ry,se;d,y;a4i3Q;k,ry;ntiJry;a4erda2ulgar;gue,in,st;g0pcomiG;a7en2Thi6i5ough,r4;anqu29en1ue;dy,g33me0ny,r04;ck,rs25;ll,me,rt,wd3F;aScarReQhOiNkin0ClJmHoFpEt7u5w4;eet,ift;b4dd0Wperfi1Xrre25;sta23t3;a9e8iff,r5u4;pVr1;a5ict,o4;ng;ig2Sn0N;a1ep,rn;le,rk,te0;e1Oi2Sright0;ci1Vft,l4on,re;emn,id;a4el0;ll,rt;e6i4y;g2Jm4;!y;ek,nd2P;ck,l0mp3;a4iRrill,y;dy,l01rp;ve0Ixy;ce,y;d,fe,int0l1Ev0U;a9e7i6o4ude;mantic,o16sy,u4;gh,nd;ch,pe,tzy;a4d,mo0A;dy,l;gg5ndom,p4re,w;id;ed;ai2i4;ck,et;hoBi1BlAo9r6u4;ny,r4;e,p3;egna2ic5o4;fouSud;ey,k0;liXor;ain,easa2;ny;dd,i0ld,ranL;aive,e6i5o4;b3isy,rm0Vsy;bb0ce,mb3;a4w;r,t;ad,e6ild,o5u4;nda0Xte;ist,o1;a5ek,l4;low;s0ty;a8ewd,i7o4ucky;f0Gn5o11u4ve0w0Vy0K;d,sy;e0g;ke0tt3ve0;me,r4te;ge;e5i4;nd;en;ol0ui17;cy,ll,n4;secu7t4;e4ima5;llege2rmedia4;te;re;aBe8i7o6u4;ge,m4ng1A;b3id;me0t;gh,l0;a4fVsita2;dy,v4;en0y;nd11ppy,r4;d,sh;aEenDhBiAl9oofy,r4;a7e6is0o4ue0Y;o4ss;vy;at,en,y;nd,y;ad,ib,ooE;a2d1;a4o4;st0;t3uiR;u1y;aDeeb3i9lat,o7r6u4;ll,n4r0O;!ny;aDesh,iend0;a4rmE;my;erce5nan4;ciB;! ;le;r,ul4;ty;a7erie,sse5v4xtre0C;il;nti4;al;r5s4;tern,y;ly,th0;aBe8i5ru4umb;nk;r5vi4;ne;e,ty;a4ep,nB;d4f,r;!ly;ppSrk;agey,h9l8o6r5u4;dd0r0te;isp,uel;ar4ld,mmon,st0ward0zy;se;evMou1;e4il0;ap,e4;sy;aJiHlEoCr6u4;r0sy;ly;a8i5o4;ad,wn;g5llia2;nt;ht;sh,ve;ld,un4;cy;a5o4ue;nd,o1;ck,nd;g,tt4;er;d,ld,w1;dy;bsu7ng6we4;so4;me;ry;rd",
  "Infinitive": "true\xA60:8V;1:8G;2:9D;3:80;4:7N;5:91;6:9H;7:99;8:82;9:9G;A:92;B:8X;C:7K;D:7U;E:7Q;F:87;G:7V;H:7H;a82b7Jc6Sd5Le4Gf45g41h3Wi3Cj39k37l2Ym2Rnou3Vo2Lp25qu24r19s0AtYuTvRwI;aOeNiLors4rI;eJiI;ng,te;ak,st3;d4e7HthI;draw,er;a2d,ep;i2ke,nIrn;d0t;aIie;li9Eni9ry;nIplift;cov0dJear7JlIplug,tie,ve85;ea9o3K;erIo;cut,go,sta9Gval96whelm;aRePhMoLrI;aIemb3;ffi3Fmp3nsI;aDpi8;pp3ugh4;aJiJrIwaE;eat4i2;nk;aIm92;ch,se;ck3ilor,keImp0r7N;! paE;a0Fc0Ee0Ch08i06l04mugg3n03o01pYquXtQuKwI;all71eeIim;p,t4;bKccumb,ffJggeBmm93p2FrI;mouFvi2;er,i5;li80mJsiIveE;de,st;erAit;aMe7SiKrI;ang3eIi2;ng20w;fIng;f4le;gg0rI;t3ve;a3Ui9;a4DeJit,l6KoI;il,of;ak,nd;lIot6Nw;icCve;eak,i0L;aIi6;m,y;ft,nIt;g,k;aKi5LoJriIun;nk,v5X;ot,rt4;ke,rp4tt0;eIll,nd,que7Nv0w;!k,m;avenAul81;dd4tis1Ay;a0BeJip4oI;am,ut;a07b05c03d02fZgroup,heaYiXlVmUnTpRq36sNtLup,vI;amp,eJiIo2V;sCve;l,rt;i8rI;ie2ofC;eFiKtIurfa5;o1XrI;aHiDuctu8;de,gn,st;el,hra1lIreseF;a5e69;d0ew,o05;aHe31o2;a7eFiIoad,y;e2nq3Mve;mbur1nf2U;r1t;inJleDocus,re9uI;el,rbi9;an5e;aDu5;ei2k7Jla3OoIyc3;gni2Wnci3up,v0;oot,uI;ff;ct,d,liI;se,ze;tt3vi9;a9enGit,o7;aVerTinpoiFlumm0VoSrKuI;b3Oke,ni9rIt;poEs6W;eMoI;cKd,fe4BhibCnoJpo1sp0tru6vI;e,i6o4W;un5;la39u8;aGclu6dJf0occupy,sup0FvI;a5LeF;etermi47iD;aGrtr4Vsse44;cei2fo3Hi9mea7plex,sIva6;eve8iB;mp0rItrol,ve,y;a5St5O;bMccuLpKutJverIwe;lap,s19tu6Au1;gr4Pnu22pa5;era7i3Ypo1;py,r;ser2taH;aMe09iJoIultiply;leBu64;micJnIspla5;ce,g3us;!k;iIke,naA;m,ntaH;aPeLiIo1u39;e,ke,ng0quIv4;eIi66;fy;aKnIss4;d,gI;th4;rn,ve;ng26u1E;eep,nI;e3Row;oHuI;gg3xtaI;po1;gno8mWnIrk;cUdSfRgeBhQitia7ju8q14sOtKun5TvI;eIo0T;nt,st;erJimi5QoxiQrI;odu5u6;aDn,prIru5Q;et;iBpi8tIu8;il,ruD;abCibC;eBo2Bu1;iIulA;ca7;i7lu6;b5Cmer1pI;aEer47ly,oJrI;e2Ris5No2;rt,se,veI;ri9;aLeKiIoiBuE;de,jaInd0;ck;ar,iQ;mp0ng,pp4st4ve;ath0et,i2le1UoKrI;aIow;b,pp3ze;!ve4S;ast4er3Li58lRorMrJuI;lf3Tr3P;eJiIolic;ght4;e0Lsh4;b3DeKfeCgIs4B;eIi2;!t;clo1go,sIwa4J;had2Y;ee,i2Q;a0KdCl0Im0CnUquip,rTsStGvQxI;cNeEha3iMpJtI;ing0Uol;eJi8lIo1unA;aHoC;ct,di7;st,t;e2MlI;a0Xu6;alua7oI;ke,l2;chew,pou1tab13;a1u4G;aYcVdTfSgQhan5joy,lPqOrNsuMtKvI;e0VisI;aAi4L;er,i5rI;aHenGuB;e,re;iGol;ui8;arAiB;aAeIra2ulf;nd0;or5;ang0oIu8;r1w;lo1ou0CrJuI;mb0;oaGy3Z;b3ct;bKerApI;hasiIow0;ze;a0Tody,rI;a5oiI;d0l;ap1eDuI;ci3Ode;rIt;ma0Nn;a0Ne02iKo,rIwind3;aw,edAoI;wn;agno1e,ff0g,mi27sLvI;eIulA;rIst;ge,t;ab3bUcPlodAmant3pNru3GsMtI;iIoEu2W;lJngI;ui9;!l;ol2ua6;eIla5o1ro2;n1r1;a2Ne2WlKoIu0K;uIv0;raA;aIo1;im;a38ur1;af4bZcTduDep4fRliQmNnLpKra1TtaGvI;eIol2;lop;aEiDoE;oIy;te,un5;eJoI;li9;an;mCv0;a5i06oIraud,y;rm;ei2iMoKrI;ee,yI;!pt;de,mIup3;missi2Upo1;de,ma7ph0;aJrief,uI;g,nk;rk;mp4rk4uF;a06ea1h04i03l02oJrIurta17;a2ea7ipp3;ales5eZhabCinci6llYmWnIrro6;cTdQfNju8no7qu0sLtKvI;eIin5;ne,rA;aHin25ribu7;er2iIoli27pi8titu7ult;d0st;eJiIroFu1;de,gu8rm;ss;eJoI;ne;mn,n1;eIlu6ur;al,i2;buBe,men5pI;e7i3ly;eDi6u6;r5xiB;ean1iS;rcumveFte;eIoo1;ri9w;ncIre4t0ulk;el;aXeRi6lPoOrLuI;iJrIy;st,y;ld;aJeastfeMiIoad4;ng;ke;il,l12mba0XrrMth0;eIow;ed;!come,gHha2liLqueaKstJtrIwild0;ay;ow;th;e2tt3;in;bysCckfi8ff3tI;he;it;b17c0Vd0Mff0Kgr0Jl0Fm0Bn05pp01rZsSttPuNvKwaI;it,k4;en;eEoI;id;rt;gIto08;meF;aGeBraD;ct;ch;pi8sJtoI;ni9;aKeIi05u8;mb3rt,ss;le;il;re;g0Ji1ou1rI;anAi2;eaKly,oiFrI;ai1o2;nt;r,se;aMiQnJtI;icipa7;eJoIul;un5y;al;ly1;aJu1;se;lgaIze;ma7;iKlI;eAoIu6;t,w;gn;ee;ix,oI;rd;a01jNmiKoJsoI;rb;pt,rn;niIt;st0;er;ouJuB;st;rn;cLhie2knowledAquiItiva7;es5re;ce;ge;eOomKrJusI;e,tom;ue;moJpI;any,li9;da7;te;pt;andOet,i6oKsI;coKol2;ve;li9rt,uI;nd;sh;de;on",
  "Modal": "true\xA6c5lets,m4ought3sh1w0;ill,o5;a0o4;ll,nt;! to,a;ight,ust;an,o0;uld",
  "Verb": "true\xA6born,cannot,gonna,has,keep tabs,msg",
  "Participle": "true\xA6fl3g1s0writt2;e1h2;iv0one;en;own",
  "Adj|Gerund": "true\xA60:2F;1:2H;2:25;3:23;4:20;5:2D;6:27;7:22;a24b1Zc1Hd14e0Yf0Og0Ih0Hi0Ajud1Xl07m04o00pWrQsFtAup9v8w0Pyiel4;ar5eY;lif0s01;aWeBhr9i3ouc7r8wis0;e01oub2us0yi1;ea0Mi8;l2vi1;l2mp0;atisf5creec7hoc0Ekyrocke0lo13oGpFtBu9we8;e12l2;pp1Kr8;gi1pri6roun4;a9ea23i8ri0Aun1C;mula0r3;gge3r8;t2vi1;ark2ee4;a8ot7;ki1ri1;aCe9ive0o8us7;a3l2;defi13fres7ig13laEmai13s0v8war4;ea2itali8ol0Q;si1zi1;gi1ll5mb2vi1;a5erpleAier1Dlun18r8un1J;e8o11;ce4s6vai2;xi1;ffsApNut9ver8wi1;arc7lap0Hp09ri4whel1L;goi1l5st0Y;et0;eande3i9o0Fu8;mb2;s6tiga0;a9i8o0C;fesa0Bmi0vi1;cKg0Vs0;mDn8rri0C;cBsAt9vi8;go1Gti1;e15imida0;pi3ul0;orpo1Drea6;po6;arrowi1ea2orrif5umilia0;lCr8;a0ipZo9uel8;i1li1;undbrea8wi1;ki1;a3ea0Z;aGetc7it0lDoBr9ulf8;il2;ee0Yigh8ust12;te04;r8un4;ebo4th0H;a9o8;a0we3;mi1tte3;di1scina0;mBn9x8;ac0ci0is0plo4;ab2c8du3ga04sT;han0oura03;barras6er02p8;owe3;aJeCi8;s8zz5;appoin0gus0sen0t8;r8u0N;ac0es6;biliDcCfiMgra4mBpres6serAv8;asCelo8;pi1;vi1;an4eaI;a5liH;ta0;maOri1s7un0;aOhLlo6o8ripp2ut0;mEn8rrespon4;cerCfBspi3t8vinQ;in9r8;as0ibu0ol2;ui1;lic0u6;ni1;fCmBp8;e9ro8;mi6;l2ti1;an4;or0;a8ea0il2;llen8rQ;gi1;lOptiva0ri1;eBin4lin4o9rui6u8;d4st2;i2oLri1un8;ci1;coJ;bsoQcLgonJlarImGppea2rEs8;pi3su3to8;n9un4;di1;is7;hi1;ri1;res0;li1;aBu6;si1;mi1;i8zi1;zi1;c8hi1;ele9ompan5;yi1;ra0;ti1;rbi1;ng",
  "Adj|Past": "true\xA60:30;1:2R;2:2U;a2Jb2Dc1Ud1Be15f10gift0h0Xi0Qj0Pknown,l0Mm0Hn0Fo0Cp05qua04rVsEtAu7v5w3;arp0ea3or5;kIth2T;a3e0W;ri0;n3pd1s0;derstood,i3;fi0t0;ar5hreatCr3wi2R;a3ou19;ck0in0pp0;get0ni1N;aHcaGeEhDimCm01oak0pAt6u3;bsid28gge2Ms3;pe3ta1S;ct0nd0;at0e5r3uV;ength3ip0;en0;am0reotyp0;eci3ik0ott0;al20fi0;pIul1;ar0ut;a3c1Jle2t1S;l0t0;r0tt25;t3ut0;is1Jur1;aAe3;c7duc0f1Cg6l1new0qu5s3;pe2t3;or0ri2;e22ir0;ist1Xul1;eiv0o3;mme09rd0v1V;lli0ti1A;li19;arallel0i0Kl7o6r3ump0;e4o3;ce0Ilo0Hnou1Tpos0te2;fe0Loc8pY;i1Gli0R;a3e19;nn0;c4rgan1Bverlo3;ok0;cupi0;e3ot0;ed0gle2;a5e4ix0o3ut0;di0Vt0G;as0Qlt0;n3rk0;ag0ufact0O;eft,i4o3;ad0st;cens0mit0st0;agg0us0N;mp8n3sol1;br0debt0f6t3volv0;e3ox0F;gr1n3re18;d0si0J;e2l1oX;li0oLrov0;amm10e1o3;ok0r3;ri0E;aNe6i5lavo09oc05r3;a3i0;ct07g0Mm0;niXx0;ar0;duc1l1mbarraKn7quipp0stabliVx3;agger1p3te5;a4e3;ct0rie0S;nd0;ha0QsZ;aJeAi3;gni01miniOre2s3;a7c5grun05t3;o3reBurb0;rt0;iplSou3;nt0rE;bl0;cenVdOf8l7pre6ra5t3velop0;a3ermO;il0;ng0;ss0;ay0ight0;e4o3;rm0;rr0;m3t0;ag0;alcul1eHharg0lGo8r5u3;lt3stomS;iv1;a4owd0u3;sh0;ck0mp0;d0lo9m6n3ok0vX;centr1f4s3troll0;idVolid1;us0;b4pl3;ic1;in0;ur0;assi5os0;lebr1n5r3;ti3;fi0;tralB;a7i6o4roken,urn3;ed,t;il0r0t3und;tl0;as0;k0laIs0;bandon0cJdGffe2lDnBpp9ss7u3ward0;g4thor3;iz0;me3;nt0;o5u3;m0r0;li0re3;ci1;im1ticip1;at0;leg0t3;er0;ct0;ju4o6va3;nc0;st0;ce3knowledg0;pt0;ed",
  "Person|Place": "true\xA6a5darw6h3jordan,k2orlando,s0victo7;a0ydney;lvador,mara,ntiago;ent,obe;amil0ous0;ton;lexand1ust0;in;ria",
  "Person|Date": "true\xA6a2j0sep;an0une;!uary;p0ugust,v0;ril"
};

// node_modules/efrt/src/encoding.js
var BASE = 36;
var seq = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var cache = seq.split("").reduce(function(h2, c2, i3) {
  h2[c2] = i3;
  return h2;
}, {});
var toAlphaCode = function(n3) {
  if (seq[n3] !== void 0) {
    return seq[n3];
  }
  let places2 = 1;
  let range = BASE;
  let s3 = "";
  for (; n3 >= range; n3 -= range, places2++, range *= BASE) {
  }
  while (places2--) {
    const d2 = n3 % BASE;
    s3 = String.fromCharCode((d2 < 10 ? 48 : 55) + d2) + s3;
    n3 = (n3 - d2) / BASE;
  }
  return s3;
};
var fromAlphaCode = function(s3) {
  if (cache[s3] !== void 0) {
    return cache[s3];
  }
  let n3 = 0;
  let places2 = 1;
  let range = BASE;
  let pow = 1;
  for (; places2 < s3.length; n3 += range, places2++, range *= BASE) {
  }
  for (let i3 = s3.length - 1; i3 >= 0; i3--, pow *= BASE) {
    let d2 = s3.charCodeAt(i3) - 48;
    if (d2 > 10) {
      d2 -= 7;
    }
    n3 += d2 * pow;
  }
  return n3;
};
var encoding_default = {
  toAlphaCode,
  fromAlphaCode
};

// node_modules/efrt/src/unpack/symbols.js
var symbols = function(t2) {
  const reSymbol = new RegExp("([0-9A-Z]+):([0-9A-Z]+)");
  for (let i3 = 0; i3 < t2.nodes.length; i3++) {
    const m3 = reSymbol.exec(t2.nodes[i3]);
    if (!m3) {
      t2.symCount = i3;
      break;
    }
    t2.syms[encoding_default.fromAlphaCode(m3[1])] = encoding_default.fromAlphaCode(m3[2]);
  }
  t2.nodes = t2.nodes.slice(t2.symCount, t2.nodes.length);
};
var symbols_default = symbols;

// node_modules/efrt/src/unpack/traverse.js
var indexFromRef = function(trie, ref, index3) {
  const dnode = encoding_default.fromAlphaCode(ref);
  if (dnode < trie.symCount) {
    return trie.syms[dnode];
  }
  return index3 + dnode + 1 - trie.symCount;
};
var toArray = function(trie) {
  const all4 = [];
  const crawl = (index3, pref) => {
    let node = trie.nodes[index3];
    if (node[0] === "!") {
      all4.push(pref);
      node = node.slice(1);
    }
    const matches3 = node.split(/([A-Z0-9,]+)/g);
    for (let i3 = 0; i3 < matches3.length; i3 += 2) {
      const str = matches3[i3];
      const ref = matches3[i3 + 1];
      if (!str) {
        continue;
      }
      const have = pref + str;
      if (ref === "," || ref === void 0) {
        all4.push(have);
        continue;
      }
      const newIndex = indexFromRef(trie, ref, index3);
      crawl(newIndex, have);
    }
  };
  crawl(0, "");
  return all4;
};
var unpack = function(str) {
  const trie = {
    nodes: str.split(";"),
    syms: [],
    symCount: 0
  };
  if (str.match(":")) {
    symbols_default(trie);
  }
  return toArray(trie);
};
var traverse_default = unpack;

// node_modules/efrt/src/unpack/index.js
var unpack2 = function(str) {
  if (!str) {
    return {};
  }
  const obj = str.split("|").reduce((h2, s3) => {
    const arr = s3.split("\xA6");
    h2[arr[0]] = arr[1];
    return h2;
  }, {});
  const all4 = {};
  Object.keys(obj).forEach(function(cat) {
    const arr = traverse_default(obj[cat]);
    if (cat === "true") {
      cat = true;
    }
    for (let i3 = 0; i3 < arr.length; i3++) {
      const k2 = arr[i3];
      if (all4.hasOwnProperty(k2) === true) {
        if (Array.isArray(all4[k2]) === false) {
          all4[k2] = [all4[k2], cat];
        } else {
          all4[k2].push(cat);
        }
      } else {
        all4[k2] = cat;
      }
    }
  });
  return all4;
};
var unpack_default = unpack2;

// node_modules/compromise/src/2-two/preTagger/model/lexicon/misc.js
var prp = ["Possessive", "Pronoun"];
var misc = {
  "20th century fox": "Organization",
  "7 eleven": "Organization",
  "motel 6": "Organization",
  g8: "Organization",
  vh1: "Organization",
  "km2": "Unit",
  "m2": "Unit",
  "dm2": "Unit",
  "cm2": "Unit",
  "mm2": "Unit",
  "mile2": "Unit",
  "in2": "Unit",
  "yd2": "Unit",
  "ft2": "Unit",
  "m3": "Unit",
  "dm3": "Unit",
  "cm3": "Unit",
  "in3": "Unit",
  "ft3": "Unit",
  "yd3": "Unit",
  "at&t": "Organization",
  "black & decker": "Organization",
  "h & m": "Organization",
  "johnson & johnson": "Organization",
  "procter & gamble": "Organization",
  "ben & jerry's": "Organization",
  "&": "Conjunction",
  i: ["Pronoun", "Singular"],
  he: ["Pronoun", "Singular"],
  she: ["Pronoun", "Singular"],
  it: ["Pronoun", "Singular"],
  they: ["Pronoun", "Plural"],
  we: ["Pronoun", "Plural"],
  was: ["Copula", "PastTense"],
  is: ["Copula", "PresentTense"],
  are: ["Copula", "PresentTense"],
  am: ["Copula", "PresentTense"],
  were: ["Copula", "PastTense"],
  her: prp,
  his: prp,
  hers: prp,
  their: prp,
  theirs: prp,
  themselves: prp,
  your: prp,
  our: prp,
  ours: prp,
  my: prp,
  its: prp,
  vs: ["Conjunction", "Abbreviation"],
  if: ["Condition", "Preposition"],
  closer: "Comparative",
  closest: "Superlative",
  much: "Adverb",
  may: "Modal",
  babysat: "PastTense",
  blew: "PastTense",
  drank: "PastTense",
  drove: "PastTense",
  forgave: "PastTense",
  skiied: "PastTense",
  spilt: "PastTense",
  stung: "PastTense",
  swam: "PastTense",
  swung: "PastTense",
  guaranteed: "PastTense",
  shrunk: "PastTense",
  nears: "PresentTense",
  nearing: "Gerund",
  neared: "PastTense",
  no: ["Negative", "Expression"]
};
var misc_default2 = misc;

// node_modules/compromise/src/2-two/preTagger/model/lexicon/emoticons.js
var emoticons_default = [
  ":(",
  ":)",
  ":P",
  ":p",
  ":O",
  ";(",
  ";)",
  ";P",
  ";p",
  ";O",
  ":3",
  ":|",
  ":/",
  ":\\",
  ":$",
  ":*",
  ":@",
  ":-(",
  ":-)",
  ":-P",
  ":-p",
  ":-O",
  ":-3",
  ":-|",
  ":-/",
  ":-\\",
  ":-$",
  ":-*",
  ":-@",
  ":^(",
  ":^)",
  ":^P",
  ":^p",
  ":^O",
  ":^3",
  ":^|",
  ":^/",
  ":^\\",
  ":^$",
  ":^*",
  ":^@",
  "):",
  "(:",
  "$:",
  "*:",
  ")-:",
  "(-:",
  "$-:",
  "*-:",
  ")^:",
  "(^:",
  "$^:",
  "*^:",
  "<3",
  "</3",
  "<\\3",
  "=("
];

// node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toPlural/_rules.js
var suffixes = {
  a: [
    [/(antenn|formul|nebul|vertebr|vit)a$/i, "$1ae"],
    [/ia$/i, "ia"]
  ],
  e: [
    [/(kn|l|w)ife$/i, "$1ives"],
    [/(hive)$/i, "$1s"],
    [/([m|l])ouse$/i, "$1ice"],
    [/([m|l])ice$/i, "$1ice"]
  ],
  f: [
    [/^(dwar|handkerchie|hoo|scar|whar)f$/i, "$1ves"],
    [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)f$/i, "$1ves"]
  ],
  i: [[/(octop|vir)i$/i, "$1i"]],
  m: [[/([ti])um$/i, "$1a"]],
  n: [[/^(oxen)$/i, "$1"]],
  o: [[/(al|ad|at|er|et|ed)o$/i, "$1oes"]],
  s: [
    [/(ax|test)is$/i, "$1es"],
    [/(alias|status)$/i, "$1es"],
    [/sis$/i, "ses"],
    [/(bu)s$/i, "$1ses"],
    [/(sis)$/i, "ses"],
    [/^(?!talis|.*hu)(.*)man$/i, "$1men"],
    [/(octop|vir|radi|nucle|fung|cact|stimul)us$/i, "$1i"]
  ],
  x: [
    [/(matr|vert|ind|cort)(ix|ex)$/i, "$1ices"],
    [/^(ox)$/i, "$1en"]
  ],
  y: [[/([^aeiouy]|qu)y$/i, "$1ies"]],
  z: [[/(quiz)$/i, "$1zes"]]
};
var rules_default = suffixes;

// node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toPlural/index.js
var addE = /([xsz]|ch|sh)$/;
var trySuffix = function(str) {
  let c2 = str[str.length - 1];
  if (rules_default.hasOwnProperty(c2) === true) {
    for (let i3 = 0; i3 < rules_default[c2].length; i3 += 1) {
      let reg = rules_default[c2][i3][0];
      if (reg.test(str) === true) {
        return str.replace(reg, rules_default[c2][i3][1]);
      }
    }
  }
  return null;
};
var pluralize = function(str = "", model5) {
  let { irregularPlurals, uncountable: uncountable2 } = model5.two;
  if (uncountable2.hasOwnProperty(str)) {
    return str;
  }
  if (irregularPlurals.hasOwnProperty(str)) {
    return irregularPlurals[str];
  }
  let plural2 = trySuffix(str);
  if (plural2 !== null) {
    return plural2;
  }
  if (addE.test(str)) {
    return str + "es";
  }
  return str + "s";
};
var toPlural_default = pluralize;

// node_modules/compromise/src/2-two/preTagger/model/lexicon/index.js
var hasSwitch = /\|/;
var lexicon3 = misc_default2;
var switches = {};
var tmpModel = { two: { irregularPlurals: plurals_default, uncountable: {} } };
Object.keys(data_default).forEach((tag) => {
  let wordsObj = unpack_default(data_default[tag]);
  if (!hasSwitch.test(tag)) {
    Object.keys(wordsObj).forEach((w) => {
      lexicon3[w] = tag;
    });
    return;
  }
  Object.keys(wordsObj).forEach((w) => {
    switches[w] = tag;
    if (tag === "Noun|Verb") {
      let plural2 = toPlural_default(w, tmpModel);
      switches[plural2] = "Plural|Verb";
    }
  });
});
emoticons_default.forEach((str) => lexicon3[str] = "Emoticon");
delete lexicon3[""];
delete lexicon3[null];
delete lexicon3[" "];

// node_modules/compromise/src/2-two/preTagger/model/clues/_adj.js
var jj = "Adjective";
var adj_default = {
  beforeTags: {
    Determiner: jj,
    Possessive: jj,
    Hyphenated: jj
  },
  afterTags: {
    Adjective: jj
  },
  beforeWords: {
    seem: jj,
    seemed: jj,
    seems: jj,
    feel: jj,
    feels: jj,
    felt: jj,
    stay: jj,
    appear: jj,
    appears: jj,
    appeared: jj,
    also: jj,
    over: jj,
    under: jj,
    too: jj,
    it: jj,
    but: jj,
    still: jj,
    really: jj,
    quite: jj,
    well: jj,
    very: jj,
    how: jj,
    deeply: jj,
    hella: jj,
    profoundly: jj,
    extremely: jj,
    so: jj,
    badly: jj,
    mostly: jj,
    totally: jj,
    awfully: jj,
    rather: jj,
    nothing: jj,
    something: jj,
    anything: jj,
    not: jj,
    me: jj,
    is: jj
  },
  afterWords: {
    too: jj,
    also: jj,
    or: jj
  }
};

// node_modules/compromise/src/2-two/preTagger/model/clues/_gerund.js
var g2 = "Gerund";
var gerund_default = {
  beforeTags: {
    Adverb: g2,
    Preposition: g2,
    Conjunction: g2
  },
  afterTags: {
    Adverb: g2,
    Possessive: g2,
    Person: g2,
    Pronoun: g2,
    Determiner: g2,
    Copula: g2,
    Preposition: g2,
    Conjunction: g2,
    Comparative: g2
  },
  beforeWords: {
    been: g2,
    keep: g2,
    continue: g2,
    stop: g2,
    am: g2,
    be: g2,
    me: g2,
    began: g2,
    start: g2,
    starts: g2,
    started: g2,
    stops: g2,
    stopped: g2,
    help: g2,
    helps: g2,
    avoid: g2,
    avoids: g2,
    love: g2,
    loves: g2,
    loved: g2,
    hate: g2,
    hates: g2,
    hated: g2
  },
  afterWords: {
    you: g2,
    me: g2,
    her: g2,
    him: g2,
    them: g2,
    their: g2,
    it: g2,
    this: g2,
    there: g2,
    on: g2,
    about: g2,
    for: g2
  }
};

// node_modules/compromise/src/2-two/preTagger/model/clues/adj-gerund.js
var clue = {
  beforeTags: Object.assign({}, adj_default.beforeTags, gerund_default.beforeTags, {
    Imperative: "Gerund",
    Infinitive: "Adjective",
    PresentTense: "Gerund",
    Plural: "Gerund"
  }),
  afterTags: Object.assign({}, adj_default.afterTags, gerund_default.afterTags, {
    Singular: "Adjective"
  }),
  beforeWords: Object.assign({}, adj_default.beforeWords, gerund_default.beforeWords, {
    is: "Adjective",
    was: "Adjective",
    of: "Adjective",
    suggest: "Gerund",
    recommend: "Gerund"
  }),
  afterWords: Object.assign({}, adj_default.afterWords, gerund_default.afterWords, {
    to: "Gerund",
    not: "Gerund",
    the: "Gerund"
  })
};
var adj_gerund_default = clue;

// node_modules/compromise/src/2-two/preTagger/model/clues/_noun.js
var n2 = "Singular";
var noun_default = {
  beforeTags: {
    Determiner: n2,
    Possessive: n2,
    Acronym: n2,
    Noun: n2,
    Adjective: n2,
    PresentTense: n2,
    Gerund: n2,
    PastTense: n2,
    Infinitive: n2,
    Date: n2,
    Ordinal: n2,
    Demonym: n2
  },
  afterTags: {
    Value: n2,
    Modal: n2,
    Copula: n2,
    PresentTense: n2,
    PastTense: n2,
    Demonym: n2
  },
  beforeWords: {
    the: n2,
    with: n2,
    without: n2,
    of: n2,
    for: n2,
    any: n2,
    all: n2,
    on: n2,
    cut: n2,
    cuts: n2,
    increase: n2,
    decrease: n2,
    raise: n2,
    drop: n2,
    save: n2,
    saved: n2,
    saves: n2,
    make: n2,
    makes: n2,
    made: n2,
    minus: n2,
    plus: n2,
    than: n2,
    another: n2,
    versus: n2,
    neither: n2,
    about: n2,
    favorite: n2,
    best: n2,
    daily: n2,
    weekly: n2,
    linear: n2,
    binary: n2,
    mobile: n2,
    lexical: n2,
    technical: n2,
    computer: n2,
    scientific: n2,
    security: n2,
    government: n2,
    popular: n2,
    formal: n2,
    no: n2,
    more: n2,
    one: n2
  },
  afterWords: {
    of: n2,
    system: n2,
    aid: n2,
    method: n2,
    utility: n2,
    tool: n2,
    reform: n2,
    therapy: n2,
    philosophy: n2,
    room: n2,
    authority: n2,
    says: n2,
    said: n2,
    wants: n2,
    wanted: n2,
    is: n2,
    can: n2,
    wise: n2
  }
};

// node_modules/compromise/src/2-two/preTagger/model/clues/adj-noun.js
var misc2 = {
  beforeTags: {
    Determiner: void 0,
    Cardinal: "Noun",
    PhrasalVerb: "Adjective"
  }
};
var clue2 = {
  beforeTags: Object.assign({}, adj_default.beforeTags, noun_default.beforeTags, misc2.beforeTags),
  afterTags: Object.assign({}, adj_default.afterTags, noun_default.afterTags),
  beforeWords: Object.assign({}, adj_default.beforeWords, noun_default.beforeWords, {
    are: "Adjective",
    is: "Adjective",
    was: "Adjective",
    be: "Adjective",
    off: "Adjective",
    out: "Adjective"
  }),
  afterWords: Object.assign({}, adj_default.afterWords, noun_default.afterWords)
};
var adj_noun_default = clue2;

// node_modules/compromise/src/2-two/preTagger/model/clues/adj-past.js
var past = "PastTense";
var adjPast = {
  beforeTags: {
    Adverb: past,
    Pronoun: past,
    ProperNoun: past,
    Auxiliary: past,
    Noun: past
  },
  afterTags: {
    Possessive: past,
    Pronoun: past,
    Determiner: past,
    Adverb: past,
    Comparative: past,
    Date: past,
    Gerund: past
  },
  beforeWords: {
    be: past,
    who: past,
    get: "Adjective",
    had: past,
    has: past,
    have: past,
    been: past,
    it: past,
    as: past,
    for: "Adjective"
  },
  afterWords: {
    by: past,
    back: past,
    out: past,
    in: past,
    up: past,
    down: past,
    before: past,
    after: past,
    for: past,
    the: past,
    with: past,
    as: past,
    on: past,
    at: past,
    between: past,
    to: past,
    into: past,
    us: past,
    them: past,
    me: past
  }
};
var adj_past_default = {
  beforeTags: Object.assign({}, adj_default.beforeTags, adjPast.beforeTags),
  afterTags: Object.assign({}, adj_default.afterTags, adjPast.afterTags),
  beforeWords: Object.assign({}, adj_default.beforeWords, adjPast.beforeWords),
  afterWords: Object.assign({}, adj_default.afterWords, adjPast.afterWords)
};

// node_modules/compromise/src/2-two/preTagger/model/clues/_verb.js
var v = "Infinitive";
var verb_default = {
  beforeTags: {
    Modal: v,
    Adverb: v,
    Negative: v,
    Plural: v
  },
  afterTags: {
    Determiner: v,
    Adverb: v,
    Possessive: v,
    Reflexive: v,
    Preposition: v,
    Cardinal: v,
    Comparative: v,
    Superlative: v
  },
  beforeWords: {
    i: v,
    we: v,
    you: v,
    they: v,
    to: v,
    please: v,
    will: v,
    have: v,
    had: v,
    would: v,
    could: v,
    should: v,
    do: v,
    did: v,
    does: v,
    can: v,
    must: v,
    us: v,
    me: v,
    let: v,
    even: v,
    when: v,
    help: v,
    he: v,
    she: v,
    it: v,
    being: v,
    bi: v,
    co: v,
    contra: v,
    de: v,
    inter: v,
    intra: v,
    mis: v,
    pre: v,
    out: v,
    counter: v
  },
  afterWords: {
    the: v,
    me: v,
    you: v,
    him: v,
    us: v,
    her: v,
    them: v,
    it: v,
    himself: v,
    herself: v,
    itself: v,
    myself: v,
    ourselves: v,
    themselves: v,
    something: v,
    anything: v,
    a: v,
    an: v,
    up: v,
    down: v,
    by: v,
    out: v,
    off: v,
    under: v,
    what: v,
    all: v,
    to: v,
    because: v,
    although: v,
    after: v,
    before: v,
    how: v,
    otherwise: v,
    together: v,
    though: v,
    into: v,
    yet: v,
    more: v,
    here: v,
    there: v
  }
};

// node_modules/compromise/src/2-two/preTagger/model/clues/adj-present.js
var misc3 = {
  afterTags: {
    Noun: "Adjective",
    Conjunction: void 0
  }
};
var clue3 = {
  beforeTags: Object.assign({}, adj_default.beforeTags, verb_default.beforeTags, {
    Adverb: void 0,
    Negative: void 0
  }),
  afterTags: Object.assign({}, adj_default.afterTags, verb_default.afterTags, misc3.afterTags),
  beforeWords: Object.assign({}, adj_default.beforeWords, verb_default.beforeWords, {
    have: void 0,
    had: void 0,
    not: void 0,
    went: "Adjective",
    goes: "Adjective",
    got: "Adjective",
    be: "Adjective"
  }),
  afterWords: Object.assign({}, adj_default.afterWords, verb_default.afterWords, {
    to: void 0,
    as: "Adjective"
  })
};
var adj_present_default = clue3;

// node_modules/compromise/src/2-two/preTagger/model/clues/noun-gerund.js
var misc4 = {
  beforeTags: {
    Copula: "Gerund",
    PastTense: "Gerund",
    PresentTense: "Gerund",
    Infinitive: "Gerund"
  },
  afterTags: {},
  beforeWords: {
    are: "Gerund",
    were: "Gerund",
    be: "Gerund",
    no: "Gerund",
    without: "Gerund",
    you: "Gerund",
    we: "Gerund",
    they: "Gerund",
    he: "Gerund",
    she: "Gerund",
    us: "Gerund",
    them: "Gerund"
  },
  afterWords: {
    the: "Gerund",
    this: "Gerund",
    that: "Gerund",
    me: "Gerund",
    us: "Gerund",
    them: "Gerund"
  }
};
var clue4 = {
  beforeTags: Object.assign({}, gerund_default.beforeTags, noun_default.beforeTags, misc4.beforeTags),
  afterTags: Object.assign({}, gerund_default.afterTags, noun_default.afterTags, misc4.afterTags),
  beforeWords: Object.assign({}, gerund_default.beforeWords, noun_default.beforeWords, misc4.beforeWords),
  afterWords: Object.assign({}, gerund_default.afterWords, noun_default.afterWords, misc4.afterWords)
};
var noun_gerund_default = clue4;

// node_modules/compromise/src/2-two/preTagger/model/clues/noun-verb.js
var nn = "Singular";
var vb = "Infinitive";
var clue5 = {
  beforeTags: Object.assign({}, verb_default.beforeTags, noun_default.beforeTags, {
    Adjective: nn,
    Particle: nn
  }),
  afterTags: Object.assign({}, verb_default.afterTags, noun_default.afterTags, {
    ProperNoun: vb,
    Gerund: vb,
    Adjective: vb,
    Copula: nn
  }),
  beforeWords: Object.assign({}, verb_default.beforeWords, noun_default.beforeWords, {
    is: nn,
    was: nn,
    of: nn,
    have: null
  }),
  afterWords: Object.assign({}, verb_default.afterWords, noun_default.afterWords, {
    instead: vb,
    about: vb,
    his: vb,
    her: vb,
    to: null,
    by: null,
    in: null
  })
};
var noun_verb_default = clue5;

// node_modules/compromise/src/2-two/preTagger/model/clues/_person.js
var p2 = "Person";
var person_default = {
  beforeTags: {
    Honorific: p2,
    Person: p2
  },
  afterTags: {
    Person: p2,
    ProperNoun: p2,
    Verb: p2
  },
  ownTags: {
    ProperNoun: p2
  },
  beforeWords: {
    hi: p2,
    hey: p2,
    yo: p2,
    dear: p2,
    hello: p2
  },
  afterWords: {
    said: p2,
    says: p2,
    told: p2,
    tells: p2,
    feels: p2,
    felt: p2,
    seems: p2,
    thinks: p2,
    thought: p2,
    spends: p2,
    spendt: p2,
    plays: p2,
    played: p2,
    sing: p2,
    sang: p2,
    learn: p2,
    learned: p2,
    wants: p2,
    wanted: p2
  }
};

// node_modules/compromise/src/2-two/preTagger/model/clues/person-date.js
var m = "Month";
var month = {
  beforeTags: {
    Date: m,
    Value: m
  },
  afterTags: {
    Date: m,
    Value: m
  },
  beforeWords: {
    by: m,
    in: m,
    on: m,
    during: m,
    after: m,
    before: m,
    between: m,
    until: m,
    til: m,
    sometime: m,
    of: m,
    this: m,
    next: m,
    last: m,
    previous: m,
    following: m
  },
  afterWords: {
    sometime: m,
    in: m,
    of: m,
    until: m,
    the: m
  }
};
var person_date_default = {
  beforeTags: Object.assign({}, person_default.beforeTags, month.beforeTags),
  afterTags: Object.assign({}, person_default.afterTags, month.afterTags),
  beforeWords: Object.assign({}, person_default.beforeWords, month.beforeWords),
  afterWords: Object.assign({}, person_default.afterWords, month.afterWords)
};

// node_modules/compromise/src/2-two/preTagger/model/clues/person-noun.js
var clue6 = {
  beforeTags: Object.assign({}, noun_default.beforeTags, person_default.beforeTags),
  afterTags: Object.assign({}, noun_default.afterTags, person_default.afterTags),
  beforeWords: Object.assign({}, noun_default.beforeWords, person_default.beforeWords, { i: "Infinitive", we: "Infinitive" }),
  afterWords: Object.assign({}, noun_default.afterWords, person_default.afterWords)
};
var person_noun_default = clue6;

// node_modules/compromise/src/2-two/preTagger/model/clues/person-verb.js
var clues = {
  beforeTags: Object.assign({}, noun_default.beforeTags, person_default.beforeTags, verb_default.beforeTags),
  afterTags: Object.assign({}, noun_default.afterTags, person_default.afterTags, verb_default.afterTags),
  beforeWords: Object.assign({}, noun_default.beforeWords, person_default.beforeWords, verb_default.beforeWords),
  afterWords: Object.assign({}, noun_default.afterWords, person_default.afterWords, verb_default.afterWords)
};
var person_verb_default = clues;

// node_modules/compromise/src/2-two/preTagger/model/clues/person-place.js
var p3 = "Place";
var place = {
  beforeTags: {
    Place: p3
  },
  afterTags: {
    Place: p3,
    Abbreviation: p3
  },
  beforeWords: {
    in: p3,
    by: p3,
    near: p3,
    from: p3,
    to: p3
  },
  afterWords: {
    in: p3,
    by: p3,
    near: p3,
    from: p3,
    to: p3,
    government: p3,
    council: p3,
    region: p3,
    city: p3
  }
};
var clue7 = {
  beforeTags: Object.assign({}, place.beforeTags, person_default.beforeTags),
  afterTags: Object.assign({}, place.afterTags, person_default.afterTags),
  beforeWords: Object.assign({}, place.beforeWords, person_default.beforeWords),
  afterWords: Object.assign({}, place.afterWords, person_default.afterWords)
};
var person_place_default = clue7;

// node_modules/compromise/src/2-two/preTagger/model/clues/unit-noun.js
var un = "Unit";
var clues2 = {
  beforeTags: { Value: un },
  afterTags: {},
  beforeWords: {
    per: un,
    every: un,
    each: un,
    square: un,
    cubic: un,
    sq: un,
    metric: un
  },
  afterWords: {
    per: un,
    squared: un,
    cubed: un,
    long: un
  }
};
var unit_noun_default = clues2;

// node_modules/compromise/src/2-two/preTagger/model/clues/index.js
var clues3 = {
  "Adj|Gerund": adj_gerund_default,
  "Adj|Noun": adj_noun_default,
  "Adj|Past": adj_past_default,
  "Adj|Present": adj_present_default,
  "Noun|Verb": noun_verb_default,
  "Noun|Gerund": noun_gerund_default,
  "Person|Noun": person_noun_default,
  "Person|Date": person_date_default,
  "Person|Verb": person_verb_default,
  "Person|Place": person_place_default,
  "Unit|Noun": unit_noun_default
};
var copy = (obj, more) => {
  let res = Object.keys(obj).reduce((h2, k2) => {
    h2[k2] = obj[k2] === "Infinitive" ? "PresentTense" : "Plural";
    return h2;
  }, {});
  return Object.assign(res, more);
};
clues3["Plural|Verb"] = {
  beforeWords: copy(clues3["Noun|Verb"].beforeWords, {
    had: "Plural",
    have: "Plural"
  }),
  afterWords: copy(clues3["Noun|Verb"].afterWords, {
    his: "PresentTense",
    her: "PresentTense",
    its: "PresentTense",
    in: null,
    to: null,
    is: "PresentTense",
    by: "PresentTense"
  }),
  beforeTags: copy(clues3["Noun|Verb"].beforeTags, {
    Conjunction: "PresentTense",
    Noun: void 0,
    ProperNoun: "PresentTense"
  }),
  afterTags: copy(clues3["Noun|Verb"].afterTags, {
    Gerund: "Plural",
    Noun: "PresentTense",
    Value: "PresentTense"
  })
};
var clues_default = clues3;

// node_modules/compromise/src/2-two/preTagger/model/patterns/suffixes.js
var Adj = "Adjective";
var Inf = "Infinitive";
var Pres = "PresentTense";
var Sing = "Singular";
var Past = "PastTense";
var Avb = "Adverb";
var Plrl = "Plural";
var Actor = "Actor";
var Vb = "Verb";
var Noun = "Noun";
var Last = "LastName";
var Modal = "Modal";
var Place = "Place";
var Prt = "Participle";
var suffixes_default2 = [
  null,
  null,
  {
    ea: Sing,
    ia: Noun,
    ic: Adj,
    ly: Avb,
    "'n": Vb,
    "'t": Vb
  },
  {
    oed: Past,
    ued: Past,
    xed: Past,
    " so": Avb,
    "'ll": Modal,
    "'re": "Copula",
    azy: Adj,
    eer: Noun,
    end: Vb,
    ped: Past,
    ffy: Adj,
    ify: Inf,
    ing: "Gerund",
    ize: Inf,
    ibe: Inf,
    lar: Adj,
    mum: Adj,
    nes: Pres,
    nny: Adj,
    ous: Adj,
    que: Adj,
    ger: Noun,
    ber: Noun,
    rol: Sing,
    sis: Sing,
    ogy: Sing,
    oid: Sing,
    ian: Sing,
    zes: Pres,
    eld: Past,
    ken: Prt,
    ven: Prt,
    ten: Prt,
    ect: Inf,
    ict: Inf,
    ign: Inf,
    ful: Adj,
    bal: Adj
  },
  {
    amed: Past,
    aped: Past,
    ched: Past,
    lked: Past,
    rked: Past,
    reed: Past,
    nded: Past,
    mned: Adj,
    cted: Past,
    dged: Past,
    ield: Sing,
    akis: Last,
    cede: Inf,
    chuk: Last,
    czyk: Last,
    ects: Pres,
    ends: Vb,
    enko: Last,
    ette: Sing,
    iary: Sing,
    wner: Sing,
    fies: Pres,
    fore: Avb,
    gate: Inf,
    gone: Adj,
    ices: Plrl,
    ints: Plrl,
    ruct: Inf,
    ines: Plrl,
    ions: Plrl,
    ners: Plrl,
    pers: Plrl,
    lers: Plrl,
    less: Adj,
    llen: Adj,
    made: Adj,
    nsen: Last,
    oses: Pres,
    ould: Modal,
    some: Adj,
    sson: Last,
    ians: Plrl,
    tion: Sing,
    tage: Noun,
    ique: Sing,
    tive: Adj,
    tors: Noun,
    vice: Sing,
    lier: Sing,
    fier: Sing,
    wned: Past,
    gent: Sing,
    tist: Actor,
    pist: Actor,
    rist: Actor,
    mist: Actor,
    yist: Actor,
    vist: Actor,
    ists: Actor,
    lite: Sing,
    site: Sing,
    rite: Sing,
    mite: Sing,
    bite: Sing,
    mate: Sing,
    date: Sing,
    ndal: Sing,
    vent: Sing,
    uist: Actor,
    gist: Actor,
    note: Sing,
    cide: Sing,
    ence: Sing,
    wide: Adj,
    vide: Inf,
    ract: Inf,
    duce: Inf,
    pose: Inf,
    eive: Inf,
    lyze: Inf,
    lyse: Inf,
    iant: Adj,
    nary: Adj
  },
  {
    elist: Actor,
    holic: Sing,
    phite: Sing,
    tized: Past,
    urned: Past,
    eased: Past,
    ances: Plrl,
    bound: Adj,
    ettes: Plrl,
    fully: Avb,
    ishes: Pres,
    ities: Plrl,
    marek: Last,
    nssen: Last,
    ology: Noun,
    osome: Sing,
    tment: Sing,
    ports: Plrl,
    rough: Adj,
    tches: Pres,
    tieth: "Ordinal",
    tures: Plrl,
    wards: Avb,
    where: Avb,
    archy: Noun,
    pathy: Noun,
    opoly: Noun,
    embly: Noun,
    phate: Noun,
    ndent: Sing,
    scent: Sing,
    onist: Actor,
    anist: Actor,
    alist: Actor,
    olist: Actor,
    icist: Actor,
    ounce: Inf,
    iable: Adj,
    borne: Adj,
    gnant: Adj,
    inant: Adj,
    igent: Adj,
    atory: Adj,
    rient: Sing,
    dient: Sing
  },
  {
    auskas: Last,
    parent: Sing,
    cedent: Sing,
    ionary: Sing,
    cklist: Sing,
    keeper: Actor,
    logist: Actor,
    teenth: "Value"
  },
  {
    logists: Actor,
    opoulos: Last,
    borough: Place,
    sdottir: Last
  }
];

// node_modules/compromise/src/2-two/preTagger/model/patterns/prefixes.js
var Adj2 = "Adjective";
var Noun2 = "Noun";
var Verb = "Verb";
var prefixes_default2 = [
  null,
  null,
  {},
  {
    neo: Noun2,
    bio: Noun2,
    "de-": Verb,
    "re-": Verb,
    "un-": Verb
  },
  {
    anti: Noun2,
    auto: Noun2,
    faux: Adj2,
    hexa: Noun2,
    kilo: Noun2,
    mono: Noun2,
    nano: Noun2,
    octa: Noun2,
    poly: Noun2,
    semi: Adj2,
    tele: Noun2,
    "pro-": Adj2,
    "mis-": Verb,
    "dis-": Verb,
    "pre-": Adj2
  },
  {
    anglo: Noun2,
    centi: Noun2,
    ethno: Noun2,
    ferro: Noun2,
    grand: Noun2,
    hepta: Noun2,
    hydro: Noun2,
    intro: Noun2,
    macro: Noun2,
    micro: Noun2,
    milli: Noun2,
    nitro: Noun2,
    penta: Noun2,
    quasi: Adj2,
    radio: Noun2,
    tetra: Noun2,
    "omni-": Adj2,
    "post-": Adj2
  },
  {
    pseudo: Adj2,
    "extra-": Adj2,
    "hyper-": Adj2,
    "inter-": Adj2,
    "intra-": Adj2,
    "deca-": Adj2
  },
  {
    electro: Noun2
  }
];

// node_modules/compromise/src/2-two/preTagger/model/patterns/endsWith.js
var Adj3 = "Adjective";
var Inf2 = "Infinitive";
var Pres2 = "PresentTense";
var Sing2 = "Singular";
var Past2 = "PastTense";
var Adverb = "Adverb";
var Exp = "Expression";
var Actor2 = "Actor";
var Verb2 = "Verb";
var Noun3 = "Noun";
var Last2 = "LastName";
var endsWith_default = {
  a: [
    [/.[aeiou]na$/, Noun3, "tuna"],
    [/.[oau][wvl]ska$/, Last2],
    [/.[^aeiou]ica$/, Sing2, "harmonica"],
    [/^([hyj]a+)+$/, Exp, "haha"]
  ],
  c: [[/.[^aeiou]ic$/, Adj3]],
  d: [
    [/[aeiou](pp|ll|ss|ff|gg|tt|rr|bb|nn|mm)ed$/, Past2, "popped"],
    [/.[aeo]{2}[bdgmnprvz]ed$/, Past2, "rammed"],
    [/.[aeiou][sg]hed$/, Past2, "gushed"],
    [/.[aeiou]red$/, Past2, "hired"],
    [/.[aeiou]r?ried$/, Past2, "hurried"],
    [/[^aeiou]ard$/, Sing2, "steward"],
    [/[aeiou][^aeiou]id$/, Adj3, ""],
    [/.[vrl]id$/, Adj3, "livid"],
    [/..led$/, Past2, "hurled"],
    [/.[iao]sed$/, Past2, ""],
    [/[aeiou]n?[cs]ed$/, Past2, ""],
    [/[aeiou][rl]?[mnf]ed$/, Past2, ""],
    [/[aeiou][ns]?c?ked$/, Past2, "bunked"],
    [/[aeiou]gned$/, Past2],
    [/[aeiou][nl]?ged$/, Past2],
    [/.[tdbwxyz]ed$/, Past2],
    [/[^aeiou][aeiou][tvx]ed$/, Past2],
    [/.[cdflmnprstv]ied$/, Past2, "emptied"]
  ],
  e: [
    [/.[lnr]ize$/, Inf2, "antagonize"],
    [/.[^aeiou]ise$/, Inf2, "antagonise"],
    [/.[aeiou]te$/, Inf2, "bite"],
    [/.[^aeiou][ai]ble$/, Adj3, "fixable"],
    [/.[^aeiou]eable$/, Adj3, "maleable"],
    [/.[ts]ive$/, Adj3, "festive"],
    [/[a-z]-like$/, Adj3, "woman-like"]
  ],
  h: [
    [/.[^aeiouf]ish$/, Adj3, "cornish"],
    [/.v[iy]ch$/, Last2, "..ovich"],
    [/^ug?h+$/, Exp, "ughh"],
    [/^uh[ -]?oh$/, Exp, "uhoh"],
    [/[a-z]-ish$/, Adj3, "cartoon-ish"]
  ],
  i: [[/.[oau][wvl]ski$/, Last2, "polish-male"]],
  k: [
    [/^(k){2}$/, Exp, "kkkk"]
  ],
  l: [
    [/.[gl]ial$/, Adj3, "familial"],
    [/.[^aeiou]ful$/, Adj3, "fitful"],
    [/.[nrtumcd]al$/, Adj3, "natal"],
    [/.[^aeiou][ei]al$/, Adj3, "familial"]
  ],
  m: [
    [/.[^aeiou]ium$/, Sing2, "magnesium"],
    [/[^aeiou]ism$/, Sing2, "schism"],
    [/^[hu]m+$/, Exp, "hmm"],
    [/^\d+ ?[ap]m$/, "Date", "3am"]
  ],
  n: [
    [/.[lsrnpb]ian$/, Adj3, "republican"],
    [/[^aeiou]ician$/, Actor2, "musician"],
    [/[aeiou][ktrp]in'$/, "Gerund", "cookin'"]
  ],
  o: [
    [/^no+$/, Exp, "noooo"],
    [/^(yo)+$/, Exp, "yoo"],
    [/^wo{2,}[pt]?$/, Exp, "woop"]
  ],
  r: [
    [/.[bdfklmst]ler$/, "Noun"],
    [/[aeiou][pns]er$/, Sing2],
    [/[^i]fer$/, Inf2],
    [/.[^aeiou][ao]pher$/, Actor2],
    [/.[lk]er$/, "Noun"],
    [/.ier$/, "Comparative"]
  ],
  t: [
    [/.[di]est$/, "Superlative"],
    [/.[icldtgrv]ent$/, Adj3],
    [/[aeiou].*ist$/, Adj3],
    [/^[a-z]et$/, Verb2]
  ],
  s: [
    [/.[^aeiou]ises$/, Pres2],
    [/.[rln]ates$/, Pres2],
    [/.[^z]ens$/, Verb2],
    [/.[lstrn]us$/, Sing2],
    [/.[aeiou]sks$/, Pres2],
    [/.[aeiou]kes$/, Pres2],
    [/[aeiou][^aeiou]is$/, Sing2],
    [/[a-z]'s$/, Noun3],
    [/^yes+$/, Exp]
  ],
  v: [
    [/.[^aeiou][ai][kln]ov$/, Last2]
  ],
  y: [
    [/.[cts]hy$/, Adj3],
    [/.[st]ty$/, Adj3],
    [/.[tnl]ary$/, Adj3],
    [/.[oe]ry$/, Sing2],
    [/[rdntkbhs]ly$/, Adverb],
    [/.(gg|bb|zz)ly$/, Adj3],
    [/...lly$/, Adverb],
    [/.[gk]y$/, Adj3],
    [/[bszmp]{2}y$/, Adj3],
    [/.[ai]my$/, Adj3],
    [/[ea]{2}zy$/, Adj3],
    [/.[^aeiou]ity$/, Sing2]
  ]
};

// node_modules/compromise/src/2-two/preTagger/model/patterns/neighbours.js
var vb2 = "Verb";
var nn2 = "Noun";
var neighbours_default = {
  leftTags: [
    ["Adjective", nn2],
    ["Possessive", nn2],
    ["Determiner", nn2],
    ["Adverb", vb2],
    ["Pronoun", vb2],
    ["Value", nn2],
    ["Ordinal", nn2],
    ["Modal", vb2],
    ["Superlative", nn2],
    ["Demonym", nn2],
    ["Honorific", "Person"]
  ],
  leftWords: [
    ["i", vb2],
    ["first", nn2],
    ["it", vb2],
    ["there", vb2],
    ["not", vb2],
    ["because", nn2],
    ["if", nn2],
    ["but", nn2],
    ["who", vb2],
    ["this", nn2],
    ["his", nn2],
    ["when", nn2],
    ["you", vb2],
    ["very", "Adjective"],
    ["old", nn2],
    ["never", vb2],
    ["before", nn2],
    ["a", nn2],
    ["the", nn2],
    ["been", vb2]
  ],
  rightTags: [
    ["Copula", nn2],
    ["PastTense", nn2],
    ["Conjunction", nn2],
    ["Modal", nn2]
  ],
  rightWords: [
    ["there", vb2],
    ["me", vb2],
    ["man", "Adjective"],
    ["him", vb2],
    ["it", vb2],
    ["were", nn2],
    ["took", nn2],
    ["himself", vb2],
    ["went", nn2],
    ["who", nn2],
    ["jr", "Person"]
  ]
};

// node_modules/compromise/src/2-two/preTagger/model/models/_data.js
var data_default2 = {
  "Comparative": {
    "rules": "ig|2ger,ng|2er,hin|3ner,n|1er,ot|2ter,lat|3ter,t|1er,ray|3er,y|ier,ross|4er,im|2mer,m|1er,f|1er,b|1er,er|2,r|1er,p|1er,h|1er,w|1er,k|1er,l|1er,d|1er,e|1r",
    "exceptions": "good|better,bad|worse,wet|3ter,lay|3er,neat|4ter,fat|3ter,mad|3der,sad|3der,wide|4r,late|4r,safe|4r,fine|4r,dire|4r,fake|4r,pale|4r,rare|4r,rude|4r,sore|4r",
    "rev": "arger|4,esser|5,igger|2,impler|5,reer|3,hinner|3,remier|6,urer|3,aucher|5,almer|3,raver|4,uter|3,iviner|5,erier|4,enuiner|6,rosser|4,uger|3,andomer|5,emoter|5,quarer|5,taler|4,iper|3,hiter|4,rther|5,rmer|2,ayer|2,immer|2,somer|4,amer|3,adder|2,nger|2,fer|1,tler|3,cer|2,ber|1,uer|2,bler|3,tter|1,rer|1,ser|2,per|1,her|1,wer|1,ker|1,ner|1,ler|1,ter|1,der|1,ier|y"
  },
  "Gerund": {
    "rules": "omoting|4e,haring|3e,ploring|4e,mbining|4e,nviting|4e,belling|3,ntoring|4e,uiding|3e,orging|3e,dhering|4e,alysing|4e,nciling|4e,mpeding|4e,uoting|3e,evoting|4e,nsating|4e,gnoring|4e,roding|3e,iaising|4e,esaling|4e,rowsing|4e,rfering|4e,kating|3e,robing|3e,tponing|4e,mmuting|4e,laning|3e,moking|3e,nfining|4e,nduring|4e,nciting|4e,busing|3e,eleting|4e,esiring|4e,rbating|4e,larging|4e,ploding|4e,haking|3e,hading|3e,biding|3e,udding|2,neating|4e,craping|4e,efuting|4e,thoring|4e,eusing|3e,agining|4e,rekking|3,suading|4e,ubating|4e,ronzing|4e,euvring|4e,bliging|4e,laking|3e,riming|3e,asising|4e,lunging|4e,cilling|3,pinging|4e,hoking|3e,creting|4e,ralling|3,miling|3e,wathing|4e,edoring|4e,odding|2,aloging|4e,rseding|4e,xcusing|4e,halling|3,ialling|3,inuting|4e,xciting|4e,chuting|4e,hrining|4e,eciting|4e,xuding|3e,isusing|4e,uizzing|3,ithing|3e,izzling|4e,haling|3e,dmiring|4e,rsaking|4e,parging|4e,ixating|4e,anuring|4e,iecing|3e,erusing|4e,eething|4e,entring|4e,goating|4e,langing|4e,stining|4e,lescing|4e,erlying|3ie,pleting|4e,ausing|3e,ciding|3e,enging|3e,casing|3e,cising|3e,esiding|4e,uning|2e,delling|3,storing|4e,tiring|3e,leging|3e,piling|3e,tising|3e,ecuting|4e,eduling|4e,uelling|3,liding|3e,uging|2e,celling|3,ubing|2e,laming|3e,ebating|4e,njuring|4e,scaping|4e,truding|4e,chising|4e,vading|3e,shaping|4e,iping|2e,naming|3e,ulging|3e,raking|3e,fling|2e,taping|3e,noting|3e,lading|3e,scaling|4e,riding|3e,rasing|3e,coping|3e,ruling|3e,wining|3e,viding|3e,quiring|4e,velling|3,alyzing|4e,laring|3e,coring|3e,ranging|4e,ousing|3e,puting|3e,vening|3e,idding|2,hining|3e,urging|3e,coding|3e,niting|3e,nelling|3,dising|3e,uising|3e,caring|3e,lapsing|4e,erging|3e,pating|3e,mining|3e,ibuting|4e,coming|3e,paring|3e,taking|3e,hasing|3e,vising|3e,ituting|4e,writing|4e,eezing|3e,piring|3e,luting|3e,voking|3e,iguring|4e,uming|2e,curing|3e,mising|3e,iking|2e,edding|2,luding|3e,suring|3e,rising|3e,ribing|3e,rading|3e,ceding|3e,nsing|2e,kling|2e,fusing|3e,azing|2e,cling|2e,nising|3e,ducing|3e,rcing|2e,gling|2e,easing|3e,uating|3e,lising|3e,lining|3e,mating|3e,mming|1,pling|2e,bbing|1,vating|3e,dling|2e,dating|3e,rsing|2e,dging|2e,tling|2e,turing|3e,icing|2e,acing|2e,gating|3e,gging|1,tating|3e,rring|1,nning|1,uing|1e,bling|2e,iating|3e,cating|3e,aging|2e,osing|2e,ncing|2e,nating|3e,pping|1,lating|3e,tting|1,rating|3e,ving|1e,izing|2e,ing|",
    "exceptions": "being|is,using|2e,making|3e,creating|5e,changing|5e,owing|2e,raising|4e,competing|6e,defining|5e,counselling|7,hiring|3e,filing|3e,controlling|7,totalling|5,infringing|7e,citing|3e,dying|1ie,doping|3e,baking|3e,hoping|3e,refining|5e,exchanging|7e,charging|5e,stereotyping|9e,voting|3e,tying|1ie,discharging|8e,basing|3e,lying|1ie,expediting|7e,typing|3e,breathing|6e,framing|4e,boring|3e,dining|3e,firing|3e,hiding|3e,appraising|7e,tasting|4e,waning|3e,distilling|6,baling|3e,boning|3e,faring|3e,honing|3e,wasting|4e,phoning|4e,luring|3e,propelling|6,timing|3e,wading|3e,abating|4e,compelling|6,vying|1ie,fading|3e,biting|3e,zoning|3e,dispelling|6,pasting|4e,praising|5e,telephoning|8e,daring|3e,waking|3e,shoring|4e,gaming|3e,padding|3,rerouting|6e,fringing|5e,braising|5e,coking|3e,recreating|7e,sloping|4e,sunbathing|7e,overcharging|9e,everchanging|9e,patrolling|6,joking|3e,extolling|5,expelling|5,reappraising|9e,wadding|3,gaping|3e,poking|3e,persevering|8e,pining|3e,recordkeeping|10e,landfilling|7,liming|3e,interchanging|10e,toting|3e,roping|3e,wiring|3e,aching|3e,gassing|3,getting|3,travelling|6,putting|3,sitting|3,betting|3,mapping|3,tapping|3,letting|3,hitting|3,tanning|3,netting|3,popping|3,fitting|3,deterring|5,barring|3,banning|3,vetting|3,omitting|4,wetting|3,plotting|4,budding|3,clotting|4,hemming|3,slotting|4,singeing|5,reprogramming|9,jetting|3,kidding|3,befitting|5,podding|3,wedding|3,donning|3,warring|3,penning|3,gutting|3,cueing|3,refitting|5,petting|3,cramming|4,napping|3,tinning|3",
    "rev": "lan|3ning,egin|4ning,can|3ning,pan|3ning,hin|3ning,kin|3ning,win|3ning,un|2ning,pin|3ning,n|1ing,ounsel|6ling,otal|4ling,abel|4ling,evel|4ling,ancel|5ling,istil|5ling,xcel|4ling,tencil|6ling,piral|5ling,arshal|6ling,nitial|6ling,hrivel|6ling,xtol|4ling,andfil|6ling,trol|4ling,fuel|4ling,model|5ling,nnel|4ling,pel|3ling,l|1ing,ransfer|7ring,lur|3ring,tir|3ring,tar|3ring,pur|3ring,car|3ring,nfer|4ring,efer|4ring,cur|3ring,r|1ing,ermit|5ting,ransmit|7ting,ommit|5ting,nit|3ting,orget|5ting,abysit|6ting,dmit|4ting,hut|3ting,hat|3ting,utfit|5ting,but|3ting,egret|5ting,llot|4ting,mat|3ting,pot|3ting,lit|3ting,emit|4ting,submit|6ting,pit|3ting,rot|3ting,quit|4ting,cut|3ting,set|3ting,t|1ing,tem|3ming,wim|3ming,kim|3ming,um|2ming,rim|3ming,m|1ing,tep|3ping,wap|3ping,top|3ping,hop|3ping,cap|3ping,rop|3ping,rap|3ping,lap|3ping,ip|2ping,p|1ing,ye|2ing,oe|2ing,ie|ying,ee|2ing,e|ing,hed|3ding,hred|4ding,bed|3ding,bid|3ding,d|1ing,ki|2ing,rek|3king,k|1ing,isc|3ing,echarg|6ing,ng|2ing,g|1ging,uiz|3zing,z|1ing,mb|2ing,rb|2ing,b|1bing,o|1ing,x|1ing,f|1ing,s|1ing,w|1ing,y|1ing,h|1ing"
  },
  "Participle": {
    "rules": "roken|1ake,hosen|2ose,allen|3,rozen|1eeze,asten|4,engthen|5,essen|3,hrunken|2ink,lain|2y,poken|1eak,tolen|1eal,eaten|3,un|in,itten|2e,gotten|1et,ighten|4,idden|2e,worn|1ear,sen|2,aken|3,ven|2,wn|1,rought|1ing,uilt|3d,urst|4,ealt|3,reamt|4,urt|3,nelt|2el,eapt|3,eft|1ave,eant|3,hot|2ot,pat|1it,et|2,ut|2,it|2,ent|2d,ept|1ep,urned|3,reated|5,eard|3,eld|old,ead|3,lid|3e,old|ell,ped|2ed,pilled|4,ound|ind,ved|2,aid|1y,ug|ig,ung|ing,ade|1ke,hone|1ine,come|4,gone|2,nuck|1eak,unk|ink",
    "exceptions": "been|2,bled|3ed,bought|1uy,fed|2ed,fled|3e,flown|2y,fought|1ight,had|2ve,hung|1ang,led|2ad,lit|2ght,met|2et,run|3,sat|1eat,seen|3,sought|1eek,woven|1eave,bet|3,brought|2ing,dealt|4,dived|4,heard|4,left|2ave,made|2ke,read|4,shaved|5,slain|3y",
    "rev": "uy|ought,ly|1own,ay|1id,rake|1oken,hoose|2sen,reate|5d,lee|2d,reeze|1ozen,aste|4n,rove|4n,hine|1one,lide|3,hrive|5d,come|4,ite|2ten,ide|2den,se|2n,ake|3n,ive|3n,uild|3t,old|eld,ind|ound,eed|1d,end|2t,urn|3ed,ean|3t,un|2,in|un,urst|4,right|5en,eight|5en,urt|3,eet|1t,hoot|2t,pit|1at,eat|3en,get|1otten,set|3,ut|2,it|2,ream|4t,ig|ug,ang|ung,ing|ung,all|3en,neel|2lt,ell|old,pill|4ed,teal|1olen,eap|3t,eep|1pt,ength|5en,ess|3en,hrink|2unken,neak|1uck,eek|ought,peak|1oken,ink|unk,wear|1orn,go|2ne,w|1n"
  },
  "PastTense": {
    "rules": "een|1,egan|2in,on|in,pun|1in,ewn|2,ave|ive,poke|1eak,hose|2ose,roke|1eak,roze|1eeze,ode|ide,orbade|3id,hone|1ine,tole|1eal,rose|1ise,woke|1ake,wrote|2ite,made|2ke,came|1ome,ove|ive,ore|ear,elped|3,elcomed|6,hared|4,nvited|5,eclared|6,eard|3,avelled|4,ombined|6,uided|4,etired|5,choed|3,ncelled|4,epeated|5,moked|4,entred|5,dhered|5,esired|5,ompeted|6,erseded|6,ramed|4,qualled|4,iloted|4,stponed|6,uelled|3,opelled|4,gnored|5,xtruded|6,caled|4,ndured|5,lamed|4,quared|5,mpeded|5,rouped|4,efeated|5,robed|4,lid|3e,magined|6,nselled|4,uthored|6,ebuted|4,shrined|6,tialled|4,erfered|6,eaped|3,yped|3,laked|4,tirred|3,ooted|3,leated|4,ncited|5,oubted|4,mpelled|4,nnulled|4,pined|4,ircled|5,ecited|5,reathed|6,nvaded|5,onfided|6,pedited|6,alcined|6,ycotted|5,dmired|5,xcreted|6,ubed|3,taked|4,onfined|6,heated|4,rimed|4,amelled|4,achined|6,litzed|4,xcited|5,xpelled|4,xtolled|4,ouled|3,imicked|4,ivalled|4,eeped|3,naked|4,tyled|4,iased|3,nhaled|5,oeuvred|6,grammed|6,kied|2,miled|4,pited|4,eterred|4,hoked|4,kidded|3,ollided|6,pleted|5,cided|4,plored|5,stored|5,longed|4,filed|4,rbed|2,suaded|5,ciled|4,edded|2,tined|4,phoned|5,fled|3,nited|4,iped|3,hauled|4,treated|5,nnelled|4,basted|5,njured|5,twined|5,uzzed|3,did|1o,odded|2,vided|4,old|ell,pared|4,mbed|2,stood|2and,pired|4,held|1old,vened|4,cored|4,read|4,piled|4,aped|3,gled|3,named|4,arred|2,oated|3,kled|3,ooled|3,uned|3,figured|6,bid|3,ound|ind,oped|2,ibed|3,quired|5,uled|3,oded|3,ceded|4,cured|4,sided|4,voked|4,rled|2,outed|3,mined|4,urred|2,ighted|4,umed|3,sured|4,iked|3,mmed|1,pled|3,fed|1,bbed|1,eled|2,luded|4,aid|1y,ferred|3,tled|3,dled|3,raded|4,oted|3,eed|2,aled|2,lined|4,mped|2,fted|2,lted|2,gged|1,eted|2,xed|1,bled|3,pted|2,tured|4,uted|3,ued|2,iled|2,nned|1,yed|1,rted|2,pped|1,tted|1,wed|1,lled|2,ited|2,med|1,sted|2,ssed|2,ged|2,ved|2,nted|2,ked|1,cted|2,ced|2,ied|y,hed|1,sed|2,ded|1,zed|2,ned|1,red|1,ated|3,ell|all,rought|1ing,hought|1ink,eft|1ave,eant|3,ealt|3,eat|3,hot|2ot,urt|3,eapt|3,elt|1el,went|go,built|4d,at|it,got|1et,ut|2,it|2,et|2,ent|2d,ept|1ep,st|2,truck|2ike,nuck|1eak,tunk|1ink,ank|ink,ook|ake,ug|ig,ang|ing,ung|ing,nderlay|5ie,dezvous|7,wam|1im,drew|2aw,saw|1ee,ew|ow",
    "exceptions": "was|is,were|are,had|2ve,led|2ad,met|2et,cited|4,focused|5,sought|1eek,lost|3e,defined|6,died|3,hired|4,bought|1uy,ran|1un,controlled|7,taught|1each,hoped|4,shed|4,refined|6,caught|2tch,flew|2y,owed|3,fought|1ight,fired|4,fed|2ed,pied|3,fared|4,tied|3,fled|3e,cared|4,ate|eat,dyed|3,lit|2ght,winged|4,bred|3ed,pent|3,wired|4,persevered|9,baked|4,dined|4,fined|4,shored|5,hid|3e,padded|3,waned|4,wove|1eave,lied|3,wasted|5,sloped|5,joked|4,ached|4,baled|4,bit|3e,bled|3ed,boned|4,caned|4,dispelled|6,egged|3,hung|1ang,patrolled|6,tasted|5,faked|4,bored|4,eyed|3,gamed|4,gassed|3,pored|4,timed|4,toned|4,zoned|4,poked|4,dared|4,been|2,said|2y,found|1ind,took|1ake,came|1ome,gave|1ive,fell|1all,brought|2ing,rose|1ise,put|3,sent|3d,spent|4d,spoke|2eak,left|2ave,won|1in,told|1ell,meant|4,heard|4,got|1et,arose|2ise,read|4,let|3,hit|3,cost|4,dealt|4,laid|2y,drove|2ive,sat|1it,cast|4,beat|4,lent|3d,sang|1ing,banned|3,jarred|3,wound|1ind,omitted|4,quit|4,slid|4e,rang|1ing,fit|3,rent|3d,bet|3,sank|1ink,reaped|4,manned|3,rode|1ide,rebutted|5,bound|1ind,barred|3,recast|6,netted|3,tanned|3,plotted|4,tore|1ear,spun|2in,pitted|3,shone|2ine,donned|3,dove|1ive,spat|2it,bent|3d,leapt|4,seeped|4,sewn|3,twinned|4,wrung|2ing,deterred|5,blew|2ow",
    "rev": "egin|2an,lan|3ned,nderpin|7ned,kin|3ned,hin|3ned,pan|3ned,can|3ned,un|2ned,n|1ed,ecome|2ame,hoose|2se,trike|2uck,lee|2d,trive|2ove,vercome|4ame,reeze|1oze,hake|1ook,nderlie|5ay,istake|3ook,etake|2ook,wake|1oke,write|2ote,make|2de,rtake|2ook,see|1aw,e|1d,elp|3ed,roup|4ed,oop|3ed,velop|5ed,eep|1pt,mp|2ed,p|1ped,hink|1ought,eek|ought,reak|1oke,neak|1uck,tink|1unk,rink|1ank,k|1ed,ommit|5ted,ermit|5ted,oadcast|7,dmit|4ted,hoot|2t,plit|4,hut|3,llot|4ted,nit|3ted,orget|3ot,egret|5ted,hrust|5,ormat|5ted,hat|3ted,lat|3ted,urt|3,cquit|5ted,urst|4,ransmit|7ted,emit|4ted,pot|3ted,cut|3,submit|6ted,set|3,t|1ed,now|1ew,trew|4n,draw|2ew,throw|3ew,grow|2ew,w|1ed,uy|ought,ey|2ed,pay|2id,oy|2ed,ay|2ed,y|ied,ravel|5led,ancel|5led,qual|4led,uel|3led,ounsel|6led,nitial|6led,nnul|4led,namel|5led,xtol|4led,ival|4led,teal|1ole,eel|1lt,trol|4led,sell|1old,nnel|4led,pel|3led,l|1ed,ransfer|7red,pur|3red,lur|3red,tir|3red,par|3red,nfer|4red,wear|1ore,bear|1ore,efer|4red,cur|3red,r|1ed,pread|5,hed|3,rind|1ound,mbed|4ded,reed|2d,hred|4ded,eread|5,orbid|3ade,leed|2d,kid|3ded,build|4t,od|2ded,stand|2ood,hold|1eld,bid|3,d|1ed,cho|3ed,go|went,do|1id,tem|3med,um|2med,rim|3med,kim|3med,wim|1am,lam|3med,m|1ed,lug|3ged,ig|ug,pring|2ang,gg|2ed,ang|ung,long|4ed,og|2ged,ling|1ung,ag|2ged,ub|2bed,ib|2bed,ob|2bed,rb|2ed,ab|2bed,mb|2ed,imic|4ked,dezvous|7,s|1ed,ki|2ed,z|1ed,f|1ed,x|1ed,h|1ed"
  },
  "PresentTense": {
    "rules": "as|1ve,tudies|3y,mbodies|4y,evies|2y,arties|3y,emedies|4y,mpties|3y,eadies|3y,obbies|3y,ullies|3y,nesties|4y,zzes|2,pies|1y,nies|1y,oes|1,xes|1,plies|2y,ries|1y,shes|2,sses|2,ches|2,fies|1y,s|",
    "exceptions": "are|is,focuses|5,relies|3y,flies|2y,gasses|3,has|2ve",
    "rev": "uy|2s,oy|2s,ey|2s,ay|2s,y|ies,adio|4s,aboo|4s,o|1es,tograph|7s,erth|4s,gh|2s,h|1es,as|2ses,s|1es,ic|2s,zz|2es,x|1es,f|1s,b|1s,g|1s,m|1s,w|1s,p|1s,k|1s,l|1s,d|1s,n|1s,r|1s,t|1s,e|1s"
  },
  "Superlative": {
    "rules": "east|4,uthwest|7,ot|2test,it|2test,lat|3test,weet|4test,t|1est,ig|2gest,ng|2est,hin|3nest,n|1est,nner|4most,uter|4most,r|1est,rey|3est,ricey|3iest,y|iest,ross|4est,f|1est,b|1est,m|1est,p|1est,h|1est,w|1est,k|1est,l|1est,d|1est,e|1st",
    "exceptions": "good|best,bad|worst,wet|3test,far|1urthest,gay|3est,neat|4test,shy|3est,fat|3test,late|4st,wide|4st,fine|4st,severe|6st,fake|4st,pale|4st,rare|4st,rude|4st,sore|4st,dire|4st",
    "rev": "east|4,argest|4,iggest|2,implest|5,afest|3,uthwest|7,hinnest|3,ncerest|5,urthest|ar,ravest|4,utest|3,eriest|4,rossest|4,dsomest|5,ugest|3,riciest|3ey,emotest|5,quarest|5,rangest|5,ipest|3,urest|3,cest|2,ermost|2,fest|1,best|1,amest|3,itest|3,ngest|2,uest|2,yest|1,tlest|3,mest|1,blest|3,sest|2,pest|1,hest|1,ttest|1,west|1,rest|1,kest|1,nest|1,lest|1,test|1,dest|1,iest|y"
  }
};

// node_modules/suffix-thumb/src/convert/index.js
var prefix2 = /^.([0-9]+)/;
var getKeyVal = function(word, model5) {
  let val = model5.exceptions[word];
  let m3 = val.match(prefix2);
  if (m3 === null) {
    return model5.exceptions[word];
  }
  let num = Number(m3[1]) || 0;
  let pre = word.substr(0, num);
  return pre + val.replace(prefix2, "");
};
var getRules = function(word, rules2 = {}) {
  let char = word[word.length - 1];
  let list4 = rules2[char] || [];
  if (rules2[""]) {
    list4 = list4.concat(rules2[""]);
  }
  return list4;
};
var convert = function(word, model5, debug2) {
  if (model5.exceptions.hasOwnProperty(word)) {
    if (debug2) {
      console.log("exception, ", word, model5.exceptions[word]);
    }
    return getKeyVal(word, model5);
  }
  let rules2 = model5.rules;
  if (model5.reversed) {
    rules2 = model5.rev;
  }
  rules2 = getRules(word, rules2);
  for (let i3 = 0; i3 < rules2.length; i3 += 1) {
    let suffix = rules2[i3][0];
    if (word.endsWith(suffix)) {
      if (debug2) {
        console.log("rule, ", rules2[i3]);
      }
      let reg = new RegExp(suffix + "$");
      return word.replace(reg, rules2[i3][1]);
    }
  }
  if (debug2) {
    console.log(" x - " + word);
  }
  return word;
};
var convert_default = convert;

// node_modules/suffix-thumb/src/_lib.js
var indexRules = function(rules2) {
  let byChar = {};
  rules2.forEach((a2) => {
    let suff = a2[0] || "";
    let char = suff[suff.length - 1] || "";
    byChar[char] = byChar[char] || [];
    byChar[char].push(a2);
  });
  return byChar;
};

// node_modules/suffix-thumb/src/compress/uncompress.js
var prefix3 = /^([0-9]+)/;
var expand3 = function(key = "", val = "") {
  val = String(val);
  let m3 = val.match(prefix3);
  if (m3 === null) {
    return [key, val];
  }
  let num = Number(m3[1]) || 0;
  let pre = key.substring(0, num);
  let full = pre + val.replace(prefix3, "");
  return [key, full];
};
var toArray2 = function(txt) {
  const pipe = /\|/;
  return txt.split(/,/).map((str) => {
    let a2 = str.split(pipe);
    return expand3(a2[0], a2[1]);
  });
};
var uncompress = function(model5 = {}) {
  model5 = Object.assign({}, model5);
  model5.rules = toArray2(model5.rules);
  model5.rules = indexRules(model5.rules);
  if (model5.rev) {
    model5.rev = toArray2(model5.rev);
    model5.rev = indexRules(model5.rev);
  }
  model5.exceptions = toArray2(model5.exceptions);
  model5.exceptions = model5.exceptions.reduce((h2, a2) => {
    h2[a2[0]] = a2[1];
    return h2;
  }, {});
  return model5;
};
var uncompress_default = uncompress;

// node_modules/suffix-thumb/src/reverse/index.js
var reverseObj = function(obj) {
  return Object.entries(obj).reduce((h2, a2) => {
    h2[a2[1]] = a2[0];
    return h2;
  }, {});
};
var reverse2 = function(model5) {
  let { rules: rules2, exceptions: exceptions5, rev } = model5;
  exceptions5 = reverseObj(exceptions5);
  return {
    reversed: !Boolean(model5.reversed),
    rules: rules2,
    exceptions: exceptions5,
    rev
  };
};
var reverse_default = reverse2;

// node_modules/compromise/src/2-two/preTagger/model/models/index.js
var fromPast = uncompress_default(data_default2.PastTense);
var fromPresent = uncompress_default(data_default2.PresentTense);
var fromGerund = uncompress_default(data_default2.Gerund);
var fromParticiple = uncompress_default(data_default2.Participle);
var toPast = reverse_default(fromPast);
var toPresent = reverse_default(fromPresent);
var toGerund = reverse_default(fromGerund);
var toParticiple = reverse_default(fromParticiple);
var toComparative = uncompress_default(data_default2.Comparative);
var toSuperlative = uncompress_default(data_default2.Superlative);
var fromComparative = reverse_default(toComparative);
var fromSuperlative = reverse_default(toSuperlative);
var models_default = {
  fromPast,
  fromPresent,
  fromGerund,
  fromParticiple,
  toPast,
  toPresent,
  toGerund,
  toParticiple,
  toComparative,
  toSuperlative,
  fromComparative,
  fromSuperlative
};

// node_modules/compromise/src/2-two/preTagger/model/regex/regex-normal.js
var regex_normal_default = [
  [/^[\w.]+@[\w.]+\.[a-z]{2,3}$/, "Email"],
  [/^(https?:\/\/|www\.)+\w+\.[a-z]{2,3}/, "Url", "http.."],
  [/^[a-z0-9./].+\.(com|net|gov|org|ly|edu|info|biz|dev|ru|jp|de|in|uk|br|io|ai)/, "Url", ".com"],
  [/^[PMCE]ST$/, "Timezone", "EST"],
  [/^ma?c'.*/, "LastName", "mc'neil"],
  [/^o'[drlkn].*/, "LastName", "o'connor"],
  [/^ma?cd[aeiou]/, "LastName", "mcdonald"],
  [/^(lol)+[sz]$/, "Expression", "lol"],
  [/^wo{2,}a*h?$/, "Expression", "wooah"],
  [/^(hee?){2,}h?$/, "Expression", "hehe"],
  [/^(un|de|re)\\-[a-z\u00C0-\u00FF]{2}/, "Verb", "un-vite"],
  [/^(m|k|cm|km)\/(s|h|hr)$/, "Unit", "5 k/m"],
  [/^(ug|ng|mg)\/(l|m3|ft3)$/, "Unit", "ug/L"]
];

// node_modules/compromise/src/2-two/preTagger/model/regex/regex-text.js
var regex_text_default = [
  [/^#[\p{Number}_]*\p{Letter}/u, "HashTag"],
  [/^@\w{2,}$/, "AtMention"],
  [/^([A-Z]\.){2}[A-Z]?/i, ["Acronym", "Noun"], "F.B.I"],
  [/.{3}[lkmnp]in['‘’‛‵′`´]$/, "Gerund", "chillin'"],
  [/.{4}s['‘’‛‵′`´]$/, "Possessive", "flanders'"],
  [/^[\p{Emoji_Presentation}\p{Extended_Pictographic}]/u, "Emoji", "emoji-class"]
];

// node_modules/compromise/src/2-two/preTagger/model/regex/regex-numbers.js
var regex_numbers_default = [
  [/^@1?[0-9](am|pm)$/i, "Time", "3pm"],
  [/^@1?[0-9]:[0-9]{2}(am|pm)?$/i, "Time", "3:30pm"],
  [/^'[0-9]{2}$/, "Year"],
  [/^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])$/, "Time", "3:12:31"],
  [/^[012]?[0-9](:[0-5][0-9])?(:[0-5][0-9])? ?(am|pm)$/i, "Time", "1:12pm"],
  [/^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])? ?(am|pm)?$/i, "Time", "1:12:31pm"],
  [/^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}/i, "Date", "iso-date"],
  [/^[0-9]{1,4}-[0-9]{1,2}-[0-9]{1,4}$/, "Date", "iso-dash"],
  [/^[0-9]{1,4}\/[0-9]{1,2}\/([0-9]{4}|[0-9]{2})$/, "Date", "iso-slash"],
  [/^[0-9]{1,4}\.[0-9]{1,2}\.[0-9]{1,4}$/, "Date", "iso-dot"],
  [/^[0-9]{1,4}-[a-z]{2,9}-[0-9]{1,4}$/i, "Date", "12-dec-2019"],
  [/^utc ?[+-]?[0-9]+$/, "Timezone", "utc-9"],
  [/^(gmt|utc)[+-][0-9]{1,2}$/i, "Timezone", "gmt-3"],
  [/^[0-9]{3}-[0-9]{4}$/, "PhoneNumber", "421-0029"],
  [/^(\+?[0-9][ -])?[0-9]{3}[ -]?[0-9]{3}-[0-9]{4}$/, "PhoneNumber", "1-800-"],
  [
    /^[-+]?\p{Currency_Symbol}[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?([kmb]|bn)?\+?$/u,
    ["Money", "Value"],
    "$5.30"
  ],
  [
    /^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?\p{Currency_Symbol}\+?$/u,
    ["Money", "Value"],
    "5.30\xA3"
  ],
  [/^[-+]?[$£]?[0-9]([0-9,.])+(usd|eur|jpy|gbp|cad|aud|chf|cny|hkd|nzd|kr|rub)$/i, ["Money", "Value"], "$400usd"],
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?\+?$/, ["Cardinal", "NumericValue"], "5,999"],
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?(st|nd|rd|r?th)$/, ["Ordinal", "NumericValue"], "53rd"],
  [/^\.[0-9]+\+?$/, ["Cardinal", "NumericValue"], ".73th"],
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?%\+?$/, ["Percent", "Cardinal", "NumericValue"], "-4%"],
  [/^\.[0-9]+%$/, ["Percent", "Cardinal", "NumericValue"], ".3%"],
  [/^[0-9]{1,4}\/[0-9]{1,4}(st|nd|rd|th)?s?$/, ["Fraction", "NumericValue"], "2/3rds"],
  [/^[0-9.]{1,3}[a-z]{0,2}[-–—][0-9]{1,3}[a-z]{0,2}$/, ["Value", "NumberRange"], "3-4"],
  [/^[0-9]{1,2}(:[0-9][0-9])?(am|pm)? ?[-–—] ?[0-9]{1,2}(:[0-9][0-9])?(am|pm)$/, ["Time", "NumberRange"], "3-4pm"],
  [/^[0-9.]+([a-z°]{1,4})$/, "NumericValue", "9km"]
];

// node_modules/compromise/src/2-two/preTagger/model/orgWords.js
var orgWords_default = [
  "academy",
  "administration",
  "agence",
  "agences",
  "agencies",
  "agency",
  "airlines",
  "airways",
  "army",
  "assoc",
  "associates",
  "association",
  "assurance",
  "authority",
  "autorite",
  "aviation",
  "bank",
  "banque",
  "board",
  "boys",
  "brands",
  "brewery",
  "brotherhood",
  "brothers",
  "bureau",
  "cafe",
  "co",
  "caisse",
  "capital",
  "care",
  "cathedral",
  "center",
  "centre",
  "chemicals",
  "choir",
  "chronicle",
  "church",
  "circus",
  "clinic",
  "clinique",
  "club",
  "co",
  "coalition",
  "coffee",
  "collective",
  "college",
  "commission",
  "committee",
  "communications",
  "community",
  "company",
  "comprehensive",
  "computers",
  "confederation",
  "conference",
  "conseil",
  "consulting",
  "containers",
  "corporation",
  "corps",
  "corp",
  "council",
  "crew",
  "data",
  "departement",
  "department",
  "departments",
  "design",
  "development",
  "directorate",
  "division",
  "drilling",
  "education",
  "eglise",
  "electric",
  "electricity",
  "energy",
  "ensemble",
  "enterprise",
  "enterprises",
  "entertainment",
  "estate",
  "etat",
  "faculty",
  "federation",
  "financial",
  "fm",
  "foundation",
  "fund",
  "gas",
  "gazette",
  "girls",
  "government",
  "group",
  "guild",
  "herald",
  "holdings",
  "hospital",
  "hotel",
  "hotels",
  "inc",
  "industries",
  "institut",
  "institute",
  "institutes",
  "insurance",
  "international",
  "interstate",
  "investment",
  "investments",
  "investors",
  "journal",
  "laboratory",
  "labs",
  "llc",
  "ltd",
  "limited",
  "machines",
  "magazine",
  "management",
  "marine",
  "marketing",
  "markets",
  "media",
  "memorial",
  "ministere",
  "ministry",
  "military",
  "mobile",
  "motor",
  "motors",
  "musee",
  "museum",
  "news",
  "observatory",
  "office",
  "oil",
  "optical",
  "orchestra",
  "organization",
  "partners",
  "partnership",
  "petrol",
  "petroleum",
  "pharmacare",
  "pharmaceutical",
  "pharmaceuticals",
  "pizza",
  "plc",
  "police",
  "polytechnic",
  "post",
  "power",
  "press",
  "productions",
  "quartet",
  "radio",
  "reserve",
  "resources",
  "restaurant",
  "restaurants",
  "savings",
  "school",
  "securities",
  "service",
  "services",
  "societe",
  "society",
  "sons",
  "subcommittee",
  "syndicat",
  "systems",
  "telecommunications",
  "telegraph",
  "television",
  "times",
  "tribunal",
  "tv",
  "union",
  "university",
  "utilities",
  "workers"
].reduce((h2, str) => {
  h2[str] = true;
  return h2;
}, {});

// node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toSingular/_rules.js
var rules_default2 = [
  [/([^v])ies$/i, "$1y"],
  [/(ise)s$/i, "$1"],
  [/(kn|[^o]l|w)ives$/i, "$1ife"],
  [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)ves$/i, "$1f"],
  [/^(dwar|handkerchie|hoo|scar|whar)ves$/i, "$1f"],
  [/(antenn|formul|nebul|vertebr|vit)ae$/i, "$1a"],
  [/(octop|vir|radi|nucle|fung|cact|stimul)(i)$/i, "$1us"],
  [/(buffal|tomat|tornad)(oes)$/i, "$1o"],
  [/(ause)s$/i, "$1"],
  [/(ease)s$/i, "$1"],
  [/(ious)es$/i, "$1"],
  [/(ouse)s$/i, "$1"],
  [/(ose)s$/i, "$1"],
  [/(..[aeiu]s)es$/i, "$1"],
  [/(vert|ind|cort)(ices)$/i, "$1ex"],
  [/(matr|append)(ices)$/i, "$1ix"],
  [/([xo]|ch|ss|sh)es$/i, "$1"],
  [/men$/i, "man"],
  [/(n)ews$/i, "$1ews"],
  [/([ti])a$/i, "$1um"],
  [/([^aeiouy]|qu)ies$/i, "$1y"],
  [/(s)eries$/i, "$1eries"],
  [/(m)ovies$/i, "$1ovie"],
  [/(cris|ax|test)es$/i, "$1is"],
  [/(alias|status)es$/i, "$1"],
  [/(ss)$/i, "$1"],
  [/(ic)s$/i, "$1"],
  [/s$/i, ""]
];

// node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toSingular/index.js
var invertObj = function(obj) {
  return Object.keys(obj).reduce((h2, k2) => {
    h2[obj[k2]] = k2;
    return h2;
  }, {});
};
var toSingular = function(str, model5) {
  const { irregularPlurals } = model5.two;
  let invert = invertObj(irregularPlurals);
  if (invert.hasOwnProperty(str)) {
    return invert[str];
  }
  for (let i3 = 0; i3 < rules_default2.length; i3++) {
    if (rules_default2[i3][0].test(str) === true) {
      str = str.replace(rules_default2[i3][0], rules_default2[i3][1]);
      return str;
    }
  }
  return str;
};
var toSingular_default = toSingular;

// node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/index.js
var all = function(str, model5) {
  let arr = [str];
  let p4 = toPlural_default(str, model5);
  if (p4 !== str) {
    arr.push(p4);
  }
  let s3 = toSingular_default(str, model5);
  if (s3 !== str) {
    arr.push(s3);
  }
  return arr;
};
var nouns_default2 = { toPlural: toPlural_default, toSingular: toSingular_default, all };

// node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/getTense/_guess.js
var guessVerb = {
  Gerund: ["ing"],
  Actor: ["erer"],
  Infinitive: [
    "ate",
    "ize",
    "tion",
    "rify",
    "then",
    "ress",
    "ify",
    "age",
    "nce",
    "ect",
    "ise",
    "ine",
    "ish",
    "ace",
    "ash",
    "ure",
    "tch",
    "end",
    "ack",
    "and",
    "ute",
    "ade",
    "ock",
    "ite",
    "ase",
    "ose",
    "use",
    "ive",
    "int",
    "nge",
    "lay",
    "est",
    "ain",
    "ant",
    "ent",
    "eed",
    "er",
    "le",
    "unk",
    "ung",
    "upt",
    "en"
  ],
  PastTense: ["ept", "ed", "lt", "nt", "ew", "ld"],
  PresentTense: [
    "rks",
    "cks",
    "nks",
    "ngs",
    "mps",
    "tes",
    "zes",
    "ers",
    "les",
    "acks",
    "ends",
    "ands",
    "ocks",
    "lays",
    "eads",
    "lls",
    "els",
    "ils",
    "ows",
    "nds",
    "ays",
    "ams",
    "ars",
    "ops",
    "ffs",
    "als",
    "urs",
    "lds",
    "ews",
    "ips",
    "es",
    "ts",
    "ns"
  ],
  Participle: ["ken", "wn"]
};
guessVerb = Object.keys(guessVerb).reduce((h2, k2) => {
  guessVerb[k2].forEach((a2) => h2[a2] = k2);
  return h2;
}, {});
var guess_default = guessVerb;

// node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/getTense/index.js
var getTense = function(str) {
  let three = str.substring(str.length - 3);
  if (guess_default.hasOwnProperty(three) === true) {
    return guess_default[three];
  }
  let two = str.substring(str.length - 2);
  if (guess_default.hasOwnProperty(two) === true) {
    return guess_default[two];
  }
  let one = str.substring(str.length - 1);
  if (one === "s") {
    return "PresentTense";
  }
  return null;
};
var getTense_default = getTense;

// node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/toInfinitive/index.js
var toParts = function(str, model5) {
  let prefix6 = "";
  let prefixes2 = {};
  if (model5.one && model5.one.prefixes) {
    prefixes2 = model5.one.prefixes;
  }
  let [verb, particle] = str.split(/ /);
  if (particle && prefixes2[verb] === true) {
    prefix6 = verb;
    verb = particle;
    particle = "";
  }
  return {
    prefix: prefix6,
    verb,
    particle
  };
};
var copulaMap = {
  are: "be",
  were: "be",
  been: "be",
  is: "be",
  am: "be",
  was: "be",
  be: "be",
  being: "be"
};
var toInfinitive = function(str, model5, tense) {
  const { fromPast: fromPast2, fromPresent: fromPresent2, fromGerund: fromGerund2, fromParticiple: fromParticiple2 } = model5.two.models;
  let { prefix: prefix6, verb, particle } = toParts(str, model5);
  let inf = "";
  if (!tense) {
    tense = getTense_default(str);
  }
  if (copulaMap.hasOwnProperty(str)) {
    inf = copulaMap[str];
  } else if (tense === "Participle") {
    inf = convert_default(verb, fromParticiple2);
  } else if (tense === "PastTense") {
    inf = convert_default(verb, fromPast2);
  } else if (tense === "PresentTense") {
    inf = convert_default(verb, fromPresent2);
  } else if (tense === "Gerund") {
    inf = convert_default(verb, fromGerund2);
  } else {
    return str;
  }
  if (particle) {
    inf += " " + particle;
  }
  if (prefix6) {
    inf = prefix6 + " " + inf;
  }
  return inf;
};
var toInfinitive_default = toInfinitive;

// node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/conjugate/index.js
var parse3 = (inf) => {
  if (/ /.test(inf)) {
    return inf.split(/ /);
  }
  return [inf, ""];
};
var conjugate = function(inf, model5) {
  const { toPast: toPast4, toPresent: toPresent4, toGerund: toGerund4, toParticiple: toParticiple2 } = model5.two.models;
  if (inf === "be") {
    return {
      Infinitive: inf,
      Gerund: "being",
      PastTense: "was",
      PresentTense: "is"
    };
  }
  let [str, particle] = parse3(inf);
  let found = {
    Infinitive: inf,
    PastTense: convert_default(str, toPast4),
    PresentTense: convert_default(str, toPresent4),
    Gerund: convert_default(str, toGerund4),
    FutureTense: "will " + inf
  };
  let pastPrt = convert_default(str, toParticiple2);
  if (pastPrt !== inf && pastPrt !== found.PastTense) {
    found.Participle = pastPrt;
  }
  if (particle) {
    Object.keys(found).forEach((k2) => {
      found[k2] += " " + particle;
    });
  }
  return found;
};
var conjugate_default = conjugate;

// node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/index.js
var all2 = function(str, model5) {
  let res = conjugate_default(str, model5);
  delete res.FutureTense;
  return Object.values(res).filter((s3) => s3);
};
var verbs_default = {
  toInfinitive: toInfinitive_default,
  conjugate: conjugate_default,
  all: all2
};

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/inflect.js
var toSuperlative2 = function(adj, model5) {
  const mod = model5.two.models.toSuperlative;
  return convert_default(adj, mod);
};
var toComparative2 = function(adj, model5) {
  const mod = model5.two.models.toComparative;
  return convert_default(adj, mod);
};
var fromComparative2 = function(adj, model5) {
  const mod = model5.two.models.fromComparative;
  return convert_default(adj, mod);
};
var fromSuperlative2 = function(adj, model5) {
  const mod = model5.two.models.fromSuperlative;
  return convert_default(adj, mod);
};

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/adverbs/lib.js
var suffixLoop = function(str = "", suffixes6 = []) {
  const len = str.length;
  let max3 = len <= 6 ? len - 1 : 6;
  for (let i3 = max3; i3 >= 1; i3 -= 1) {
    let suffix = str.substring(len - i3, str.length);
    if (suffixes6[suffix.length].hasOwnProperty(suffix) === true) {
      let pre = str.slice(0, len - i3);
      let post = suffixes6[suffix.length][suffix];
      return pre + post;
    }
  }
  return null;
};
var lib_default6 = suffixLoop;

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/adverbs/toAdjective.js
var s2 = "ically";
var ical = /* @__PURE__ */ new Set([
  "analyt" + s2,
  "chem" + s2,
  "class" + s2,
  "clin" + s2,
  "crit" + s2,
  "ecolog" + s2,
  "electr" + s2,
  "empir" + s2,
  "frant" + s2,
  "grammat" + s2,
  "ident" + s2,
  "ideolog" + s2,
  "log" + s2,
  "mag" + s2,
  "mathemat" + s2,
  "mechan" + s2,
  "med" + s2,
  "method" + s2,
  "method" + s2,
  "mus" + s2,
  "phys" + s2,
  "phys" + s2,
  "polit" + s2,
  "pract" + s2,
  "rad" + s2,
  "satir" + s2,
  "statist" + s2,
  "techn" + s2,
  "technolog" + s2,
  "theoret" + s2,
  "typ" + s2,
  "vert" + s2,
  "whims" + s2
]);
var suffixes2 = [
  null,
  {},
  { "ly": "" },
  {
    "ily": "y",
    "bly": "ble",
    "ply": "ple"
  },
  {
    "ally": "al",
    "rply": "rp"
  },
  {
    "ually": "ual",
    "ially": "ial",
    "cally": "cal",
    "eally": "eal",
    "rally": "ral",
    "nally": "nal",
    "mally": "mal",
    "eeply": "eep",
    "eaply": "eap"
  },
  {
    ically: "ic"
  }
];
var noAdj = /* @__PURE__ */ new Set([
  "early",
  "only",
  "hourly",
  "daily",
  "weekly",
  "monthly",
  "yearly",
  "mostly",
  "duly",
  "unduly",
  "especially",
  "undoubtedly",
  "conversely",
  "namely",
  "exceedingly",
  "presumably",
  "accordingly",
  "overly",
  "best",
  "latter",
  "little",
  "long",
  "low"
]);
var exceptions = {
  wholly: "whole",
  fully: "full",
  truly: "true",
  gently: "gentle",
  singly: "single",
  customarily: "customary",
  idly: "idle",
  publically: "public",
  quickly: "fast",
  well: "good"
};
var toAdjective = function(str) {
  if (!str.endsWith("ly")) {
    return null;
  }
  if (ical.has(str)) {
    return str.replace(/ically/, "ical");
  }
  if (noAdj.has(str)) {
    return null;
  }
  if (exceptions.hasOwnProperty(str)) {
    return exceptions[str];
  }
  return lib_default6(str, suffixes2) || str;
};
var toAdjective_default = toAdjective;

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/adverbs/toAdverb.js
var suffixes3 = [
  null,
  {
    y: "ily"
  },
  {
    ly: "ly",
    ic: "ically"
  },
  {
    ial: "ially",
    ual: "ually",
    tle: "tly",
    ble: "bly",
    ple: "ply",
    ary: "arily"
  },
  {},
  {},
  {}
];
var exceptions2 = {
  cool: "cooly",
  whole: "wholly",
  full: "fully",
  good: "well",
  idle: "idly",
  public: "publicly",
  single: "singly",
  special: "especially"
};
var toAdverb = function(str) {
  if (exceptions2.hasOwnProperty(str)) {
    return exceptions2[str];
  }
  let res = lib_default6(str, suffixes3);
  if (res) {
    return res;
  }
  return str + "ly";
};
var toAdverb_default = toAdverb;

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/adverbs/toNoun.js
var suffixes4 = [
  null,
  {
    "y": "iness"
  },
  {
    "le": "ility",
    "al": "ality",
    "ay": "ayness"
  },
  {
    "ial": "y",
    "ing": "ment",
    "ess": "essness",
    "ous": "ousness",
    "ive": "ivity",
    "ect": "ection"
  },
  {
    "ting": "ting",
    "ring": "ring",
    "cial": "ciality",
    "nate": "nation",
    "rate": "ration",
    "bing": "bingness",
    "atic": "acy",
    "sing": "se",
    "iful": "y",
    "ible": "ibility"
  },
  {
    "erate": "eration"
  },
  {
    "ionate": "ion"
  }
];
var exceptions3 = {
  clean: "cleanliness",
  naive: "naivety",
  dramatic: "drama",
  ironic: "irony",
  deep: "depth",
  automatic: "automation",
  simple: "simplicity",
  boring: "boredom",
  free: "freedom",
  wise: "wisdom",
  fortunate: "fortune",
  gentle: "gentleness",
  quiet: "quiet",
  expensive: "expense",
  offensive: "offence"
};
var dontDo = /* @__PURE__ */ new Set([
  "terrible",
  "annoying"
]);
var toNoun = function(str) {
  if (exceptions3.hasOwnProperty(str)) {
    return exceptions3[str];
  }
  if (dontDo.has(str)) {
    return null;
  }
  let res = lib_default6(str, suffixes4);
  if (res) {
    return res;
  }
  return str + "ness";
};
var toNoun_default = toNoun;

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/index.js
var all3 = function(str, model5) {
  let arr = [str];
  arr.push(toSuperlative2(str, model5));
  arr.push(toComparative2(str, model5));
  arr.push(toAdverb_default(str));
  arr = arr.filter((s3) => s3);
  arr = new Set(arr);
  return Array.from(arr);
};
var adjectives_default = {
  toSuperlative: toSuperlative2,
  toComparative: toComparative2,
  toAdverb: toAdverb_default,
  toNoun: toNoun_default,
  fromAdverb: toAdjective_default,
  fromSuperlative: fromSuperlative2,
  fromComparative: fromComparative2,
  all: all3
};

// node_modules/compromise/src/2-two/preTagger/methods/transform/index.js
var transform_default = {
  noun: nouns_default2,
  verb: verbs_default,
  adjective: adjectives_default
};

// node_modules/compromise/src/2-two/preTagger/methods/expand/byTag.js
var byTag_default = {
  Singular: (word, lex, methods16, model5) => {
    let already = model5.one.lexicon;
    let plural2 = methods16.two.transform.noun.toPlural(word, model5);
    if (!already[plural2]) {
      lex[plural2] = lex[plural2] || "Plural";
    }
  },
  Actor: (word, lex, methods16, model5) => {
    let already = model5.one.lexicon;
    let plural2 = methods16.two.transform.noun.toPlural(word, model5);
    if (!already[plural2]) {
      lex[plural2] = lex[plural2] || ["Plural", "Actor"];
    }
  },
  Comparable: (word, lex, methods16, model5) => {
    let already = model5.one.lexicon;
    let { toSuperlative: toSuperlative3, toComparative: toComparative3 } = methods16.two.transform.adjective;
    let sup = toSuperlative3(word, model5);
    if (!already[sup]) {
      lex[sup] = lex[sup] || "Superlative";
    }
    let comp = toComparative3(word, model5);
    if (!already[comp]) {
      lex[comp] = lex[comp] || "Comparative";
    }
    lex[word] = "Adjective";
  },
  Demonym: (word, lex, methods16, model5) => {
    let plural2 = methods16.two.transform.noun.toPlural(word, model5);
    lex[plural2] = lex[plural2] || ["Demonym", "Plural"];
  },
  Infinitive: (word, lex, methods16, model5) => {
    let already = model5.one.lexicon;
    let all4 = methods16.two.transform.verb.conjugate(word, model5);
    Object.entries(all4).forEach((a2) => {
      if (!already[a2[1]] && !lex[a2[1]]) {
        lex[a2[1]] = a2[0];
      }
    });
  },
  PhrasalVerb: (word, lex, methods16, model5) => {
    let already = model5.one.lexicon;
    lex[word] = ["PhrasalVerb", "Infinitive"];
    let _multi = model5.one._multiCache;
    let [inf, rest] = word.split(" ");
    if (!already[inf]) {
      lex[inf] = lex[inf] || "Infinitive";
    }
    let all4 = methods16.two.transform.verb.conjugate(inf, model5);
    delete all4.FutureTense;
    Object.entries(all4).forEach((a2) => {
      if (a2[0] === "Actor" || a2[1] === "") {
        return;
      }
      if (!lex[a2[1]] && !already[a2[1]]) {
        lex[a2[1]] = a2[0];
      }
      _multi[a2[1]] = true;
      let str = a2[1] + " " + rest;
      lex[str] = lex[str] || [a2[0], "PhrasalVerb"];
    });
  },
  Multiple: (word, lex) => {
    lex[word] = ["Multiple", "Cardinal"];
    lex[word + "th"] = ["Multiple", "Ordinal"];
    lex[word + "ths"] = ["Multiple", "Fraction"];
  },
  Cardinal: (word, lex) => {
    lex[word] = ["TextValue", "Cardinal"];
  },
  Ordinal: (word, lex) => {
    lex[word] = ["TextValue", "Ordinal"];
    lex[word + "s"] = ["TextValue", "Fraction"];
  }
};

// node_modules/compromise/src/2-two/preTagger/methods/expand/index.js
var expand4 = function(words, world2) {
  const { methods: methods16, model: model5 } = world2;
  let lex = {};
  let _multi = {};
  Object.keys(words).forEach((word) => {
    let tag = words[word];
    word = word.toLowerCase().trim();
    word = word.replace(/'s\b/, "");
    let split3 = word.split(/ /);
    if (split3.length > 1) {
      _multi[split3[0]] = true;
    }
    if (byTag_default.hasOwnProperty(tag) === true) {
      byTag_default[tag](word, lex, methods16, model5);
    }
    lex[word] = lex[word] || tag;
  });
  delete lex[""];
  delete lex[null];
  delete lex[" "];
  return { lex, _multi };
};
var expand_default2 = expand4;

// node_modules/compromise/src/2-two/preTagger/methods/quickSplit.js
var splitOn = function(terms, i3) {
  const isNum = /^[0-9]+$/;
  let term = terms[i3];
  if (!term) {
    return false;
  }
  const maybeDate = /* @__PURE__ */ new Set(["may", "april", "august", "jan"]);
  if (term.normal === "like" || maybeDate.has(term.normal)) {
    return false;
  }
  if (term.tags.has("Place") || term.tags.has("Date")) {
    return false;
  }
  if (terms[i3 - 1]) {
    let lastTerm = terms[i3 - 1];
    if (lastTerm.tags.has("Date") || maybeDate.has(lastTerm.normal)) {
      return false;
    }
    if (lastTerm.tags.has("Adjective") || term.tags.has("Adjective")) {
      return false;
    }
  }
  let str = term.normal;
  if (str.length === 1 || str.length === 2 || str.length === 4) {
    if (isNum.test(str)) {
      return false;
    }
  }
  return true;
};
var quickSplit = function(document2) {
  const splitHere = /[,:;]/;
  let arr = [];
  document2.forEach((terms) => {
    let start2 = 0;
    terms.forEach((term, i3) => {
      if (splitHere.test(term.post) && splitOn(terms, i3 + 1)) {
        arr.push(terms.slice(start2, i3 + 1));
        start2 = i3 + 1;
      }
    });
    if (start2 < terms.length) {
      arr.push(terms.slice(start2, terms.length));
    }
  });
  return arr;
};
var quickSplit_default = quickSplit;

// node_modules/compromise/src/2-two/preTagger/methods/looksPlural.js
var isPlural = {
  e: [
    "mice",
    "louse",
    "antennae",
    "formulae",
    "nebulae",
    "vertebrae",
    "vitae"
  ],
  i: [
    "tia",
    "octopi",
    "viri",
    "radii",
    "nuclei",
    "fungi",
    "cacti",
    "stimuli"
  ],
  n: [
    "men"
  ],
  t: [
    "feet"
  ]
};
var exceptions4 = /* @__PURE__ */ new Set([
  "formulas",
  "koalas",
  "israelis",
  "menus"
]);
var notPlural = [
  "bus",
  "mas",
  "was",
  "las",
  "ias",
  "xas",
  "vas",
  "cis",
  "lis",
  "nis",
  "ois",
  "ris",
  "sis",
  "tis",
  "xis",
  "aus",
  "cus",
  "eus",
  "fus",
  "gus",
  "ius",
  "lus",
  "nus",
  "ous",
  "pus",
  "rus",
  "sus",
  "tus",
  "xus",
  "'s",
  "ss"
];
var looksPlural = function(str) {
  if (!str || str.length <= 3) {
    return false;
  }
  if (exceptions4.has(str)) {
    return true;
  }
  let end2 = str[str.length - 1];
  if (isPlural.hasOwnProperty(end2)) {
    return isPlural[end2].find((suff) => str.endsWith(suff));
  }
  if (end2 !== "s") {
    return false;
  }
  if (notPlural.find((suff) => str.endsWith(suff))) {
    return false;
  }
  return true;
};
var looksPlural_default = looksPlural;

// node_modules/compromise/src/2-two/preTagger/methods/index.js
var methods_default9 = {
  two: {
    quickSplit: quickSplit_default,
    expandLexicon: expand_default2,
    transform: transform_default,
    looksPlural: looksPlural_default
  }
};

// node_modules/compromise/src/2-two/preTagger/model/_expand/irregulars.js
var expandIrregulars = function(model5) {
  const { irregularPlurals } = model5.two;
  const { lexicon: lexicon4 } = model5.one;
  Object.entries(irregularPlurals).forEach((a2) => {
    lexicon4[a2[0]] = lexicon4[a2[0]] || "Singular";
    lexicon4[a2[1]] = lexicon4[a2[1]] || "Plural";
  });
  return model5;
};
var irregulars_default = expandIrregulars;

// node_modules/compromise/src/2-two/preTagger/model/_expand/models.js
var getWords = function(model5, left, right) {
  return Object.entries(model5.exceptions).reduce((h2, a2) => {
    if (left) {
      h2[a2[0]] = left;
    }
    h2[a2[1]] = right;
    return h2;
  }, {});
};
var expandModels = function(model5) {
  let { lexicon: lexicon4 } = model5.one;
  const { toPast: toPast4, toPresent: toPresent4, toGerund: toGerund4, toSuperlative: toSuperlative3, toComparative: toComparative3 } = model5.two.models;
  let res = {};
  let words = {};
  words = getWords(toPast4, "Infinitive", "PastTense");
  Object.assign(res, words);
  words = getWords(toPresent4, "Infinitive", "Verb");
  Object.assign(res, words);
  words = getWords(toGerund4, "Infinitive", "Gerund");
  Object.assign(res, words);
  words = getWords(toSuperlative3, "Adjective", "Superlative");
  Object.assign(res, words);
  words = getWords(toComparative3, "Adjective", "Comparative");
  Object.assign(res, words);
  model5.one.lexicon = Object.assign(res, lexicon4);
  return model5;
};
var models_default2 = expandModels;

// node_modules/compromise/src/2-two/preTagger/model/_expand/index.js
var tmpModel2 = {
  two: { models: models_default }
};
var switchDefaults = {
  "Adj|Gerund": "Adjective",
  "Adj|Noun": "Adjective",
  "Adj|Past": "Adjective",
  "Adj|Present": "Adjective",
  "Noun|Verb": "Singular",
  "Noun|Gerund": "Gerund",
  "Person|Noun": "Noun",
  "Person|Date": "Month",
  "Person|Verb": "FirstName",
  "Person|Place": "Person",
  "Plural|Verb": "Plural",
  "Unit|Noun": "Noun"
};
var expandLexicon = function(words, model5) {
  const world2 = { model: model5, methods: methods_default9 };
  let { lex, _multi } = methods_default9.two.expandLexicon(words, world2);
  Object.assign(model5.one.lexicon, lex);
  Object.assign(model5.one._multiCache, _multi);
  return model5;
};
var addUncountables = function(words, model5) {
  Object.keys(words).forEach((k2) => {
    if (words[k2] === "Uncountable") {
      model5.two.uncountable[k2] = true;
      words[k2] = "Uncountable";
    }
  });
  return model5;
};
var expandVerb = function(str, words, doPresent) {
  let obj = conjugate_default(str, tmpModel2);
  words[obj.PastTense] = words[obj.PastTense] || "PastTense";
  words[obj.Gerund] = words[obj.Gerund] || "Gerund";
  if (doPresent === true) {
    words[obj.PresentTense] = words[obj.PresentTense] || "PresentTense";
  }
};
var expandAdjective = function(str, words, model5) {
  let sup = toSuperlative2(str, model5);
  words[sup] = words[sup] || "Superlative";
  let comp = toComparative2(str, model5);
  words[comp] = words[comp] || "Comparative";
};
var expandNoun = function(str, words, model5) {
  let plur = toPlural_default(str, model5);
  words[plur] = words[plur] || "Plural";
};
var expandVariable = function(switchWords, model5) {
  let words = {};
  const lex = model5.one.lexicon;
  Object.keys(switchWords).forEach((w) => {
    const name = switchWords[w];
    words[w] = switchDefaults[name];
    if (name === "Noun|Verb" || name === "Person|Verb") {
      expandVerb(w, lex, false);
    }
    if (name === "Adj|Present") {
      expandVerb(w, lex, true);
      expandAdjective(w, lex, model5);
    }
    if (name === "Adj|Gerund" || name === "Noun|Gerund") {
      let inf = toInfinitive_default(w, tmpModel2, "Gerund");
      if (!lex[inf]) {
        words[inf] = "Infinitive";
      }
    }
    if (name === "Noun|Gerund" || name === "Adj|Noun" || name === "Person|Noun") {
      expandNoun(w, lex, model5);
    }
    if (name === "Adj|Past") {
      let inf = toInfinitive_default(w, tmpModel2, "PastTense");
      if (!lex[inf]) {
        words[inf] = "Infinitive";
      }
    }
  });
  model5 = expandLexicon(words, model5);
  return model5;
};
var expand5 = function(model5) {
  model5 = expandLexicon(model5.one.lexicon, model5);
  model5 = addUncountables(model5.one.lexicon, model5);
  model5 = expandVariable(model5.two.switches, model5);
  model5 = models_default2(model5);
  model5 = irregulars_default(model5);
  return model5;
};
var expand_default3 = expand5;

// node_modules/compromise/src/2-two/preTagger/model/index.js
var model4 = {
  one: {
    _multiCache: {},
    lexicon: lexicon3
  },
  two: {
    irregularPlurals: plurals_default,
    models: models_default,
    suffixPatterns: suffixes_default2,
    prefixPatterns: prefixes_default2,
    endsWith: endsWith_default,
    neighbours: neighbours_default,
    regexNormal: regex_normal_default,
    regexText: regex_text_default,
    regexNumbers: regex_numbers_default,
    switches,
    clues: clues_default,
    uncountable: {},
    orgWords: orgWords_default
  }
};
model4 = expand_default3(model4);
var model_default3 = model4;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/1st-pass/01-colons.js
var byPunctuation = function(terms, i3, model5, world2) {
  const setTag3 = world2.methods.one.setTag;
  if (i3 === 0 && terms.length >= 3) {
    const hasColon = /:/;
    let post = terms[0].post;
    if (post.match(hasColon)) {
      let nextTerm = terms[1];
      if (nextTerm.tags.has("Value") || nextTerm.tags.has("Email") || nextTerm.tags.has("PhoneNumber")) {
        return;
      }
      setTag3([terms[0]], "Expression", world2, null, `2-punct-colon''`);
    }
  }
};
var colons_default = byPunctuation;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/1st-pass/02-hyphens.js
var byHyphen = function(terms, i3, model5, world2) {
  const setTag3 = world2.methods.one.setTag;
  if (terms[i3].post === "-" && terms[i3 + 1]) {
    setTag3([terms[i3], terms[i3 + 1]], "Hyphenated", world2, null, `1-punct-hyphen''`);
  }
};
var hyphens_default = byHyphen;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/00-tagSwitch.js
var prefix4 = /^(under|over|mis|re|un|dis|semi)-?/;
var tagSwitch = function(terms, i3, model5) {
  const switches2 = model5.two.switches;
  let term = terms[i3];
  if (switches2.hasOwnProperty(term.normal)) {
    term.switch = switches2[term.normal];
    return;
  }
  if (prefix4.test(term.normal)) {
    let stem = term.normal.replace(prefix4, "");
    if (stem.length > 3 && switches2.hasOwnProperty(stem)) {
      term.switch = switches2[stem];
    }
  }
};
var tagSwitch_default = tagSwitch;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/_fastTag.js
var log2 = (term, tag, reason = "") => {
  const yellow = (str) => "\x1B[33m\x1B[3m" + str + "\x1B[0m";
  const i3 = (str) => "\x1B[3m" + str + "\x1B[0m";
  let word = term.text || "[" + term.implicit + "]";
  if (typeof tag !== "string" && tag.length > 2) {
    tag = tag.slice(0, 2).join(", #") + " +";
  }
  tag = typeof tag !== "string" ? tag.join(", #") : tag;
  console.log(` ${yellow(word).padEnd(24)} \x1B[32m\u2192\x1B[0m #${tag.padEnd(22)}  ${i3(reason)}`);
};
var setTag2 = function(term, tag, reason) {
  if (!tag || tag.length === 0) {
    return;
  }
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2 && env2.DEBUG_TAGS) {
    log2(term, tag, reason);
  }
  term.tags = term.tags || /* @__PURE__ */ new Set();
  if (typeof tag === "string") {
    term.tags.add(tag);
  } else {
    tag.forEach((tg) => term.tags.add(tg));
  }
};
var fastTag_default = setTag2;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/_fillTags.js
var uncountable = [
  "Acronym",
  "Abbreviation",
  "ProperNoun",
  "Uncountable",
  "Possessive",
  "Pronoun",
  "Activity",
  "Honorific"
];
var setPluralSingular = function(term) {
  if (!term.tags.has("Noun") || term.tags.has("Plural") || term.tags.has("Singular") || term.tags.has("Date")) {
    return;
  }
  if (uncountable.find((tag) => term.tags.has(tag))) {
    return;
  }
  if (looksPlural_default(term.normal)) {
    fastTag_default(term, "Plural", "3-plural-guess");
  } else {
    fastTag_default(term, "Singular", "3-singular-guess");
  }
};
var setTense = function(term) {
  let tags = term.tags;
  if (tags.has("Verb") && tags.size === 1) {
    let guess = getTense_default(term.normal);
    if (guess) {
      fastTag_default(term, guess, "3-verb-tense-guess");
    }
  }
};
var fillTags = function(terms, i3, model5) {
  let term = terms[i3];
  let tags = Array.from(term.tags);
  for (let k2 = 0; k2 < tags.length; k2 += 1) {
    if (model5.one.tagSet[tags[k2]]) {
      let toAdd = model5.one.tagSet[tags[k2]].parents;
      fastTag_default(term, toAdd, ` -inferred by #${tags[k2]}`);
    }
  }
  setPluralSingular(term);
  setTense(term, model5);
};
var fillTags_default = fillTags;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/01-case.js
var titleCase3 = /^\p{Lu}[\p{Ll}'’]/u;
var hasNumber = /[0-9]/;
var notProper = ["Date", "Month", "WeekDay", "Unit", "Expression"];
var hasIVX = /[IVX]/;
var romanNumeral = /^[IVXLCDM]{2,}$/;
var romanNumValid = /^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/;
var nope = {
  li: true,
  dc: true,
  md: true,
  dm: true,
  ml: true
};
var checkCase = function(terms, i3, model5) {
  let term = terms[i3];
  term.index = term.index || [0, 0];
  let index3 = term.index[1];
  let str = term.text || "";
  if (index3 !== 0 && titleCase3.test(str) === true && hasNumber.test(str) === false) {
    if (notProper.find((tag) => term.tags.has(tag))) {
      return null;
    }
    if (term.pre.match(/["']$/)) {
      return null;
    }
    fillTags_default(terms, i3, model5);
    if (!term.tags.has("Noun")) {
      term.tags.clear();
    }
    fastTag_default(term, "ProperNoun", "2-titlecase");
    return true;
  }
  if (str.length >= 2 && romanNumeral.test(str) && hasIVX.test(str) && romanNumValid.test(str) && !nope[term.normal]) {
    fastTag_default(term, "RomanNumeral", "2-xvii");
    return true;
  }
  return null;
};
var case_default2 = checkCase;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/02-suffix.js
var suffixLoop2 = function(str = "", suffixes6 = []) {
  const len = str.length;
  let max3 = 7;
  if (len <= max3) {
    max3 = len - 1;
  }
  for (let i3 = max3; i3 > 1; i3 -= 1) {
    let suffix = str.substring(len - i3, len);
    if (suffixes6[suffix.length].hasOwnProperty(suffix) === true) {
      let tag = suffixes6[suffix.length][suffix];
      return tag;
    }
  }
  return null;
};
var tagBySuffix = function(terms, i3, model5) {
  let term = terms[i3];
  if (term.tags.size === 0) {
    let tag = suffixLoop2(term.normal, model5.two.suffixPatterns);
    if (tag !== null) {
      fastTag_default(term, tag, "2-suffix");
      term.confidence = 0.7;
      return true;
    }
    if (term.implicit) {
      tag = suffixLoop2(term.implicit, model5.two.suffixPatterns);
      if (tag !== null) {
        fastTag_default(term, tag, "2-implicit-suffix");
        term.confidence = 0.7;
        return true;
      }
    }
  }
  return null;
};
var suffix_default = tagBySuffix;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/03-regex.js
var hasApostrophe = /['‘’‛‵′`´]/;
var doRegs = function(str, regs) {
  for (let i3 = 0; i3 < regs.length; i3 += 1) {
    if (regs[i3][0].test(str) === true) {
      return regs[i3];
    }
  }
  return null;
};
var doEndsWith = function(str = "", byEnd3) {
  let char = str[str.length - 1];
  if (byEnd3.hasOwnProperty(char) === true) {
    let regs = byEnd3[char] || [];
    for (let r2 = 0; r2 < regs.length; r2 += 1) {
      if (regs[r2][0].test(str) === true) {
        return regs[r2];
      }
    }
  }
  return null;
};
var checkRegex = function(terms, i3, model5, world2) {
  const setTag3 = world2.methods.one.setTag;
  let { regexText, regexNormal, regexNumbers, endsWith } = model5.two;
  let term = terms[i3];
  let normal = term.machine || term.normal;
  let text = term.text;
  if (hasApostrophe.test(term.post) && !hasApostrophe.test(term.pre)) {
    text += term.post.trim();
  }
  let arr = doRegs(text, regexText) || doRegs(normal, regexNormal);
  if (!arr && /[0-9]/.test(normal)) {
    arr = doRegs(normal, regexNumbers);
  }
  if (!arr && term.tags.size === 0) {
    arr = doEndsWith(normal, endsWith);
  }
  if (arr) {
    setTag3([term], arr[1], world2, null, `2-regex-'${arr[2] || arr[0]}'`);
    term.confidence = 0.6;
    return true;
  }
  return null;
};
var regex_default = checkRegex;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/04-prefix.js
var prefixLoop = function(str = "", prefixes2 = []) {
  const len = str.length;
  let max3 = 7;
  if (max3 > len - 3) {
    max3 = len - 3;
  }
  for (let i3 = max3; i3 > 2; i3 -= 1) {
    let prefix6 = str.substring(0, i3);
    if (prefixes2[prefix6.length].hasOwnProperty(prefix6) === true) {
      let tag = prefixes2[prefix6.length][prefix6];
      return tag;
    }
  }
  return null;
};
var checkPrefix = function(terms, i3, model5) {
  let term = terms[i3];
  if (term.tags.size === 0) {
    let tag = prefixLoop(term.normal, model5.two.prefixPatterns);
    if (tag !== null) {
      fastTag_default(term, tag, "2-prefix");
      term.confidence = 0.5;
      return true;
    }
  }
  return null;
};
var prefix_default = checkPrefix;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/05-year.js
var min = 1400;
var max2 = 2100;
var dateWords = /* @__PURE__ */ new Set([
  "in",
  "on",
  "by",
  "until",
  "for",
  "to",
  "during",
  "throughout",
  "through",
  "within",
  "before",
  "after",
  "of",
  "this",
  "next",
  "last",
  "circa",
  "around",
  "post",
  "pre",
  "budget",
  "classic",
  "plan",
  "may"
]);
var seemsGood = function(term) {
  if (!term) {
    return false;
  }
  let str = term.normal || term.implicit;
  if (dateWords.has(str)) {
    return true;
  }
  if (term.tags.has("Date") || term.tags.has("Month") || term.tags.has("WeekDay") || term.tags.has("Year")) {
    return true;
  }
  if (term.tags.has("ProperNoun")) {
    return true;
  }
  return false;
};
var seemsOkay = function(term) {
  if (!term) {
    return false;
  }
  if (term.tags.has("Ordinal")) {
    return true;
  }
  if (term.tags.has("Cardinal") && term.normal.length < 3) {
    return true;
  }
  if (term.normal === "is" || term.normal === "was") {
    return true;
  }
  return false;
};
var seemsFine = function(term) {
  return term && (term.tags.has("Date") || term.tags.has("Month") || term.tags.has("WeekDay") || term.tags.has("Year"));
};
var tagYear = function(terms, i3) {
  const term = terms[i3];
  if (term.tags.has("NumericValue") && term.tags.has("Cardinal") && term.normal.length === 4) {
    let num = Number(term.normal);
    if (num && !isNaN(num)) {
      if (num > min && num < max2) {
        let lastTerm = terms[i3 - 1];
        let nextTerm = terms[i3 + 1];
        if (seemsGood(lastTerm) || seemsGood(nextTerm)) {
          return fastTag_default(term, "Year", "2-tagYear");
        }
        if (num >= 1920 && num < 2025) {
          if (seemsOkay(lastTerm) || seemsOkay(nextTerm)) {
            return fastTag_default(term, "Year", "2-tagYear-close");
          }
          if (seemsFine(terms[i3 - 2]) || seemsFine(terms[i3 + 2])) {
            return fastTag_default(term, "Year", "2-tagYear-far");
          }
          if (lastTerm && (lastTerm.tags.has("Determiner") || lastTerm.tags.has("Possessive"))) {
            if (nextTerm && nextTerm.tags.has("Noun") && !nextTerm.tags.has("Plural")) {
              return fastTag_default(term, "Year", "2-tagYear-noun");
            }
          }
        }
      }
    }
  }
  return null;
};
var year_default = tagYear;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/06-verb-type.js
var verbType = function(terms, i3, model5, world2) {
  const setTag3 = world2.methods.one.setTag;
  const term = terms[i3];
  const types = ["PastTense", "PresentTense", "Auxiliary", "Modal", "Particle"];
  if (term.tags.has("Verb")) {
    let type = types.find((typ) => term.tags.has(typ));
    if (!type) {
      setTag3([term], "Infinitive", world2, null, `2-verb-type''`);
    }
  }
};
var verb_type_default = verbType;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/01-acronym.js
var oneLetterAcronym2 = /^[A-Z]('s|,)?$/;
var isUpperCase = /^[A-Z-]+$/;
var upperThenS = /^[A-Z]+s$/;
var periodAcronym2 = /([A-Z]\.)+[A-Z]?,?$/;
var noPeriodAcronym2 = /[A-Z]{2,}('s|,)?$/;
var lowerCaseAcronym2 = /([a-z]\.)+[a-z]\.?$/;
var oneLetterWord = {
  I: true,
  A: true
};
var places = {
  la: true,
  ny: true,
  us: true,
  dc: true,
  gb: true
};
var isNoPeriodAcronym = function(term, model5) {
  let str = term.text;
  if (isUpperCase.test(str) === false) {
    if (str.length > 3 && upperThenS.test(str) === true) {
      str = str.replace(/s$/, "");
    } else {
      return false;
    }
  }
  if (str.length > 5) {
    return false;
  }
  if (oneLetterWord.hasOwnProperty(str)) {
    return false;
  }
  if (model5.one.lexicon.hasOwnProperty(term.normal)) {
    return false;
  }
  if (periodAcronym2.test(str) === true) {
    return true;
  }
  if (lowerCaseAcronym2.test(str) === true) {
    return true;
  }
  if (oneLetterAcronym2.test(str) === true) {
    return true;
  }
  if (noPeriodAcronym2.test(str) === true) {
    return true;
  }
  return false;
};
var isAcronym3 = function(terms, i3, model5) {
  let term = terms[i3];
  if (term.tags.has("RomanNumeral") || term.tags.has("Acronym")) {
    return null;
  }
  if (isNoPeriodAcronym(term, model5)) {
    term.tags.clear();
    fastTag_default(term, ["Acronym", "Noun"], "3-no-period-acronym");
    if (places[term.normal] === true) {
      fastTag_default(term, "Place", "3-place-acronym");
    }
    if (upperThenS.test(term.text) === true) {
      fastTag_default(term, "Plural", "3-plural-acronym");
    }
    return true;
  }
  if (!oneLetterWord.hasOwnProperty(term.text) && oneLetterAcronym2.test(term.text)) {
    term.tags.clear();
    fastTag_default(term, ["Acronym", "Noun"], "3-one-letter-acronym");
    return true;
  }
  if (term.tags.has("Organization") && term.text.length <= 3) {
    fastTag_default(term, "Acronym", "3-org-acronym");
    return true;
  }
  if (term.tags.has("Organization") && isUpperCase.test(term.text) && term.text.length <= 6) {
    fastTag_default(term, "Acronym", "3-titlecase-acronym");
    return true;
  }
  return null;
};
var acronym_default = isAcronym3;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/02-neighbours.js
var lookAtWord = function(term, words) {
  if (!term) {
    return null;
  }
  let found = words.find((a2) => term.normal === a2[0]);
  if (found) {
    return found[1];
  }
  return null;
};
var lookAtTag = function(term, tags) {
  if (!term) {
    return null;
  }
  let found = tags.find((a2) => term.tags.has(a2[0]));
  if (found) {
    return found[1];
  }
  return null;
};
var neighbours = function(terms, i3, model5) {
  const { leftTags, leftWords, rightWords, rightTags } = model5.two.neighbours;
  let term = terms[i3];
  if (term.tags.size === 0) {
    let tag = null;
    tag = tag || lookAtWord(terms[i3 - 1], leftWords);
    tag = tag || lookAtWord(terms[i3 + 1], rightWords);
    tag = tag || lookAtTag(terms[i3 - 1], leftTags);
    tag = tag || lookAtTag(terms[i3 + 1], rightTags);
    if (tag) {
      fastTag_default(term, tag, "3-[neighbour]");
      fillTags_default(terms, i3, model5);
      terms[i3].confidence = 0.2;
      return true;
    }
  }
  return null;
};
var neighbours_default2 = neighbours;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/03-orgWords.js
var isTitleCase2 = (str) => /^\p{Lu}[\p{Ll}'’]/u.test(str);
var isOrg = function(term, i3, yelling) {
  if (!term) {
    return false;
  }
  if (term.tags.has("FirstName") || term.tags.has("Place")) {
    return false;
  }
  if (term.tags.has("ProperNoun") || term.tags.has("Organization") || term.tags.has("Acronym")) {
    return true;
  }
  if (!yelling && isTitleCase2(term.text)) {
    if (i3 === 0) {
      return term.tags.has("Singular");
    }
    return true;
  }
  return false;
};
var tagOrgs = function(terms, i3, world2, yelling) {
  const orgWords = world2.model.two.orgWords;
  const setTag3 = world2.methods.one.setTag;
  let term = terms[i3];
  let str = term.machine || term.normal;
  if (orgWords[str] === true && isOrg(terms[i3 - 1], i3 - 1, yelling)) {
    setTag3([terms[i3]], "Organization", world2, null, "3-[org-word]");
    for (let t2 = i3; t2 >= 0; t2 -= 1) {
      if (isOrg(terms[t2], t2, yelling)) {
        setTag3([terms[t2]], "Organization", world2, null, "3-[org-word]");
      } else {
        break;
      }
    }
  }
  return null;
};
var orgWords_default2 = tagOrgs;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/04-fallback.js
var nounFallback = function(terms, i3, model5) {
  let isEmpty = false;
  let tags = terms[i3].tags;
  if (tags.size === 0) {
    isEmpty = true;
  } else if (tags.size === 1) {
    if (tags.has("Hyphenated") || tags.has("HashTag") || tags.has("Prefix")) {
      isEmpty = true;
    }
  }
  if (isEmpty) {
    fastTag_default(terms[i3], "Noun", "3-[fallback]");
    fillTags_default(terms, i3, model5);
    terms[i3].confidence = 0.1;
  }
};
var fallback_default = nounFallback;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/_adhoc.js
var isTitleCase3 = /^[A-Z][a-z]/;
var isCapital = (terms, i3) => {
  if (terms[i3].tags.has("ProperNoun") && isTitleCase3.test(terms[i3].text)) {
    return "Noun";
  }
  return null;
};
var isAloneVerb = (terms, i3, tag) => {
  if (i3 === 0 && !terms[1]) {
    return tag;
  }
  return null;
};
var isEndNoun = function(terms, i3) {
  if (!terms[i3 + 1] && terms[i3 - 1] && terms[i3 - 1].tags.has("Determiner")) {
    return "Noun";
  }
  return null;
};
var isStart = function(terms, i3, tag) {
  if (i3 === 0 && terms.length > 3) {
    return tag;
  }
  return null;
};
var adhoc = {
  "Adj|Gerund": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Adj|Noun": (terms, i3) => {
    return isCapital(terms, i3) || isEndNoun(terms, i3);
  },
  "Adj|Past": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Adj|Present": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Noun|Gerund": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Noun|Verb": (terms, i3) => {
    return isCapital(terms, i3) || isAloneVerb(terms, i3, "Infinitive");
  },
  "Plural|Verb": (terms, i3) => {
    return isCapital(terms, i3) || isAloneVerb(terms, i3, "PresentTense") || isStart(terms, i3, "Plural");
  },
  "Person|Noun": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Person|Verb": (terms, i3) => {
    if (i3 !== 0) {
      return isCapital(terms, i3);
    }
    return null;
  }
};
var adhoc_default = adhoc;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/06-switches.js
var env = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
var prefix5 = /^(under|over|mis|re|un|dis|semi)-?/;
var checkWord = (term, obj) => {
  if (!term || !obj) {
    return null;
  }
  let str = term.normal || term.implicit;
  let found = null;
  if (obj.hasOwnProperty(str)) {
    found = obj[str];
  }
  if (found && env.DEBUG_TAGS) {
    console.log(`
  \x1B[2m\x1B[3m     \u2193 - '${str}' \x1B[0m`);
  }
  return found;
};
var checkTag = (term, obj = {}, tagSet) => {
  if (!term || !obj) {
    return null;
  }
  let tags = Array.from(term.tags).sort((a2, b) => {
    let numA = tagSet[a2] ? tagSet[a2].parents.length : 0;
    let numB = tagSet[b] ? tagSet[b].parents.length : 0;
    return numA > numB ? -1 : 1;
  });
  let found = tags.find((tag) => obj[tag]);
  if (found && env.DEBUG_TAGS) {
    console.log(`  \x1B[2m\x1B[3m      \u2193 - '${term.normal || term.implicit}' (#${found})  \x1B[0m`);
  }
  found = obj[found];
  return found;
};
var pickTag = function(terms, i3, clues4, model5) {
  if (!clues4) {
    return null;
  }
  const tagSet = model5.one.tagSet;
  let tag = checkWord(terms[i3 + 1], clues4.afterWords);
  tag = tag || checkWord(terms[i3 - 1], clues4.beforeWords);
  tag = tag || checkTag(terms[i3 - 1], clues4.beforeTags, tagSet);
  tag = tag || checkTag(terms[i3 + 1], clues4.afterTags, tagSet);
  return tag;
};
var doSwitches = function(terms, i3, world2) {
  const model5 = world2.model;
  const setTag3 = world2.methods.one.setTag;
  const { switches: switches2, clues: clues4 } = model5.two;
  const term = terms[i3];
  let str = term.normal || term.implicit || "";
  if (prefix5.test(str) && !switches2[str]) {
    str = str.replace(prefix5, "");
  }
  if (term.switch) {
    let form = term.switch;
    if (term.tags.has("Acronym") || term.tags.has("PhrasalVerb")) {
      return;
    }
    let tag = pickTag(terms, i3, clues4[form], model5);
    if (adhoc_default[form]) {
      tag = adhoc_default[form](terms, i3) || tag;
    }
    if (tag) {
      setTag3([term], tag, world2, null, `3-[switch] (${form})`);
      fillTags_default(terms, i3, model5);
    } else if (env.DEBUG_TAGS) {
      console.log(`
 -> X  - '${str}'  : (${form})  `);
    }
  }
};
var switches_default = doSwitches;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/07-imperative.js
var beside = {
  there: true,
  this: true,
  it: true,
  him: true,
  her: true,
  us: true
};
var imperative = function(terms, world2) {
  const setTag3 = world2.methods.one.setTag;
  const multiWords = world2.model.one._multiCache || {};
  let t2 = terms[0];
  let isRight = t2.switch === "Noun|Verb" || t2.tags.has("Infinitive");
  if (isRight && terms.length >= 2) {
    if (terms.length < 4 && !beside[terms[1].normal]) {
      return;
    }
    if (!t2.tags.has("PhrasalVerb") && multiWords.hasOwnProperty(t2.normal)) {
      return;
    }
    let nextNoun = terms[1].tags.has("Noun") || terms[1].tags.has("Determiner");
    if (nextNoun) {
      let soonVerb = terms.slice(1, 3).some((term) => term.tags.has("Verb"));
      if (!soonVerb || t2.tags.has("#PhrasalVerb")) {
        setTag3([t2], "Imperative", world2, null, "3-[imperative]");
      }
    }
  }
};
var imperative_default = imperative;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/index.js
var ignoreCase = function(terms) {
  if (terms.filter((t2) => !t2.tags.has("ProperNoun")).length <= 3) {
    return false;
  }
  const lowerCase = /^[a-z]/;
  return terms.every((t2) => !lowerCase.test(t2.text));
};
var firstPass = function(docs, model5, world2) {
  docs.forEach((terms) => {
    colons_default(terms, 0, model5, world2);
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
    }
  });
};
var secondPass = function(terms, model5, world2, isYelling) {
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    tagSwitch_default(terms, i3, model5);
    if (isYelling === false) {
      case_default2(terms, i3, model5);
    }
    suffix_default(terms, i3, model5);
    regex_default(terms, i3, model5, world2);
    prefix_default(terms, i3, model5);
    year_default(terms, i3, model5);
  }
};
var thirdPass = function(terms, model5, world2, isYelling) {
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    let found = acronym_default(terms, i3, model5);
    fillTags_default(terms, i3, model5);
    found = found || neighbours_default2(terms, i3, model5);
    found = found || fallback_default(terms, i3, model5);
  }
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    orgWords_default2(terms, i3, world2, isYelling);
    switches_default(terms, i3, world2);
    verb_type_default(terms, i3, model5, world2);
    hyphens_default(terms, i3, model5, world2);
  }
  imperative_default(terms, world2);
};
var preTagger = function(view) {
  const { methods: methods16, model: model5, world: world2 } = view;
  let docs = view.docs;
  firstPass(docs, model5, world2);
  let document2 = methods16.two.quickSplit(docs);
  for (let n3 = 0; n3 < document2.length; n3 += 1) {
    let terms = document2[n3];
    const isYelling = ignoreCase(terms);
    secondPass(terms, model5, world2, isYelling);
    thirdPass(terms, model5, world2, isYelling);
  }
  return document2;
};
var tagger_default2 = preTagger;

// node_modules/compromise/src/2-two/preTagger/compute/root.js
var toRoot = {
  "Possessive": (term) => {
    let str = term.machine || term.normal || term.text;
    str = str.replace(/'s$/, "");
    return str;
  },
  "Plural": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.noun.toSingular(str, world2.model);
  },
  "Copula": () => {
    return "is";
  },
  "PastTense": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.verb.toInfinitive(str, world2.model, "PastTense");
  },
  "Gerund": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.verb.toInfinitive(str, world2.model, "Gerund");
  },
  "PresentTense": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    if (term.tags.has("Infinitive")) {
      return str;
    }
    return world2.methods.two.transform.verb.toInfinitive(str, world2.model, "PresentTense");
  },
  "Comparative": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.adjective.fromComparative(str, world2.model);
  },
  "Superlative": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.adjective.fromSuperlative(str, world2.model);
  },
  "Adverb": (term, world2) => {
    const { fromAdverb } = world2.methods.two.transform.adjective;
    let str = term.machine || term.normal || term.text;
    return fromAdverb(str);
  }
};
var getRoot = function(view) {
  const world2 = view.world;
  const keys = Object.keys(toRoot);
  view.docs.forEach((terms) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      const term = terms[i3];
      for (let k2 = 0; k2 < keys.length; k2 += 1) {
        if (term.tags.has(keys[k2])) {
          const fn = toRoot[keys[k2]];
          let root = fn(term, world2);
          if (term.normal !== root) {
            term.root = root;
          }
          break;
        }
      }
    }
  });
};
var root_default = getRoot;

// node_modules/compromise/src/2-two/preTagger/compute/penn.js
var mapping = {
  "Adverb": "RB",
  "Comparative": "JJR",
  "Superlative": "JJS",
  "Adjective": "JJ",
  "TO": "Conjunction",
  "Modal": "MD",
  "Auxiliary": "MD",
  "Gerund": "VBG",
  "PastTense": "VBD",
  "Participle": "VBN",
  "PresentTense": "VBZ",
  "Infinitive": "VB",
  "Particle": "RP",
  "Verb": "VB",
  "Pronoun": "PRP",
  "Cardinal": "CD",
  "Conjunction": "CC",
  "Determiner": "DT",
  "Preposition": "IN",
  "QuestionWord": "WP",
  "Expression": "UH",
  "Possessive": "POS",
  "ProperNoun": "NNP",
  "Person": "NNP",
  "Place": "NNP",
  "Organization": "NNP",
  "Singular": "NNP",
  "Plural": "NNS",
  "Noun": "NN",
  "There": "EX"
};
var toPenn = function(term) {
  if (term.tags.has("ProperNoun") && term.tags.has("Plural")) {
    return "NNPS";
  }
  if (term.tags.has("Possessive") && term.tags.has("Pronoun")) {
    return "PRP$";
  }
  if (term.normal === "there") {
    return "EX";
  }
  if (term.normal === "to") {
    return "TO";
  }
  let arr = term.tagRank || [];
  for (let i3 = 0; i3 < arr.length; i3 += 1) {
    if (mapping.hasOwnProperty(arr[i3])) {
      return mapping[arr[i3]];
    }
  }
  return null;
};
var pennTag = function(view) {
  view.compute("tagRank");
  view.docs.forEach((terms) => {
    terms.forEach((term) => {
      term.penn = toPenn(term);
    });
  });
};
var penn_default = pennTag;

// node_modules/compromise/src/2-two/preTagger/compute/index.js
var compute_default8 = { preTagger: tagger_default2, root: root_default, penn: penn_default };

// node_modules/compromise/src/2-two/preTagger/tagSet/nouns.js
var entity = ["Person", "Place", "Organization"];
var nouns_default3 = {
  Noun: {
    not: ["Verb", "Adjective", "Adverb", "Value", "Determiner"]
  },
  Singular: {
    is: "Noun",
    not: ["Plural", "Uncountable"]
  },
  ProperNoun: {
    is: "Noun"
  },
  Person: {
    is: "Singular",
    also: ["ProperNoun"],
    not: ["Place", "Organization", "Date"]
  },
  FirstName: {
    is: "Person"
  },
  MaleName: {
    is: "FirstName",
    not: ["FemaleName", "LastName"]
  },
  FemaleName: {
    is: "FirstName",
    not: ["MaleName", "LastName"]
  },
  LastName: {
    is: "Person",
    not: ["FirstName"]
  },
  Honorific: {
    is: "Person",
    not: ["FirstName", "LastName", "Value"]
  },
  Place: {
    is: "Singular",
    not: ["Person", "Organization"]
  },
  Country: {
    is: "Place",
    also: ["ProperNoun"],
    not: ["City"]
  },
  City: {
    is: "Place",
    also: ["ProperNoun"],
    not: ["Country"]
  },
  Region: {
    is: "Place",
    also: ["ProperNoun"]
  },
  Address: {},
  Organization: {
    is: "ProperNoun",
    not: ["Person", "Place"]
  },
  SportsTeam: {
    is: "Organization"
  },
  School: {
    is: "Organization"
  },
  Company: {
    is: "Organization"
  },
  Plural: {
    is: "Noun",
    not: ["Singular", "Uncountable"]
  },
  Uncountable: {
    is: "Noun"
  },
  Pronoun: {
    is: "Noun",
    not: entity
  },
  Actor: {
    is: "Noun",
    not: entity
  },
  Activity: {
    is: "Noun",
    not: ["Person", "Place"]
  },
  Unit: {
    is: "Noun",
    not: entity
  },
  Demonym: {
    is: "Noun",
    also: ["ProperNoun"],
    not: entity
  },
  Possessive: {
    is: "Noun"
  },
  Reflexive: {
    is: "Pronoun"
  }
};

// node_modules/compromise/src/2-two/preTagger/tagSet/verbs.js
var verbs_default2 = {
  Verb: {
    not: ["Noun", "Adjective", "Adverb", "Value", "Expression"]
  },
  PresentTense: {
    is: "Verb",
    not: ["PastTense"]
  },
  Infinitive: {
    is: "PresentTense",
    not: ["Gerund"]
  },
  Imperative: {
    is: "Infinitive",
    not: ["PastTense", "Gerund", "Copula"]
  },
  Gerund: {
    is: "PresentTense",
    not: ["Copula"]
  },
  PastTense: {
    is: "Verb",
    not: ["PresentTense", "Gerund"]
  },
  Copula: {
    is: "Verb"
  },
  Modal: {
    is: "Verb",
    not: ["Infinitive"]
  },
  Participle: {
    is: "PastTense"
  },
  Auxiliary: {
    is: "Verb",
    not: ["PastTense", "PresentTense", "Gerund", "Conjunction"]
  },
  PhrasalVerb: {
    is: "Verb"
  },
  Particle: {
    is: "PhrasalVerb",
    not: ["PastTense", "PresentTense", "Copula", "Gerund"]
  },
  Passive: {
    is: "Verb"
  }
};

// node_modules/compromise/src/2-two/preTagger/tagSet/values.js
var values_default = {
  Value: {
    not: ["Verb", "Adjective", "Adverb"]
  },
  Ordinal: {
    is: "Value",
    not: ["Cardinal"]
  },
  Cardinal: {
    is: "Value",
    not: ["Ordinal"]
  },
  Fraction: {
    is: "Value",
    not: ["Noun"]
  },
  Multiple: {
    is: "TextValue"
  },
  RomanNumeral: {
    is: "Cardinal",
    not: ["TextValue"]
  },
  TextValue: {
    is: "Value",
    not: ["NumericValue"]
  },
  NumericValue: {
    is: "Value",
    not: ["TextValue"]
  },
  Money: {
    is: "Cardinal"
  },
  Percent: {
    is: "Value"
  }
};

// node_modules/compromise/src/2-two/preTagger/tagSet/dates.js
var dates_default = {
  Date: {
    not: ["Verb", "Adverb", "Adjective"]
  },
  Month: {
    is: "Date",
    also: ["Noun"],
    not: ["Year", "WeekDay", "Time"]
  },
  WeekDay: {
    is: "Date",
    also: ["Noun"]
  },
  Year: {
    is: "Date",
    not: ["RomanNumeral"]
  },
  FinancialQuarter: {
    is: "Date",
    not: "Fraction"
  },
  Holiday: {
    is: "Date",
    also: ["Noun"]
  },
  Season: {
    is: "Date"
  },
  Timezone: {
    is: "Date",
    also: ["Noun"],
    not: ["ProperNoun"]
  },
  Time: {
    is: "Date",
    not: ["AtMention"]
  },
  Duration: {
    is: "Date",
    also: ["Noun"]
  }
};

// node_modules/compromise/src/2-two/preTagger/tagSet/misc.js
var anything = ["Noun", "Verb", "Adjective", "Adverb", "Value", "QuestionWord"];
var misc_default3 = {
  Adjective: {
    not: ["Noun", "Verb", "Adverb", "Value"]
  },
  Comparable: {
    is: "Adjective"
  },
  Comparative: {
    is: "Adjective"
  },
  Superlative: {
    is: "Adjective",
    not: ["Comparative"]
  },
  NumberRange: {},
  Adverb: {
    not: ["Noun", "Verb", "Adjective", "Value"]
  },
  Determiner: {
    not: ["Noun", "Verb", "Adjective", "Adverb", "QuestionWord", "Conjunction"]
  },
  Conjunction: {
    not: anything
  },
  Preposition: {
    not: ["Noun", "Verb", "Adjective", "Adverb", "QuestionWord", "Determiner"]
  },
  QuestionWord: {
    not: ["Determiner"]
  },
  Currency: {
    is: "Noun"
  },
  Expression: {
    not: ["Noun", "Adjective", "Verb", "Adverb"]
  },
  Abbreviation: {},
  Url: {
    not: ["HashTag", "PhoneNumber", "Verb", "Adjective", "Value", "AtMention", "Email"]
  },
  PhoneNumber: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention", "Email"]
  },
  HashTag: {},
  AtMention: {
    is: "Noun",
    not: ["HashTag", "Email"]
  },
  Emoji: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention"]
  },
  Emoticon: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention"]
  },
  Email: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention"]
  },
  Acronym: {
    not: ["Plural", "RomanNumeral"]
  },
  Negative: {
    not: ["Noun", "Adjective", "Value", "Expression"]
  },
  Condition: {
    not: ["Verb", "Adjective", "Noun", "Value"]
  },
  There: {
    not: ["Verb", "Adjective", "Noun", "Value", "Conjunction", "Preposition"]
  },
  Prefix: {
    not: ["Abbreviation", "Acronym", "ProperNoun"]
  },
  Hyphenated: {}
};

// node_modules/compromise/src/2-two/preTagger/tagSet/index.js
var allTags = Object.assign({}, nouns_default3, verbs_default2, values_default, dates_default, misc_default3);
var tagSet_default = allTags;

// node_modules/compromise/src/2-two/preTagger/plugin.js
var plugin_default13 = {
  compute: compute_default8,
  methods: methods_default9,
  model: model_default3,
  tags: tagSet_default,
  hooks: ["preTagger"]
};

// node_modules/compromise/src/2-two/contraction-two/api/contract.js
var postPunct = /[,)"';:\-–—.…]/;
var setContraction = function(m3, suffix) {
  if (!m3.found) {
    return;
  }
  let terms = m3.termList();
  for (let i3 = 0; i3 < terms.length - 1; i3++) {
    const t2 = terms[i3];
    if (postPunct.test(t2.post)) {
      return;
    }
  }
  terms[0].implicit = terms[0].normal;
  terms[0].text += suffix;
  terms[0].normal += suffix;
  terms.slice(1).forEach((t2) => {
    t2.implicit = t2.normal;
    t2.text = "";
    t2.normal = "";
  });
  for (let i3 = 0; i3 < terms.length - 1; i3++) {
    terms[i3].post = terms[i3].post.replace(/ /, "");
  }
};
var contract = function() {
  let doc = this.not("@hasContraction");
  let m3 = doc.match("(we|they|you) are");
  setContraction(m3, `'re`);
  m3 = doc.match("(he|she|they|it|we|you) will");
  setContraction(m3, `'ll`);
  m3 = doc.match("(he|she|they|it|we) is");
  setContraction(m3, `'s`);
  m3 = doc.match("#Person is");
  setContraction(m3, `'s`);
  m3 = doc.match("#Person would");
  setContraction(m3, `'d`);
  m3 = doc.match("(is|was|had|would|should|could|do|does|have|has|can) not");
  setContraction(m3, `n't`);
  m3 = doc.match("(i|we|they) have");
  setContraction(m3, `'ve`);
  m3 = doc.match("(would|should|could) have");
  setContraction(m3, `'ve`);
  m3 = doc.match("i am");
  setContraction(m3, `'m`);
  m3 = doc.match("going to");
  return this;
};
var contract_default = contract;

// node_modules/compromise/src/2-two/contraction-two/api/index.js
var titleCase4 = /^\p{Lu}[\p{Ll}'’]/u;
var toTitleCase2 = function(str = "") {
  str = str.replace(/^ *[a-z\u00C0-\u00FF]/, (x) => x.toUpperCase());
  return str;
};
var api3 = function(View2) {
  class Contractions extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Contraction";
    }
    expand() {
      this.docs.forEach((terms) => {
        let isTitleCase4 = titleCase4.test(terms[0].text);
        terms.forEach((t2, i3) => {
          t2.text = t2.implicit;
          delete t2.implicit;
          if (i3 < terms.length - 1 && t2.post === "") {
            t2.post += " ";
          }
          t2.dirty = true;
        });
        if (isTitleCase4) {
          terms[0].text = toTitleCase2(terms[0].text);
        }
      });
      this.compute("normal");
      return this;
    }
  }
  View2.prototype.contractions = function() {
    let m3 = this.match("@hasContraction+");
    return new Contractions(this.document, m3.pointer);
  };
  View2.prototype.contract = contract_default;
};
var api_default10 = api3;

// node_modules/compromise/src/2-two/contraction-two/compute/_splice.js
var insertContraction2 = function(document2, point, words) {
  let [n3, w] = point;
  if (!words || words.length === 0) {
    return;
  }
  words = words.map((word, i3) => {
    word.implicit = word.text;
    word.machine = word.text;
    word.pre = "";
    word.post = "";
    word.text = "";
    word.normal = "";
    word.index = [n3, w + i3];
    return word;
  });
  if (words[0]) {
    words[0].pre = document2[n3][w].pre;
    words[words.length - 1].post = document2[n3][w].post;
    words[0].text = document2[n3][w].text;
    words[0].normal = document2[n3][w].normal;
  }
  document2[n3].splice(w, 1, ...words);
};
var splice_default2 = insertContraction2;

// node_modules/compromise/src/2-two/contraction-two/compute/apostrophe-s.js
var hasContraction3 = /'/;
var isHas = (terms, i3) => {
  let after2 = terms.slice(i3 + 1, i3 + 3);
  return after2.some((t2) => t2.tags.has("PastTense"));
};
var apostropheS = function(terms, i3) {
  let before2 = terms[i3].normal.split(hasContraction3)[0];
  if (isHas(terms, i3)) {
    return [before2, "has"];
  }
  if (before2 === "let") {
    return [before2, "us"];
  }
  if (before2 === "there") {
    let nextTerm = terms[i3 + 1];
    if (nextTerm && nextTerm.tags.has("Plural")) {
      return [before2, "are"];
    }
  }
  return [before2, "is"];
};
var apostrophe_s_default = apostropheS;

// node_modules/compromise/src/2-two/contraction-two/compute/apostrophe-d.js
var hasContraction4 = /'/;
var pickHad = (terms, i3) => {
  if (terms[i3 + 1] && terms[i3 + 1].normal == "better") {
    return true;
  }
  let after2 = terms.slice(i3 + 1, i3 + 3);
  return after2.some((t2) => t2.tags.has("PastTense"));
};
var _apostropheD2 = function(terms, i3) {
  let before2 = terms[i3].normal.split(hasContraction4)[0];
  if (before2 === "how" || before2 === "what") {
    return [before2, "did"];
  }
  if (pickHad(terms, i3) === true) {
    return [before2, "had"];
  }
  return [before2, "would"];
};
var apostrophe_d_default2 = _apostropheD2;

// node_modules/compromise/src/2-two/contraction-two/compute/apostrophe-t.js
var lastNoun = function(terms, i3) {
  for (let n3 = i3 - 1; n3 >= 0; n3 -= 1) {
    if (terms[n3].tags.has("Noun") || terms[n3].tags.has("Pronoun") || terms[n3].tags.has("Plural") || terms[n3].tags.has("Singular")) {
      return terms[n3];
    }
  }
  return null;
};
var apostropheT2 = function(terms, i3) {
  if (terms[i3].normal === "ain't" || terms[i3].normal === "aint") {
    if (terms[i3 + 1] && terms[i3 + 1].normal === "never") {
      return ["have"];
    }
    let noun = lastNoun(terms, i3);
    if (noun) {
      if (noun.normal === "we" || noun.normal === "they") {
        return ["are", "not"];
      }
      if (noun.normal === "i") {
        return ["am", "not"];
      }
      if (noun.tags && noun.tags.has("Plural")) {
        return ["are", "not"];
      }
    }
    return ["is", "not"];
  }
  let before2 = terms[i3].normal.replace(/n't/, "");
  return [before2, "not"];
};
var apostrophe_t_default2 = apostropheT2;

// node_modules/compromise/src/2-two/contraction-two/compute/isPossessive.js
var banList = {
  that: true,
  there: true,
  let: true,
  here: true,
  everywhere: true
};
var beforePossessive = {
  in: true,
  by: true,
  for: true
};
var isPossessive = (terms, i3) => {
  let term = terms[i3];
  if (banList.hasOwnProperty(term.machine || term.normal)) {
    return false;
  }
  if (term.tags.has("Possessive")) {
    return true;
  }
  if (term.tags.has("QuestionWord")) {
    return false;
  }
  if (term.normal === `he's` || term.normal === `she's`) {
    return false;
  }
  let nextTerm = terms[i3 + 1];
  if (!nextTerm) {
    return true;
  }
  if (term.normal === `it's`) {
    if (nextTerm.tags.has("#Noun")) {
      return true;
    }
    return false;
  }
  if (nextTerm.tags.has("Verb")) {
    if (nextTerm.tags.has("Infinitive")) {
      return true;
    }
    if (nextTerm.tags.has("PresentTense")) {
      return true;
    }
    return false;
  }
  if (nextTerm.tags.has("Noun")) {
    let nextStr = nextTerm.machine || nextTerm.normal;
    if (nextStr === "here" || nextStr === "there" || nextStr === "everywhere") {
      return false;
    }
    if (nextTerm.tags.has("Possessive")) {
      return false;
    }
    if (nextTerm.tags.has("ProperNoun") && !term.tags.has("ProperNoun")) {
      return false;
    }
    return true;
  }
  if (terms[i3 - 1] && beforePossessive[terms[i3 - 1].normal] === true) {
    return true;
  }
  let twoTerm = terms[i3 + 2];
  if (twoTerm && twoTerm.tags.has("Noun") && !twoTerm.tags.has("Pronoun")) {
    return true;
  }
  if (nextTerm.tags.has("Adjective") || nextTerm.tags.has("Adverb") || nextTerm.tags.has("Verb")) {
    return false;
  }
  return false;
};
var isPossessive_default = isPossessive;

// node_modules/compromise/src/2-two/contraction-two/compute/index.js
var byApostrophe2 = /'/;
var reIndex = function(terms) {
  terms.forEach((t2, i3) => {
    if (t2.index) {
      t2.index[1] = i3;
    }
  });
};
var reTag2 = function(terms, view, start2, len) {
  let tmp = view.update();
  tmp.document = [terms];
  let end2 = start2 + len;
  if (start2 > 0) {
    start2 -= 1;
  }
  if (terms[end2]) {
    end2 += 1;
  }
  tmp.ptrs = [[0, start2, end2]];
  tmp.compute(["lexicon", "preTagger"]);
  reIndex(terms);
};
var byEnd2 = {
  d: (terms, i3) => apostrophe_d_default2(terms, i3),
  t: (terms, i3) => apostrophe_t_default2(terms, i3),
  s: (terms, i3, world2) => {
    if (isPossessive_default(terms, i3)) {
      return world2.methods.one.setTag([terms[i3]], "Possessive", world2, "2-contraction");
    }
    return apostrophe_s_default(terms, i3);
  }
};
var toDocs2 = function(words, view) {
  let doc = view.fromText(words.join(" "));
  doc.compute("id");
  return doc.docs[0];
};
var contractionTwo = (view) => {
  let { world: world2, document: document2 } = view;
  document2.forEach((terms, n3) => {
    for (let i3 = terms.length - 1; i3 >= 0; i3 -= 1) {
      if (terms[i3].implicit) {
        return;
      }
      let after2 = null;
      if (byApostrophe2.test(terms[i3].normal) === true) {
        [, after2] = terms[i3].normal.split(byApostrophe2);
      }
      let words = null;
      if (byEnd2.hasOwnProperty(after2)) {
        words = byEnd2[after2](terms, i3, world2);
      }
      if (words) {
        words = toDocs2(words, view);
        splice_default2(document2, [n3, i3], words);
        reTag2(document2[n3], view, i3, words.length);
        continue;
      }
    }
  });
};
var compute_default9 = { contractionTwo };

// node_modules/compromise/src/2-two/contraction-two/plugin.js
var plugin_default14 = {
  compute: compute_default9,
  api: api_default10,
  hooks: ["contractionTwo"]
};

// node_modules/compromise/src/2-two/postTagger/model/adjective/adjective.js
var adjective_default = [
  { match: "[(all|both)] #Determiner #Noun", group: 0, tag: "Noun", reason: "all-noun" },
  { match: "#Copula [(just|alone)]$", group: 0, tag: "Adjective", reason: "not-adverb" },
  { match: "#Singular is #Adverb? [#PastTense$]", group: 0, tag: "Adjective", reason: "is-filled" },
  { match: "[#PastTense] #Singular is", group: 0, tag: "Adjective", reason: "smoked-poutine" },
  { match: "[#PastTense] #Plural are", group: 0, tag: "Adjective", reason: "baked-onions" },
  { match: "well [#PastTense]", group: 0, tag: "Adjective", reason: "well-made" },
  { match: "#Copula [fucked up?]", group: 0, tag: "Adjective", reason: "swears-adjective" },
  { match: "#Singular (seems|appears) #Adverb? [#PastTense$]", group: 0, tag: "Adjective", reason: "seems-filled" },
  { match: "#Copula #Adjective? [(out|in|through)]$", group: 0, tag: "Adjective", reason: "still-out" },
  { match: "^[#Adjective] (the|your) #Noun", group: 0, notIf: "(all|even)", tag: "Infinitive", reason: "shut-the" },
  { match: "the [said] #Noun", group: 0, tag: "Adjective", reason: "the-said-card" },
  { match: "[#Hyphenated (#Hyphenated && #PastTense)] (#Noun|#Conjunction)", group: 0, tag: "Adjective", notIf: "#Adverb", reason: "faith-based" },
  { match: "[#Hyphenated (#Hyphenated && #Gerund)] (#Noun|#Conjunction)", group: 0, tag: "Adjective", notIf: "#Adverb", reason: "self-driving" },
  { match: "[#PastTense (#Hyphenated && #PhrasalVerb)] (#Noun|#Conjunction)", group: 0, tag: "Adjective", reason: "dammed-up" },
  { match: "(#Hyphenated && #Value) fold", tag: "Adjective", reason: "two-fold" },
  { match: "must (#Hyphenated && #Infinitive)", tag: "Adjective", reason: "must-win" },
  { match: `(#Hyphenated && #Infinitive) #Hyphenated`, tag: "Adjective", notIf: "#PhrasalVerb", reason: "vacuum-sealed" },
  { match: "too much", tag: "Adverb Adjective", reason: "bit-4" },
  { match: "a bit much", tag: "Determiner Adverb Adjective", reason: "bit-3" },
  { match: "[(un|contra|extra|inter|intra|macro|micro|mid|mis|mono|multi|pre|sub|tri|ex)] #Adjective", group: 0, tag: ["Adjective", "Prefix"], reason: "un-skilled" }
];

// node_modules/compromise/src/2-two/postTagger/model/adjective/adj-adverb.js
var adverbAdj = `(dark|bright|flat|light|soft|pale|dead|dim|faux|little|wee|sheer|most|near|good|extra|all)`;
var adj_adverb_default = [
  { match: `#Adverb [#Adverb] (and|or|then)`, group: 0, tag: "Adjective", reason: "kinda-sparkly-and" },
  { match: `[${adverbAdj}] #Adjective`, group: 0, tag: "Adverb", reason: "dark-green" },
  { match: `#Copula [far too] #Adjective`, group: 0, tag: "Adverb", reason: "far-too" },
  { match: `#Copula [still] (in|#Gerund|#Adjective)`, group: 0, tag: "Adverb", reason: "was-still-walking" }
];

// node_modules/compromise/src/2-two/postTagger/model/adjective/adj-gerund.js
var adj_gerund_default2 = [
  { match: "(a|an) [#Gerund]", group: 0, tag: "Adjective", reason: "a|an" },
  { match: "as [#Gerund] as", group: 0, tag: "Adjective", reason: "as-gerund-as" },
  { match: "more [#Gerund] than", group: 0, tag: "Adjective", reason: "more-gerund-than" },
  { match: "(so|very|extremely) [#Gerund]", group: 0, tag: "Adjective", reason: "so-gerund" },
  { match: "(found|found) it #Adverb? [#Gerund]", group: 0, tag: "Adjective", reason: "found-it-gerund" },
  { match: "a (little|bit|wee) bit? [#Gerund]", group: 0, tag: "Adjective", reason: "a-bit-gerund" },
  { match: "#Gerund [#Gerund]", group: 0, tag: "Adjective", notIf: "(impersonating|practicing|considering|assuming)", reason: "looking-annoying" }
];

// node_modules/compromise/src/2-two/postTagger/model/adjective/adj-noun.js
var adj_noun_default2 = [
  { match: "#Determiner [#Adjective] #Copula", group: 0, tag: "Noun", reason: "the-adj-is" },
  { match: "#Adjective [#Adjective] #Copula", group: 0, tag: "Noun", reason: "adj-adj-is" },
  { match: "(his|its) [%Adj|Noun%]", group: 0, tag: "Noun", notIf: "#Hyphenated", reason: "his-fine" },
  { match: "#Copula #Adverb? [all]", group: 0, tag: "Noun", reason: "is-all" },
  { match: `(have|had) [#Adjective] #Preposition .`, group: 0, tag: "Noun", reason: "have-fun" },
  { match: `#Gerund (giant|capital|center|zone|application)`, tag: "Noun", reason: "brewing-giant" },
  { match: `#Preposition (a|an) [#Adjective]$`, group: 0, tag: "Noun", reason: "an-instant" },
  { match: `no [#Adjective] #Modal`, group: 0, tag: "Noun", reason: "no-golden" },
  { match: `[brand #Gerund?] new`, group: 0, tag: "Adverb", reason: "brand-new" },
  { match: `(#Determiner|#Comparative|new|different) [kind]`, group: 0, tag: "Noun", reason: "some-kind" },
  { match: `#Possessive [%Adj|Noun%] #Noun`, group: 0, tag: "Adjective", reason: "her-favourite" },
  { match: `must && #Hyphenated .`, tag: "Adjective", reason: "must-win" },
  { match: `#Determiner [#Adjective]$`, tag: "Noun", notIf: "(this|that|#Comparative|#Superlative)", reason: "the-south" },
  { match: `(#Noun && #Hyphenated) (#Adjective && #Hyphenated)`, tag: "Adjective", notIf: "(this|that|#Comparative|#Superlative)", reason: "company-wide" }
];

// node_modules/compromise/src/2-two/postTagger/model/adjective/adj-verb.js
var adj_verb_default = [
  { match: "(slowly|quickly) [#Adjective]", group: 0, tag: "Verb", reason: "slowly-adj" },
  { match: "does (#Adverb|not)? [#Adjective]", group: 0, tag: "PresentTense", reason: "does-mean" },
  { match: "[(fine|okay|cool|ok)] by me", group: 0, tag: "Adjective", reason: "okay-by-me" },
  { match: "i (#Adverb|do)? not? [mean]", group: 0, tag: "PresentTense", reason: "i-mean" },
  { match: "will #Adjective", tag: "Auxiliary Infinitive", reason: "will-adj" },
  { match: "#Pronoun [#Adjective] #Determiner #Adjective? #Noun", group: 0, tag: "Verb", reason: "he-adj-the" },
  { match: "#Copula [%Adj|Present%] to #Verb", group: 0, tag: "Verb", reason: "adj-to" },
  { match: "#Copula [#Adjective] (well|badly|quickly|slowly)", group: 0, tag: "Verb", reason: "done-well" },
  { match: "#Adjective and [#Gerund] !#Preposition?", group: 0, tag: "Adjective", reason: "rude-and-x" },
  { match: "#Copula #Adverb? (over|under) [#PastTense]", group: 0, tag: "Adjective", reason: "over-cooked" },
  { match: "#Copula #Adjective+ (and|or) [#PastTense]$", group: 0, tag: "Adjective", reason: "bland-and-overcooked" },
  { match: "got #Adverb? [#PastTense] of", group: 0, tag: "Adjective", reason: "got-tired-of" },
  { match: "(seem|seems|seemed|appear|appeared|appears|feel|feels|felt|sound|sounds|sounded) (#Adverb|#Adjective)? [#PastTense]", group: 0, tag: "Adjective", reason: "felt-loved" },
  { match: "(seem|feel|seemed|felt) [#PastTense #Particle?]", group: 0, tag: "Adjective", reason: "seem-confused" },
  { match: "a (bit|little|tad) [#PastTense #Particle?]", group: 0, tag: "Adjective", reason: "a-bit-confused" },
  { match: "not be [%Adj|Past% #Particle?]", group: 0, tag: "Adjective", reason: "do-not-be-confused" },
  { match: "#Copula just [%Adj|Past% #Particle?]", group: 0, tag: "Adjective", reason: "is-just-right" },
  { match: "as [#Infinitive] as", group: 0, tag: "Adjective", reason: "as-pale-as" },
  { match: "[%Adj|Past%] and #Adjective", group: 0, tag: "Adjective", reason: "faled-and-oppressive" },
  { match: "or [#PastTense] #Noun", group: 0, tag: "Adjective", notIf: "(#Copula|#Pronoun)", reason: "or-heightened-emotion" }
];

// node_modules/compromise/src/2-two/postTagger/model/adverb.js
var adverb_default = [
  { match: "[still] #Adjective", group: 0, tag: "Adverb", reason: "still-advb" },
  { match: "[still] #Verb", group: 0, tag: "Adverb", reason: "still-verb" },
  { match: "[so] #Adjective", group: 0, tag: "Adverb", reason: "so-adv" },
  { match: "[way] #Comparative", group: 0, tag: "Adverb", reason: "way-adj" },
  { match: "[way] #Adverb #Adjective", group: 0, tag: "Adverb", reason: "way-too-adj" },
  { match: "[all] #Verb", group: 0, tag: "Adverb", reason: "all-verb" },
  { match: "#Verb  [like]", group: 0, notIf: "(#Modal|#PhrasalVerb)", tag: "Adverb", reason: "verb-like" },
  { match: "(barely|hardly) even", tag: "Adverb", reason: "barely-even" },
  { match: "[even] #Verb", group: 0, tag: "Adverb", reason: "even-walk" },
  { match: "[even] #Comparative", group: 0, tag: "Adverb", reason: "even-worse" },
  { match: "[even] (#Determiner|#Possessive)", group: 0, tag: "#Adverb", reason: "even-the" },
  { match: "even left", tag: "#Adverb #Verb", reason: "even-left" },
  { match: "[way] #Adjective", group: 0, tag: "#Adverb", reason: "way-over" },
  {
    match: "#PresentTense [(hard|quick|long|bright|slow|fast|backwards|forwards)]",
    notIf: "#Copula",
    group: 0,
    tag: "Adverb",
    reason: "lazy-ly"
  },
  { match: "[much] #Adjective", group: 0, tag: "Adverb", reason: "bit-1" },
  { match: "#Copula [#Adverb]$", group: 0, tag: "Adjective", reason: "is-well" },
  { match: "a [(little|bit|wee) bit?] #Adjective", group: 0, tag: "Adverb", reason: "a-bit-cold" },
  { match: `[(super|pretty)] #Adjective`, group: 0, tag: "Adverb", reason: "super-strong" },
  { match: "(become|fall|grow) #Adverb? [#PastTense]", group: 0, tag: "Adjective", reason: "overly-weakened" },
  { match: "(a|an) #Adverb [#Participle] #Noun", group: 0, tag: "Adjective", reason: "completely-beaten" },
  { match: "#Determiner #Adverb? [close]", group: 0, tag: "Adjective", reason: "a-close" },
  { match: "#Gerund #Adverb? [close]", group: 0, tag: "Adverb", reason: "being-close" },
  { match: "(the|those|these|a|an) [#Participle] #Noun", group: 0, tag: "Adjective", reason: "blown-motor" },
  { match: "(#PresentTense|#PastTense) [back]", group: 0, tag: "Adverb", notIf: "#PhrasalVerb", reason: "charge-back" },
  { match: "#Verb [around]", group: 0, tag: "Adverb", notIf: "#PhrasalVerb", reason: "send-around" },
  { match: "[later] #PresentTense", group: 0, tag: "Adverb", reason: "later-say" }
];

// node_modules/compromise/src/2-two/postTagger/model/dates/date-phrase.js
var date_phrase_default = [
  { match: "#Holiday (day|eve)", tag: "Holiday", reason: "holiday-day" },
  { match: "#Value of #Month", tag: "Date", reason: "value-of-month" },
  { match: "#Cardinal #Month", tag: "Date", reason: "cardinal-month" },
  { match: "#Month #Value to #Value", tag: "Date", reason: "value-to-value" },
  { match: "#Month the #Value", tag: "Date", reason: "month-the-value" },
  { match: "(#WeekDay|#Month) #Value", tag: "Date", reason: "date-value" },
  { match: "#Value (#WeekDay|#Month)", tag: "Date", reason: "value-date" },
  { match: "(#TextValue && #Date) #TextValue", tag: "Date", reason: "textvalue-date" },
  { match: `#Month #NumberRange`, tag: "Date", reason: "aug 20-21" },
  { match: `#WeekDay #Month #Ordinal`, tag: "Date", reason: "week mm-dd" },
  { match: `#Month #Ordinal #Cardinal`, tag: "Date", reason: "mm-dd-yyy" },
  { match: `(#Place|#Demonmym|#Time) (standard|daylight|central|mountain)? time`, tag: "Timezone", reason: "std-time" },
  {
    match: `(eastern|mountain|pacific|central|atlantic) (standard|daylight|summer)? time`,
    tag: "Timezone",
    reason: "eastern-time"
  },
  { match: `#Time [(eastern|mountain|pacific|central|est|pst|gmt)]`, group: 0, tag: "Timezone", reason: "5pm-central" },
  { match: `(central|western|eastern) european time`, tag: "Timezone", reason: "cet" }
];

// node_modules/compromise/src/2-two/postTagger/model/dates/date.js
var date_default = [
  { match: "[sun] the #Ordinal", tag: "WeekDay", reason: "sun-the-5th" },
  { match: "[sun] #Date", group: 0, tag: "WeekDay", reason: "sun-feb" },
  { match: "#Date (on|this|next|last|during)? [sun]", group: 0, tag: "WeekDay", reason: "1pm-sun" },
  { match: `(in|by|before|during|on|until|after|of|within|all) [sat]`, group: 0, tag: "WeekDay", reason: "sat" },
  { match: `(in|by|before|during|on|until|after|of|within|all) [wed]`, group: 0, tag: "WeekDay", reason: "wed" },
  { match: `(in|by|before|during|on|until|after|of|within|all) [march]`, group: 0, tag: "Month", reason: "march" },
  { match: "[sat] #Date", group: 0, tag: "WeekDay", reason: "sat-feb" },
  { match: `#Preposition [(march|may)]`, group: 0, tag: "Month", reason: "in-month" },
  { match: `(this|next|last) (march|may) !#Infinitive`, tag: "#Date #Month", reason: "this-month" },
  { match: `(march|may) the? #Value`, tag: "#Month #Date #Date", reason: "march-5th" },
  { match: `#Value of? (march|may)`, tag: "#Date #Date #Month", reason: "5th-of-march" },
  { match: `[(march|may)] .? #Date`, group: 0, tag: "Month", reason: "march-and-feb" },
  { match: `#Date .? [(march|may)]`, group: 0, tag: "Month", reason: "feb-and-march" },
  { match: `#Adverb [(march|may)]`, group: 0, tag: "Verb", reason: "quickly-march" },
  { match: `[(march|may)] #Adverb`, group: 0, tag: "Verb", reason: "march-quickly" }
];

// node_modules/compromise/src/2-two/postTagger/model/nouns/nouns.js
var infNouns = "(feel|sense|process|rush|side|bomb|bully|challenge|cover|crush|dump|exchange|flow|function|issue|lecture|limit|march|process)";
var nouns_default4 = [
  { match: "(the|any) [more]", group: 0, tag: "Singular", reason: "more-noun" },
  { match: "[more] #Noun", group: 0, tag: "Adjective", reason: "more-noun" },
  { match: "(right|rights) of .", tag: "Noun", reason: "right-of" },
  { match: "a [bit]", group: 0, tag: "Singular", reason: "bit-2" },
  { match: "a [must]", group: 0, tag: "Singular", reason: "must-2" },
  { match: "(we|us) [all]", group: 0, tag: "Noun", reason: "we all" },
  { match: "due to [#Verb]", group: 0, tag: "Noun", reason: "due-to" },
  { match: "some [#Verb] #Plural", group: 0, tag: "Noun", reason: "determiner6" },
  { match: "#Possessive #Ordinal [#PastTense]", group: 0, tag: "Noun", reason: "first-thought" },
  { match: "(the|this|those|these) #Adjective [%Verb|Noun%]", group: 0, tag: "Noun", notIf: "#Copula", reason: "the-adj-verb" },
  { match: "(the|this|those|these) #Adverb #Adjective [#Verb]", group: 0, tag: "Noun", reason: "determiner4" },
  { match: "the [#Verb] #Preposition .", group: 0, tag: "Noun", reason: "determiner1" },
  { match: "(a|an|the) [#Verb] of", group: 0, tag: "Noun", reason: "the-verb-of" },
  { match: "#Determiner #Noun of [#Verb]", group: 0, tag: "Noun", notIf: "#Gerund", reason: "noun-of-noun" },
  { match: "#PastTense #Preposition [#PresentTense]", group: 0, notIf: "#Gerund", tag: "Noun", reason: "ended-in-ruins" },
  { match: "#Conjunction [u]", group: 0, tag: "Pronoun", reason: "u-pronoun-2" },
  { match: "[u] #Verb", group: 0, tag: "Pronoun", reason: "u-pronoun-1" },
  { match: "#Determiner [(western|eastern|northern|southern|central)] #Noun", group: 0, tag: "Noun", reason: "western-line" },
  { match: "(#Singular && @hasHyphen) #PresentTense", tag: "Noun", reason: "hyphen-verb" },
  { match: "is no [#Verb]", group: 0, tag: "Noun", reason: "is-no-verb" },
  { match: "do [so]", group: 0, tag: "Noun", reason: "so-noun" },
  { match: "#Determiner [(shit|damn|hell)]", group: 0, tag: "Noun", reason: "swears-noun" },
  { match: "to [(shit|hell)]", group: 0, tag: "Noun", reason: "to-swears" },
  { match: "(the|these) [#Singular] (were|are)", group: 0, tag: "Plural", reason: "singular-were" },
  { match: `a #Noun+ or #Adverb+? [#Verb]`, group: 0, tag: "Noun", reason: "noun-or-noun" },
  { match: "(the|those|these|a|an) #Adjective? [#PresentTense #Particle?]", group: 0, tag: "Noun", notIf: "(seem|appear|include|#Gerund|#Copula)", reason: "det-inf" },
  { match: "#Noun #Actor", tag: "Actor", reason: "thing-doer" },
  { match: "[#Actor+] #ProperNoun", group: 0, tag: "Honorific", reason: "sgt-kelly" },
  { match: `co #Singular`, tag: "Actor", reason: "co-noun" },
  { match: "#Determiner [sun]", group: 0, tag: "Singular", reason: "the-sun" },
  { match: "#Verb (a|an) [#Value]", group: 0, tag: "Singular", reason: "did-a-value" },
  { match: "the [(can|will|may)]", group: 0, tag: "Singular", reason: "the can" },
  { match: "#FirstName #Acronym? (#Possessive && #LastName)", tag: "Possessive", reason: "name-poss" },
  { match: "#Organization+ #Possessive", tag: "Possessive", reason: "org-possessive" },
  { match: "#Place+ #Possessive", tag: "Possessive", reason: "place-possessive" },
  { match: "#Possessive #PresentTense #Particle?", notIf: "(#Gerund|her)", tag: "Noun", reason: "possessive-verb" },
  { match: "(my|our|their|her|his|its) [(#Plural && #Actor)] #Noun", tag: "Possessive", reason: "my-dads" },
  { match: "#Value of a [second]", group: 0, unTag: "Value", tag: "Singular", reason: "10th-of-a-second" },
  { match: "#Value [seconds]", group: 0, unTag: "Value", tag: "Plural", reason: "10-seconds" },
  { match: "in [#Infinitive]", group: 0, tag: "Singular", reason: "in-age" },
  { match: "a [#Adjective] #Preposition", group: 0, tag: "Noun", reason: "a-minor-in" },
  { match: "#Determiner [#Singular] said", group: 0, tag: "Actor", reason: "the-actor-said" },
  { match: `#Determiner #Noun [${infNouns}] !(#Preposition|to|#Adverb)?`, group: 0, tag: "Noun", reason: "the-noun-sense" },
  { match: "[#PresentTense] (of|by|for) (a|an|the) #Noun #Copula", group: 0, tag: "Plural", reason: "photographs-of" },
  { match: "#Infinitive and [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "fight and win" },
  { match: "#Noun and [#Verb] and #Noun", group: 0, tag: "Noun", reason: "peace-and-flowers" },
  { match: "the #Cardinal [%Adj|Noun%]", group: 0, tag: "Noun", reason: "the-1992-classic" },
  { match: "#Copula the [%Adj|Noun%] #Noun", group: 0, tag: "Adjective", reason: "the-premier-university" },
  { match: "i #Verb [me] #Noun", group: 0, tag: "Possessive", reason: "scottish-me" },
  { match: "[#PresentTense] (music|class|lesson|night|party|festival|league|ceremony)", group: 0, tag: "Noun", reason: "dance-music" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/noun-gerund.js
var noun_gerund_default2 = [
  { match: "(this|that|the|a|an) [#Gerund #Infinitive]", group: 0, tag: "Singular", reason: "the-planning-process" },
  { match: "(that|the) [#Gerund #PresentTense]", group: 0, ifNo: "#Copula", tag: "Plural", reason: "the-paving-stones" },
  { match: "#Determiner [#Gerund] #Noun", group: 0, tag: "Adjective", reason: "the-gerund-noun" },
  { match: `#Pronoun #Infinitive [#Gerund] #PresentTense`, group: 0, tag: "Noun", reason: "tipping-sucks" },
  { match: "#Adjective [#Gerund]", group: 0, tag: "Noun", notIf: "(still|even|just)", reason: "early-warning" },
  { match: "[#Gerund] #Adverb? not? #Copula", group: 0, tag: "Activity", reason: "gerund-copula" },
  { match: "[#Gerund] #Modal", group: 0, tag: "Activity", reason: "gerund-modal" },
  { match: "#Singular for [%Noun|Gerund%]", group: 0, tag: "Gerund", reason: "noun-for-gerund" },
  { match: "#Comparative (for|at) [%Noun|Gerund%]", group: 0, tag: "Gerund", reason: "better-for-gerund" },
  { match: "#PresentTense the [#Gerund]", group: 0, tag: "Noun", reason: "keep-the-touching" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/verb-noun.js
var verb_noun_default = [
  { match: "#Infinitive (this|that|the) [#Infinitive]", group: 0, tag: "Noun", reason: "do-this-dance" },
  { match: "#Gerund #Determiner [#Infinitive]", group: 0, tag: "Noun", reason: "running-a-show" },
  { match: "#Determiner (only|further|just|more|backward) [#Infinitive]", group: 0, tag: "Noun", reason: "the-only-reason" },
  { match: "(the|this|a|an) [#Infinitive] #Adverb? #Verb", group: 0, tag: "Noun", reason: "determiner5" },
  { match: "#Determiner #Adjective #Adjective? [#Infinitive]", group: 0, tag: "Noun", reason: "a-nice-inf" },
  { match: "#Determiner #Demonym [#PresentTense]", group: 0, tag: "Noun", reason: "mexican-train" },
  { match: "#Adjective #Noun+ [#Infinitive] #Copula", group: 0, tag: "Noun", reason: "career-move" },
  { match: "at some [#Infinitive]", group: 0, tag: "Noun", reason: "at-some-inf" },
  { match: "(go|goes|went) to [#Infinitive]", group: 0, tag: "Noun", reason: "goes-to-verb" },
  { match: "(a|an) #Adjective? #Noun [#Infinitive] (#Preposition|#Noun)", group: 0, tag: "Noun", reason: "a-noun-inf" },
  { match: "(a|an) #Noun [#Infinitive]$", group: 0, tag: "Noun", reason: "a-noun-inf2" },
  { match: "#Gerund #Adjective? for [#Infinitive]", group: 0, tag: "Noun", reason: "running-for" },
  { match: "#Gerund #Adjective to [#Infinitive]", group: 0, tag: "Noun", reason: "running-to" },
  { match: "about [#Infinitive]", group: 0, tag: "Singular", reason: "about-love" },
  { match: "#Plural on [#Infinitive]", group: 0, tag: "Noun", reason: "on-stage" },
  { match: "any [#Infinitive]", group: 0, tag: "Noun", reason: "any-charge" },
  { match: "no [#Infinitive]", group: 0, tag: "Noun", reason: "no-doubt" },
  { match: "number of [#PresentTense]", group: 0, tag: "Noun", reason: "number-of-x" },
  { match: "(taught|teaches|learns|learned) [#PresentTense]", group: 0, tag: "Noun", reason: "teaches-x" },
  { match: "(try|use|attempt|build|make) [#Verb #Particle?]", notIf: "(#Copula|#Noun|sure|fun|up)", group: 0, tag: "Noun", reason: "do-verb" },
  { match: "^[#Infinitive] (is|was)", group: 0, tag: "Noun", reason: "checkmate-is" },
  { match: "#Infinitive much [#Infinitive]", group: 0, tag: "Noun", reason: "get-much" },
  { match: "[cause] #Pronoun #Verb", group: 0, tag: "Conjunction", reason: "cause-cuz" },
  { match: "the #Singular [#Infinitive] #Noun", group: 0, tag: "Noun", notIf: "#Pronoun", reason: "cardio-dance" },
  { match: "#Determiner #Modal [#Noun]", group: 0, tag: "PresentTense", reason: "should-smoke" },
  { match: "(this|that) [#Plural]", group: 0, tag: "PresentTense", notIf: "#Preposition", reason: "this-verbs" },
  {
    match: "(let|make|made) (him|her|it|#Person|#Place|#Organization)+ [#Singular] (a|an|the|it)",
    group: 0,
    tag: "Infinitive",
    reason: "let-him-glue"
  },
  { match: "#Verb (all|every|each|most|some|no) [#PresentTense]", notIf: "#Modal", group: 0, tag: "Noun", reason: "all-presentTense" },
  { match: "(had|have|#PastTense) #Adjective [#PresentTense]", group: 0, tag: "Noun", notIf: "better", reason: "adj-presentTense" },
  { match: "#Value #Adjective [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "one-big-reason" },
  { match: "#PastTense #Adjective+ [#PresentTense]", group: 0, tag: "Noun", notIf: "(#Copula|better)", reason: "won-wide-support" },
  { match: "(many|few|several|couple) [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "many-poses" },
  { match: "#Determiner #Adverb #Adjective [%Noun|Verb%]", group: 0, tag: "Noun", notIf: "#Copula", reason: "very-big-dream" },
  { match: "from #Noun to [%Noun|Verb%]", group: 0, tag: "Noun", reason: "start-to-finish" },
  { match: "(for|with|of) #Noun (and|or|not) [%Noun|Verb%]", group: 0, tag: "Noun", notIf: "#Pronoun", reason: "for-food-and-gas" },
  { match: "#Adjective #Adjective [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "adorable-little-store" },
  { match: "#Gerund #Adverb? #Comparative [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "higher-costs" },
  { match: "(#Noun && @hasComma) #Noun (and|or) [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "noun-list" },
  { match: "(many|any|some|several) [#PresentTense] for", group: 0, tag: "Noun", reason: "any-verbs-for" },
  { match: `to #PresentTense #Noun [#PresentTense] #Preposition`, group: 0, tag: "Noun", reason: "gas-exchange" },
  { match: `#PastTense (until|as|through|without) [#PresentTense]`, group: 0, tag: "Noun", reason: "waited-until-release" },
  { match: `#Gerund like #Adjective? [#PresentTense]`, group: 0, tag: "Plural", reason: "like-hot-cakes" },
  { match: `some #Adjective [#PresentTense]`, group: 0, tag: "Noun", reason: "some-reason" },
  { match: `for some [#PresentTense]`, group: 0, tag: "Noun", reason: "for-some-reason" },
  { match: `(same|some|the|that|a) kind of [#PresentTense]`, group: 0, tag: "Noun", reason: "some-kind-of" },
  { match: `(same|some|the|that|a) type of [#PresentTense]`, group: 0, tag: "Noun", reason: "some-type-of" },
  { match: `#Gerund #Adjective #Preposition [#PresentTense]`, group: 0, tag: "Noun", reason: "doing-better-for-x" },
  { match: `(get|got|have) #Comparative [#PresentTense]`, group: 0, tag: "Noun", reason: "got-better-aim" },
  { match: "whose [#PresentTense] #Copula", group: 0, tag: "Noun", reason: "whos-name-was" },
  { match: `#PhrasalVerb #Particle #Preposition [#PresentTense]`, group: 0, tag: "Noun", reason: "given-up-on-x" },
  { match: "there (are|were) #Adjective? [#PresentTense]", group: 0, tag: "Plural", reason: "there-are" },
  { match: "#Value [#PresentTense] of", group: 0, notIf: "(one|1|#Copula|#Infinitive)", tag: "Plural", reason: "2-trains" },
  { match: "[#PresentTense] (are|were) #Adjective", group: 0, tag: "Plural", reason: "compromises-are-possible" },
  { match: "^[(hope|guess|thought|think)] #Pronoun #Verb", group: 0, tag: "Infinitive", reason: "suppose-i" },
  { match: "#Possessive #Adjective [#Verb]", group: 0, tag: "Noun", notIf: "#Copula", reason: "our-full-support" },
  { match: "[(tastes|smells)] #Adverb? #Adjective", group: 0, tag: "PresentTense", reason: "tastes-good" },
  { match: "#Copula #Gerund [#PresentTense] !by?", group: 0, tag: "Noun", notIf: "going", reason: "ignoring-commute" },
  { match: "#Determiner #Adjective? [(shed|thought|rose|bid|saw|spelt)]", group: 0, tag: "Noun", reason: "noun-past" },
  { match: "how to [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "how-to-noun" },
  { match: "which [%Noun|Verb%] #Noun", group: 0, tag: "Infinitive", reason: "which-boost-it" },
  { match: "#Gerund [%Plural|Verb%]", group: 0, tag: "Plural", reason: "asking-questions" },
  { match: "(ready|available|difficult|hard|easy|made|attempt|try) to [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "ready-to-noun" },
  { match: "(bring|went|go|drive|run|bike) to [%Noun|Verb%]", group: 0, tag: "Noun", reason: "bring-to-noun" },
  { match: "#Modal #Noun [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "would-you-look" },
  { match: "#Copula just [#Infinitive]", group: 0, tag: "Noun", reason: "is-just-spam" },
  { match: "^%Noun|Verb% %Plural|Verb%", tag: "Imperative #Plural", reason: "request-copies" },
  { match: "#Adjective #Plural and [%Plural|Verb%]", group: 0, tag: "#Plural", reason: "pickles-and-drinks" },
  { match: "#Determiner #Year [#Verb]", group: 0, tag: "Noun", reason: "the-1968-film" },
  { match: "#Determiner [#PhrasalVerb #Particle]", group: 0, tag: "Noun", reason: "the-break-up" },
  { match: "#Determiner [%Adj|Noun%] #Noun", group: 0, tag: "Adjective", notIf: "(#Pronoun|#Possessive|#ProperNoun)", reason: "the-individual-goals" },
  { match: "[%Noun|Verb%] or #Infinitive", group: 0, tag: "Infinitive", reason: "work-or-prepare" },
  { match: "to #Infinitive [#PresentTense]", group: 0, tag: "Noun", notIf: "(#Gerund|#Copula|help)", reason: "to-give-thanks" }
];

// node_modules/compromise/src/2-two/postTagger/model/numbers/money.js
var money_default = [
  { match: "#Money and #Money #Currency?", tag: "Money", reason: "money-and-money" },
  { match: "#Value #Currency [and] #Value (cents|ore|centavos|sens)", group: 0, tag: "money", reason: "and-5-cents" },
  { match: "#Value (mark|rand|won|rub|ore)", tag: "#Money #Currency", reason: "4 mark" }
];

// node_modules/compromise/src/2-two/postTagger/model/numbers/fractions.js
var fractions_default = [
  { match: "[(half|quarter)] of? (a|an)", group: 0, tag: "Fraction", reason: "millionth" },
  { match: "#Adverb [half]", group: 0, tag: "Fraction", reason: "nearly-half" },
  { match: "[half] the", group: 0, tag: "Fraction", reason: "half-the" },
  { match: "#Cardinal and a half", tag: "Fraction", reason: "and-a-half" },
  { match: "#Value (halves|halfs|quarters)", tag: "Fraction", reason: "two-halves" },
  { match: "a #Ordinal", tag: "Fraction", reason: "a-quarter" },
  { match: "[#Cardinal+] (#Fraction && /s$/)", tag: "Fraction", reason: "seven-fifths" },
  { match: "[#Cardinal+ #Ordinal] of .", group: 0, tag: "Fraction", reason: "ordinal-of" },
  { match: "[(#NumericValue && #Ordinal)] of .", group: 0, tag: "Fraction", reason: "num-ordinal-of" },
  { match: "(a|one) #Cardinal?+ #Ordinal", tag: "Fraction", reason: "a-ordinal" },
  { match: "#Cardinal+ out? of every? #Cardinal", tag: "Fraction", reason: "out-of" }
];

// node_modules/compromise/src/2-two/postTagger/model/numbers/numbers.js
var numbers_default = [
  { match: `#Cardinal [second]`, tag: "Unit", reason: "one-second" },
  {
    match: "!once? [(a|an)] (#Duration|hundred|thousand|million|billion|trillion)",
    group: 0,
    tag: "Value",
    reason: "a-is-one"
  },
  { match: "1 #Value #PhoneNumber", tag: "PhoneNumber", reason: "1-800-Value" },
  { match: "#NumericValue #PhoneNumber", tag: "PhoneNumber", reason: "(800) PhoneNumber" },
  { match: "#Demonym #Currency", tag: "Currency", reason: "demonym-currency" },
  { match: "#Value [(buck|bucks|grand)]", group: 0, tag: "Currency", reason: "value-bucks" },
  { match: "[#Value+] #Currency", group: 0, tag: "Money", reason: "15 usd" },
  { match: "[second] #Noun", group: 0, tag: "Ordinal", reason: "second-noun" },
  { match: "#Value+ [#Currency]", group: 0, tag: "Unit", reason: "5-yan" },
  { match: "#Value [(foot|feet)]", group: 0, tag: "Unit", reason: "foot-unit" },
  { match: "#Value [#Abbreviation]", group: 0, tag: "Unit", reason: "value-abbr" },
  { match: "#Value [k]", group: 0, tag: "Unit", reason: "value-k" },
  { match: "#Unit an hour", tag: "Unit", reason: "unit-an-hour" },
  { match: "(minus|negative) #Value", tag: "Value", reason: "minus-value" },
  { match: "#Value (point|decimal) #Value", tag: "Value", reason: "value-point-value" },
  { match: "#Determiner [(half|quarter)] #Ordinal", group: 0, tag: "Value", reason: "half-ordinal" },
  { match: `#Multiple+ and #Value`, tag: "Value", reason: "magnitude-and-value" },
  { match: "#Value #Unit [(per|an) (hr|hour|sec|second|min|minute)]", group: 0, tag: "Unit", reason: "12-miles-per-second" },
  { match: "#Value [(square|cubic)] #Unit", group: 0, tag: "Unit", reason: "square-miles" }
];

// node_modules/compromise/src/2-two/postTagger/model/person/person-phrase.js
var person_phrase_default = [
  { match: "#Copula [(#Noun|#PresentTense)] #LastName", group: 0, tag: "FirstName", reason: "copula-noun-lastname" },
  { match: "(sister|pope|brother|father|aunt|uncle|grandpa|grandfather|grandma) #ProperNoun", tag: "Person", reason: "lady-titlecase", safe: true },
  { match: "#FirstName [#Determiner #Noun] #LastName", group: 0, tag: "Person", reason: "first-noun-last" },
  {
    match: "#ProperNoun (b|c|d|e|f|g|h|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z) #ProperNoun",
    tag: "Person",
    reason: "titlecase-acronym-titlecase",
    safe: true
  },
  { match: "#Acronym #LastName", tag: "Person", reason: "acronym-lastname", safe: true },
  { match: "#Person (jr|sr|md)", tag: "Person", reason: "person-honorific" },
  { match: "#Honorific #Acronym", tag: "Person", reason: "Honorific-TitleCase" },
  { match: "#Person #Person the? #RomanNumeral", tag: "Person", reason: "roman-numeral" },
  { match: "#FirstName [/^[^aiurck]$/]", group: 0, tag: ["Acronym", "Person"], reason: "john-e" },
  { match: "#Noun van der? #Noun", tag: "Person", reason: "van der noun", safe: true },
  { match: "(king|queen|prince|saint|lady) of #Noun", tag: "Person", reason: "king-of-noun", safe: true },
  { match: "(prince|lady) #Place", tag: "Person", reason: "lady-place" },
  { match: "(king|queen|prince|saint) #ProperNoun", tag: "Person", reason: "saint-foo" },
  { match: "al (#Person|#ProperNoun)", tag: "Person", reason: "al-borlen", safe: true },
  { match: "#FirstName de #Noun", tag: "Person", reason: "bill-de-noun" },
  { match: "#FirstName (bin|al) #Noun", tag: "Person", reason: "bill-al-noun" },
  { match: "#FirstName #Acronym #ProperNoun", tag: "Person", reason: "bill-acronym-title" },
  { match: "#FirstName #FirstName #ProperNoun", tag: "Person", reason: "bill-firstname-title" },
  { match: "(#Honorific|#Actor) #FirstName? #ProperNoun", tag: "Person", reason: "dr-john-Title" },
  { match: "#FirstName the #Adjective", tag: "Person", reason: "name-the-great" },
  { match: "#ProperNoun (van|al|bin) #ProperNoun", tag: "Person", reason: "title-van-title", safe: true },
  { match: "#ProperNoun (de|du) la? #ProperNoun", tag: "Person", reason: "title-de-title" },
  { match: "#Singular #Acronym #LastName", tag: "#FirstName #Person .", reason: "title-acro-noun", safe: true },
  { match: "[#ProperNoun] #Person", group: 0, tag: "Person", reason: "proper-person", safe: true },
  { match: "#Person [#ProperNoun #ProperNoun]", group: 0, tag: "Person", notIf: "#Possessive", reason: "three-name-person", safe: true },
  { match: "#FirstName #Acronym? [#ProperNoun]", group: 0, tag: "LastName", notIf: "#Possessive", reason: "firstname-titlecase" },
  { match: "#FirstName [#FirstName]", group: 0, tag: "LastName", reason: "firstname-firstname" },
  { match: "#FirstName #Acronym #Noun", tag: "Person", reason: "n-acro-noun", safe: true },
  { match: "#FirstName [(de|di|du|van|von)] #Person", group: 0, tag: "LastName", reason: "de-firstname" },
  { match: "[(private|general|major|rear|prime|field|count|miss)] #Honorific? #Person", group: 0, tag: ["Honorific", "Person"], reason: "ambg-honorifics" },
  { match: "#Honorific #FirstName [#Singular]", group: 0, tag: "LastName", notIf: "#Possessive", reason: "dr-john-foo", safe: true },
  { match: "[(his|her) (majesty|honour|worship|excellency|honorable)] #Person", group: 0, tag: "Honorific", reason: "his-excellency" },
  { match: "#Honorific #Actor", tag: "Honorific", reason: "Lieutenant colonel" },
  { match: "(first|second|third|1st|2nd|3rd) #Actor", tag: "Honorific", reason: "first lady" }
];

// node_modules/compromise/src/2-two/postTagger/model/person/ambig-name.js
var personAdj = "(misty|rusty|dusty|rich|randy|sandy|young|earnest|frank|brown)";
var ambig_name_default = [
  { match: "%Person|Date% #Acronym? #ProperNoun", tag: "Person", reason: "jan-thierson" },
  { match: "%Person|Noun% #Acronym? #ProperNoun", tag: "Person", reason: "switch-person", safe: true },
  { match: "%Person|Noun% #Organization", tag: "Organization", reason: "olive-garden" },
  { match: "%Person|Verb% #Acronym? #ProperNoun", tag: "Person", reason: "verb-propernoun" },
  { match: `[%Person|Verb%] (will|had|has|said|says|told|did|learned|wants|wanted)`, group: 0, tag: "Person", reason: "person-said" },
  { match: `[%Person|Place%] (harbor|harbour|pier|town|city|place|dump|landfill)`, group: 0, tag: "Place", reason: "sydney-harbour" },
  { match: `(west|east|north|south) [%Person|Place%]`, group: 0, tag: "Place", reason: "east-sydney" },
  { match: `${personAdj} #Person`, tag: "Person", reason: "randy-smith" },
  { match: `${personAdj} #Acronym? #ProperNoun`, tag: "Person", reason: "rusty-smith" },
  { match: `#Adverb [${personAdj}]`, group: 0, tag: "Adjective", reason: "really-rich" },
  { match: `#Modal [%Person|Verb%]`, group: 0, tag: "Verb", reason: "would-mark" },
  { match: `#Adverb [%Person|Verb%]`, group: 0, tag: "Verb", reason: "really-mark" },
  { match: `[%Person|Verb%] (#Adverb|#Comparative)`, group: 0, tag: "Verb", reason: "drew-closer" },
  { match: `%Person|Verb% #Person`, tag: "Person", reason: "rob-smith" },
  { match: `%Person|Verb% #Acronym #ProperNoun`, tag: "Person", reason: "rob-a-smith" },
  { match: "[will] #Verb", group: 0, tag: "Modal", reason: "will-verb" },
  { match: "(will && @isTitleCase) #ProperNoun", tag: "Person", reason: "will-name" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/verbs.js
var verbs_default3 = [
  {
    match: "#Copula (pretty|dead|full|well|sure) (#Adjective|#Noun)",
    tag: "#Copula #Adverb #Adjective",
    reason: "sometimes-adverb"
  },
  { match: "(#Pronoun|#Person) (had|#Adverb)? [better] #PresentTense", group: 0, tag: "Modal", reason: "i-better" },
  { match: "(#Modal|i|they|we|do) not? [like]", group: 0, tag: "PresentTense", reason: "modal-like" },
  { match: "#Noun #Adverb? [left]", group: 0, tag: "PastTense", reason: "left-verb" },
  { match: "will #Adverb? not? #Adverb? [be] #Gerund", group: 0, tag: "Copula", reason: "will-be-copula" },
  { match: "will #Adverb? not? #Adverb? [be] #Adjective", group: 0, tag: "Copula", reason: "be-copula" },
  { match: "[march] (up|down|back|toward)", notIf: "#Date", group: 0, tag: "Infinitive", reason: "march-to" },
  { match: "#Modal [march]", group: 0, tag: "Infinitive", reason: "must-march" },
  { match: `[may] be`, group: 0, tag: "Verb", reason: "may-be" },
  { match: `[(subject|subjects|subjected)] to`, group: 0, tag: "Verb", reason: "subject to" },
  { match: `[home] to`, group: 0, tag: "PresentTense", reason: "home to" },
  { match: "[open] #Determiner", group: 0, tag: "Infinitive", reason: "open-the" },
  { match: `(were|was) being [#PresentTense]`, group: 0, tag: "PastTense", reason: "was-being" },
  { match: `(had|has|have) [been /en$/]`, group: 0, tag: "Auxiliary Participle", reason: "had-been-broken" },
  { match: `(had|has|have) [been /ed$/]`, group: 0, tag: "Auxiliary PastTense", reason: "had-been-smoked" },
  { match: `(had|has) #Adverb? [been] #Adverb? #PastTense`, group: 0, tag: "Auxiliary", reason: "had-been-adj" },
  { match: `(had|has) to [#Noun] (#Determiner|#Possessive)`, group: 0, tag: "Infinitive", reason: "had-to-noun" },
  { match: `have [#PresentTense]`, group: 0, tag: "PastTense", notIf: "(come|gotten)", reason: "have-read" },
  { match: `(does|will|#Modal) that [work]`, group: 0, tag: "PastTense", reason: "does-that-work" },
  { match: `[(sound|sounds)] #Adjective`, group: 0, tag: "PresentTense", reason: "sounds-fun" },
  { match: `[(look|looks)] #Adjective`, group: 0, tag: "PresentTense", reason: "looks-good" },
  { match: `[(need|needs)] to #Infinitive`, group: 0, tag: "PresentTense", reason: "need-to-learn" },
  { match: `[(start|starts|stop|stops|begin|begins)] #Gerund`, group: 0, tag: "Verb", reason: "starts-thinking" },
  { match: `(have|had) read`, tag: "Modal #PastTense", reason: "read-read" },
  {
    match: `(is|was|were) [(under|over) #PastTense]`,
    group: 0,
    tag: "Adverb Adjective",
    reason: "was-under-cooked"
  },
  { match: "[shit] (#Determiner|#Possessive|them)", group: 0, tag: "Verb", reason: "swear1-verb" },
  { match: "[damn] (#Determiner|#Possessive|them)", group: 0, tag: "Verb", reason: "swear2-verb" },
  { match: "[fuck] (#Determiner|#Possessive|them)", group: 0, tag: "Verb", reason: "swear3-verb" },
  { match: "#Plural that %Noun|Verb%", tag: ". #Preposition #Infinitive", reason: "jobs-that-work" },
  { match: "[works] for me", group: 0, tag: "PresentTense", reason: "works-for-me" },
  { match: "as #Pronoun [please]", group: 0, tag: "Infinitive", reason: "as-we-please" },
  { match: "[(co|mis|de|inter|intra|pre|re|un|out|under|over|counter)] #Verb", group: 0, tag: ["Verb", "Prefix"], notIf: "(#Copula|#PhrasalVerb)", reason: "co-write" },
  { match: "#PastTense and [%Adj|Past%]", group: 0, tag: "PastTense", reason: "dressed-and-left" },
  { match: "[%Adj|Past%] and #PastTense", group: 0, tag: "PastTense", reason: "dressed-and-left" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/auxiliary.js
var auxiliary_default = [
  { match: `will (#Adverb|not)+? [have] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "will-have-vb" },
  { match: `[#Copula] (#Adverb|not)+? (#Gerund|#PastTense)`, group: 0, tag: "Auxiliary", reason: "copula-walking" },
  { match: `[(#Modal|did)+] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "modal-verb" },
  { match: `#Modal (#Adverb|not)+? [have] (#Adverb|not)+? [had] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "would-have" },
  { match: `[(has|had)] (#Adverb|not)+? #PastTense`, group: 0, tag: "Auxiliary", reason: "had-walked" },
  { match: "[(do|does|did|will|have|had|has|got)] (not|#Adverb)+? #Verb", group: 0, tag: "Auxiliary", reason: "have-had" },
  { match: "[about to] #Adverb? #Verb", group: 0, tag: ["Auxiliary", "Verb"], reason: "about-to" },
  { match: `#Modal (#Adverb|not)+? [be] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "would-be" },
  { match: `[(#Modal|had|has)] (#Adverb|not)+? [been] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "had-been" },
  { match: "[(be|being|been)] #Participle", group: 0, tag: "Auxiliary", reason: "being-driven" },
  { match: "[may] #Adverb? #Infinitive", group: 0, tag: "Auxiliary", reason: "may-want" },
  { match: "#Copula (#Adverb|not)+? [(be|being|been)] #Adverb+? #PastTense", group: 0, tag: "Auxiliary", reason: "being-walked" },
  { match: "will [be] #PastTense", group: 0, tag: "Auxiliary", reason: "will-be-x" },
  { match: "[(be|been)] (#Adverb|not)+? #Gerund", group: 0, tag: "Auxiliary", reason: "been-walking" },
  { match: "[used to] #PresentTense", group: 0, tag: "Auxiliary", reason: "used-to-walk" },
  { match: "#Copula (#Adverb|not)+? [going to] #Adverb+? #PresentTense", group: 0, tag: "Auxiliary", reason: "going-to-walk" },
  { match: "#Imperative [(me|him|her)]", group: 0, tag: "Reflexive", reason: "tell-him" },
  { match: "(is|was) #Adverb? [no]", group: 0, tag: "Negative", reason: "is-no" },
  { match: "[(been|had|became|came)] #PastTense", group: 0, notIf: "#PhrasalVerb", tag: "Auxiliary", reason: "been-told" },
  { match: "[(being|having|getting)] #Verb", group: 0, tag: "Auxiliary", reason: "being-born" },
  { match: "[be] #Gerund", group: 0, tag: "Auxiliary", reason: "be-walking" },
  { match: "[better] #PresentTense", group: 0, tag: "Modal", notIf: "(#Copula|#Gerund)", reason: "better-go" },
  { match: "even better", tag: "Adverb #Comparative", reason: "even-better" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/phrasal.js
var phrasal_default = [
  { match: "(#Verb && @hasHyphen) up", tag: "PhrasalVerb", reason: "foo-up" },
  { match: "(#Verb && @hasHyphen) off", tag: "PhrasalVerb", reason: "foo-off" },
  { match: "(#Verb && @hasHyphen) over", tag: "PhrasalVerb", reason: "foo-over" },
  { match: "(#Verb && @hasHyphen) out", tag: "PhrasalVerb", reason: "foo-out" },
  {
    match: "[#Verb (in|out|up|down|off|back)] (on|in)",
    notIf: "#Copula",
    tag: "PhrasalVerb Particle",
    reason: "walk-in-on"
  },
  { match: "(lived|went|crept|go) [on] for", group: 0, tag: "PhrasalVerb", reason: "went-on" },
  { match: "#Verb (up|down|in|on|for)$", tag: "PhrasalVerb #Particle", notIf: "#PhrasalVerb", reason: "come-down$" },
  { match: "help [(stop|end|make|start)]", group: 0, tag: "Infinitive", reason: "help-stop" },
  { match: "[(stop|start|finish|help)] #Gerund", group: 0, tag: "Infinitive", reason: "start-listening" },
  {
    match: "#Verb (him|her|it|us|himself|herself|itself|everything|something) [(up|down)]",
    group: 0,
    tag: "Adverb",
    reason: "phrasal-pronoun-advb"
  }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/imperative.js
var notIf2 = "(i|we|they)";
var imperative_default2 = [
  { match: "^do not? [#Infinitive #Particle?]", notIf: notIf2, group: 0, tag: "Imperative", reason: "do-eat" },
  { match: "^please do? not? [#Infinitive #Particle?]", group: 0, tag: "Imperative", reason: "please-go" },
  { match: "^just do? not? [#Infinitive #Particle?]", group: 0, tag: "Imperative", reason: "just-go" },
  { match: "^[#Infinitive] it #Comparative", notIf: notIf2, group: 0, tag: "Imperative", reason: "do-it-better" },
  { match: "^[#Infinitive] it (please|now|again|plz)", notIf: notIf2, group: 0, tag: "Imperative", reason: "do-it-please" },
  { match: "^[#Infinitive] (#Adjective|#Adverb)$", group: 0, tag: "Imperative", notIf: "(so|such|rather|enough)", reason: "go-quickly" },
  { match: "^[#Infinitive] (up|down|over) #Determiner", group: 0, tag: "Imperative", reason: "turn-down" },
  { match: "^[#Infinitive] (your|my|the|a|an|any|each|every|some|more|with|on)", group: 0, notIf: "like", tag: "Imperative", reason: "eat-my-shorts" },
  { match: "^[#Infinitive] (him|her|it|us|me|there)", group: 0, tag: "Imperative", reason: "tell-him" },
  { match: "^[#Infinitive] #Adjective #Noun$", group: 0, tag: "Imperative", reason: "avoid-loud-noises" },
  { match: "^[#Infinitive] (#Adjective|#Adverb)? and #Infinitive", group: 0, tag: "Imperative", reason: "call-and-reserve" },
  { match: "^(go|stop|wait|hurry) please?$", tag: "Imperative", reason: "go" },
  { match: "^(somebody|everybody) [#Infinitive]", group: 0, tag: "Imperative", reason: "somebody-call" },
  { match: "^let (us|me) [#Infinitive]", group: 0, tag: "Imperative", reason: "lets-leave" },
  { match: "^[(shut|close|open|start|stop|end|keep)] #Determiner #Noun", group: 0, tag: "Imperative", reason: "shut-the-door" },
  { match: "^[go] to .", group: 0, tag: "Imperative", reason: "go-to-toronto" },
  { match: "^#Modal you [#Infinitive]", group: 0, tag: "Imperative", reason: "would-you-" },
  { match: "^never [#Infinitive]", group: 0, tag: "Imperative", reason: "never-stop" },
  { match: "^come #Infinitive", tag: "Imperative", notIf: "on", reason: "come-have" },
  { match: "^come and? #Infinitive", tag: "Imperative . Imperative", notIf: "#PhrasalVerb", reason: "come-and-have" },
  { match: "^stay (out|away|back)", tag: "Imperative", reason: "stay-away" },
  { match: "^[(stay|be|keep)] #Adjective", group: 0, tag: "Imperative", reason: "stay-cool" },
  { match: "^[keep it] #Adjective", group: 0, tag: "Imperative", reason: "keep-it-cool" },
  { match: "^do not [#Infinitive]", group: 0, tag: "Imperative", reason: "do-not-be" },
  { match: "[#Infinitive] (yourself|yourselves)", group: 0, tag: "Imperative", reason: "allow-yourself" },
  { match: "[#Infinitive] what .", group: 0, tag: "Imperative", reason: "look-what" },
  { match: "^[#Infinitive] #Gerund", group: 0, tag: "Imperative", reason: "keep-playing" },
  { match: "^[#Infinitive] (to|for|into|toward|here|there)", group: 0, tag: "Imperative", reason: "go-to" },
  { match: "^[#Infinitive] (and|or) #Infinitive", group: 0, tag: "Imperative", reason: "inf-and-inf" },
  { match: "^[%Noun|Verb%] to", group: 0, tag: "Imperative", reason: "commit-to" },
  { match: "^[#Infinitive] #Adjective? #Singular #Singular", group: 0, tag: "Imperative", reason: "maintain-eye-contact" },
  { match: "do not (forget|omit|neglect) to [#Infinitive]", group: 0, tag: "Imperative", reason: "do-not-forget" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/adj-gerund.js
var adj_gerund_default3 = [
  { match: "(that|which) were [%Adj|Gerund%]", group: 0, tag: "Gerund", reason: "that-were-growing" },
  { match: "#Gerund [#Gerund] #Plural", group: 0, tag: "Adjective", reason: "hard-working-fam" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/passive.js
var passive_default = [
  { match: "(got|were|was|is|are|am) (#PastTense|#Participle)", tag: "Passive", reason: "got-walked" },
  { match: "(was|were|is|are|am) being (#PastTense|#Participle)", tag: "Passive", reason: "was-being" },
  { match: "(had|have|has) been (#PastTense|#Participle)", tag: "Passive", reason: "had-been" },
  { match: "will be being? (#PastTense|#Participle)", tag: "Passive", reason: "will-be-cleaned" },
  { match: "#Noun [(#PastTense|#Participle)] by (the|a) #Noun", group: 0, tag: "Passive", reason: "suffered-by" }
];

// node_modules/compromise/src/2-two/postTagger/model/_misc.js
var matches = [
  { match: "u r", tag: "#Pronoun #Copula", reason: "u r" },
  { match: "#Noun [(who|whom)]", group: 0, tag: "Determiner", reason: "captain-who" },
  { match: "[had] #Noun+ #PastTense", group: 0, tag: "Condition", reason: "had-he" },
  { match: "[were] #Noun+ to #Infinitive", group: 0, tag: "Condition", reason: "were-he" },
  { match: "some sort of", tag: "Adjective Noun Conjunction", reason: "some-sort-of" },
  { match: "of some sort", tag: "Conjunction Adjective Noun", reason: "of-some-sort" },
  { match: "[such] (a|an|is)? #Noun", group: 0, tag: "Determiner", reason: "such-skill" },
  { match: "[right] (before|after|in|into|to|toward)", group: 0, tag: "#Adverb", reason: "right-into" },
  { match: "#Preposition [about]", group: 0, tag: "Adjective", reason: "at-about" },
  { match: "(are|#Modal|see|do|for) [ya]", group: 0, tag: "Pronoun", reason: "are-ya" },
  { match: "[long live] .", group: 0, tag: "#Adjective #Infinitive", reason: "long-live" },
  { match: "[plenty] of", group: 0, tag: "#Uncountable", reason: "plenty-of" },
  { match: "(always|nearly|barely|practically) [there]", group: 0, tag: "Adjective", reason: "always-there" },
  { match: "[there] (#Adverb|#Pronoun)? #Copula", group: 0, tag: "There", reason: "there-is" },
  { match: "#Copula [there] .", group: 0, tag: "There", reason: "is-there" },
  { match: "#Modal #Adverb? [there]", group: 0, tag: "There", reason: "should-there" },
  { match: "^[do] (you|we|they)", group: 0, tag: "QuestionWord", reason: "do-you" },
  { match: "^[does] (he|she|it|#ProperNoun)", group: 0, tag: "QuestionWord", reason: "does-he" },
  { match: "a [while]", group: 0, tag: "Noun", reason: "a-while" },
  { match: "guess who", tag: "#Infinitive #QuestionWord", reason: "guess-who" }
];
var misc_default4 = matches;

// node_modules/compromise/src/2-two/postTagger/model/orgs/organizations.js
var organizations_default2 = [
  { match: "#Noun (&|n) #Noun", tag: "Organization", reason: "Noun-&-Noun" },
  { match: "#Organization of the? #ProperNoun", tag: "Organization", reason: "org-of-place", safe: true },
  { match: "#Organization #Country", tag: "Organization", reason: "org-country" },
  { match: "#ProperNoun #Organization", tag: "Organization", reason: "titlecase-org" },
  { match: "#ProperNoun (ltd|co|inc|dept|assn|bros)", tag: "Organization", reason: "org-abbrv" },
  { match: "the [#Acronym]", group: 0, tag: "Organization", reason: "the-acronym", safe: true },
  {
    match: "(world|global|international|national|#Demonym) #Organization",
    tag: "Organization",
    reason: "global-org"
  },
  { match: "#Noun+ (public|private) school", tag: "School", reason: "noun-public-school" }
];

// node_modules/compromise/src/2-two/postTagger/model/nouns/places.js
var places_default2 = [
  {
    match: "(west|north|south|east|western|northern|southern|eastern)+ #Place",
    tag: "Region",
    reason: "west-norfolk"
  },
  {
    match: "#City [(al|ak|az|ar|ca|ct|dc|fl|ga|id|il|nv|nh|nj|ny|oh|pa|sc|tn|tx|ut|vt|pr)]",
    group: 0,
    tag: "Region",
    reason: "us-state"
  },
  {
    match: "portland [or]",
    group: 0,
    tag: "Region",
    reason: "portland-or"
  },
  {
    match: "#ProperNoun+ (district|region|province|county|prefecture|municipality|territory|burough|reservation)",
    tag: "Region",
    reason: "foo-district"
  },
  {
    match: "(district|region|province|municipality|territory|burough|state) of #ProperNoun",
    tag: "Region",
    reason: "district-of-Foo"
  },
  {
    match: "in [#ProperNoun] #Place",
    group: 0,
    tag: "Place",
    reason: "propernoun-place"
  },
  {
    match: "#Value #Noun (st|street|rd|road|crescent|cr|way|tr|terrace|avenue|ave)",
    tag: "Address",
    reason: "address-st"
  }
];

// node_modules/compromise/src/2-two/postTagger/model/conjunctions.js
var conjunctions_default = [
  { match: "[so] #Noun", group: 0, tag: "Conjunction", reason: "so-conj" },
  {
    match: "[(who|what|where|why|how|when)] #Noun #Copula #Adverb? (#Verb|#Adjective)",
    group: 0,
    tag: "Conjunction",
    reason: "how-he-is-x"
  },
  { match: "#Copula [(who|what|where|why|how|when)] #Noun", group: 0, tag: "Conjunction", reason: "when-he" },
  { match: "#Verb [that] #Pronoun", group: 0, tag: "Conjunction", reason: "said-that-he" },
  { match: "#Noun [that] #Copula", group: 0, tag: "Conjunction", reason: "that-are" },
  { match: "#Noun [that] #Verb #Adjective", group: 0, tag: "Conjunction", reason: "that-seem" },
  { match: "#Noun #Copula not? [that] #Adjective", group: 0, tag: "Adverb", reason: "that-adj" },
  { match: "#Verb #Adverb? #Noun [(that|which)]", group: 0, tag: "Preposition", reason: "that-prep" },
  { match: "@hasComma [which] (#Pronoun|#Verb)", group: 0, tag: "Preposition", reason: "which-copula" },
  { match: "#Noun [like] #Noun", group: 0, tag: "Preposition", reason: "noun-like" },
  { match: "^[like] #Determiner", group: 0, tag: "Preposition", reason: "like-the" },
  { match: "a #Noun [like] (#Noun|#Determiner)", group: 0, tag: "Preposition", reason: "a-noun-like" },
  { match: "#Adverb [like]", group: 0, tag: "Verb", reason: "really-like" },
  { match: "(not|nothing|never) [like]", group: 0, tag: "Preposition", reason: "nothing-like" },
  { match: "#Infinitive #Pronoun [like]", group: 0, tag: "Preposition", reason: "treat-them-like" },
  { match: "[#QuestionWord] (#Pronoun|#Determiner)", group: 0, tag: "Preposition", reason: "how-he" },
  { match: "[#QuestionWord] #Participle", group: 0, tag: "Preposition", reason: "when-stolen" },
  { match: "[how] (#Determiner|#Copula|#Modal|#PastTense)", group: 0, tag: "QuestionWord", reason: "how-is" },
  { match: "#Plural [(who|which|when)] .", group: 0, tag: "Preposition", reason: "people-who" }
];

// node_modules/compromise/src/2-two/postTagger/model/expressions.js
var expressions_default = [
  { match: "holy (shit|fuck|hell)", tag: "Expression", reason: "swears-expression" },
  { match: "^[(well|so|okay|now)] !#Adjective?", group: 0, tag: "Expression", reason: "well-" },
  { match: "^come on", tag: "Expression", reason: "come-on" },
  { match: "(say|says|said) [sorry]", group: 0, tag: "Expression", reason: "say-sorry" },
  { match: "^(ok|alright|shoot|hell|anyways)", tag: "Expression", reason: "ok-" },
  { match: "^(say && @hasComma)", tag: "Expression", reason: "say-" },
  { match: "^(like && @hasComma)", tag: "Expression", reason: "like-" },
  { match: "^[(dude|man|girl)] #Pronoun", group: 0, tag: "Expression", reason: "dude-i" }
];

// node_modules/compromise/src/2-two/postTagger/model/index.js
var matches2 = [].concat(passive_default, adjective_default, adj_adverb_default, adj_gerund_default2, adj_noun_default2, adverb_default, date_default, date_phrase_default, nouns_default4, noun_gerund_default2, verb_noun_default, money_default, fractions_default, numbers_default, person_phrase_default, ambig_name_default, verbs_default3, adj_verb_default, auxiliary_default, phrasal_default, imperative_default2, adj_gerund_default3, misc_default4, organizations_default2, places_default2, conjunctions_default, expressions_default);
var model_default4 = {
  two: {
    matches: matches2
  }
};

// node_modules/compromise/src/2-two/postTagger/compute/index.js
var net = null;
var postTagger = function(view) {
  const { world: world2 } = view;
  const { model: model5, methods: methods16 } = world2;
  net = net || methods16.one.buildNet(model5.two.matches, world2);
  let document2 = methods16.two.quickSplit(view.document);
  let ptrs = document2.map((terms) => {
    let t2 = terms[0];
    return [t2.index[0], t2.index[1], t2.index[1] + terms.length];
  });
  let m3 = view.update(ptrs);
  m3.cache();
  m3.sweep(net);
  view.uncache();
  return view;
};
var tagger2 = (view) => view.compute(["lexicon", "preTagger", "postTagger"]);
var compute_default10 = { postTagger, tagger: tagger2 };

// node_modules/compromise/src/2-two/postTagger/api.js
var round = (n3) => Math.round(n3 * 100) / 100;
function api_default11(View2) {
  View2.prototype.confidence = function() {
    let sum = 0;
    let count = 0;
    this.docs.forEach((terms) => {
      terms.forEach((term) => {
        count += 1;
        sum += term.confidence || 1;
      });
    });
    if (count === 0) {
      return 1;
    }
    return round(sum / count);
  };
  View2.prototype.tagger = function() {
    return this.compute(["tagger"]);
  };
}

// node_modules/compromise/src/2-two/postTagger/plugin.js
var plugin2 = {
  api: api_default11,
  compute: compute_default10,
  model: model_default4,
  hooks: ["postTagger"]
};
var plugin_default15 = plugin2;

// node_modules/compromise/src/2-two/lazy/maybeMatch.js
var getWords2 = function(net3) {
  return Object.keys(net3.hooks).filter((w) => !w.startsWith("#") && !w.startsWith("%"));
};
var maybeMatch = function(doc, net3) {
  let words = getWords2(net3);
  if (words.length === 0) {
    return doc;
  }
  if (!doc._cache) {
    doc.cache();
  }
  let cache2 = doc._cache;
  return doc.filter((_m, i3) => {
    return words.some((str) => cache2[i3].has(str));
  });
};
var maybeMatch_default = maybeMatch;

// node_modules/compromise/src/2-two/lazy/lazyParse.js
var lazyParse = function(input, reg) {
  let net3 = reg;
  if (typeof reg === "string") {
    net3 = this.buildNet([{ match: reg }]);
  }
  let doc = this.tokenize(input);
  let m3 = maybeMatch_default(doc, net3);
  if (m3.found) {
    m3.compute(["index", "tagger"]);
    return m3.match(reg);
  }
  return doc.none();
};
var lazyParse_default = lazyParse;

// node_modules/compromise/src/2-two/lazy/plugin.js
var plugin_default16 = {
  lib: {
    lazy: lazyParse_default
  }
};

// node_modules/compromise/src/2-two/swap/api/swap-verb.js
var matchVerb = function(m3, lemma) {
  const conjugate2 = m3.methods.two.transform.verb.conjugate;
  let all4 = conjugate2(lemma, m3.model);
  if (m3.has("#Gerund")) {
    return all4.Gerund;
  }
  if (m3.has("#PastTense")) {
    return all4.PastTense;
  }
  if (m3.has("#PresentTense")) {
    return all4.PresentTense;
  }
  if (m3.has("#Gerund")) {
    return all4.Gerund;
  }
  return lemma;
};
var swapVerb = function(vb3, lemma) {
  let str = lemma;
  vb3.forEach((m3) => {
    if (!m3.has("#Infinitive")) {
      str = matchVerb(m3, lemma);
    }
    m3.replaceWith(str);
  });
  return vb3;
};
var swap_verb_default = swapVerb;

// node_modules/compromise/src/2-two/swap/api/swap.js
var swapNoun = function(m3, lemma) {
  let str = lemma;
  if (m3.has("#Plural")) {
    const toPlural = m3.methods.two.transform.noun.toPlural;
    str = toPlural(lemma, m3.model);
  }
  m3.replaceWith(str);
};
var swapAdverb = function(m3, lemma) {
  const { toAdverb: toAdverb2 } = m3.methods.two.transform.adjective;
  let str = lemma;
  let adv = toAdverb2(str);
  if (adv) {
    m3.replaceWith(adv);
  }
};
var swapAdjective = function(m3, lemma) {
  const { toComparative: toComparative3, toSuperlative: toSuperlative3 } = m3.methods.two.transform.adjective;
  let str = lemma;
  if (m3.has("#Comparative")) {
    str = toComparative3(str, m3.model);
  } else if (m3.has("#Superlative")) {
    str = toSuperlative3(str, m3.model);
  }
  if (str) {
    m3.replaceWith(str);
  }
};
var swap = function(from, to, tag) {
  let reg = from.split(/ /g).map((str) => `{${str}}`).join(" ");
  let m3 = this.match(reg);
  if (tag) {
    m3 = m3.if(tag);
  }
  if (m3.has("#Verb")) {
    return swap_verb_default(m3, to);
  }
  if (m3.has("#Noun")) {
    return swapNoun(m3, to);
  }
  if (m3.has("#Adverb")) {
    return swapAdverb(m3, to);
  }
  if (m3.has("#Adjective")) {
    return swapAdjective(m3, to);
  }
  return this;
};
var swap_default = swap;

// node_modules/compromise/src/2-two/swap/plugin.js
var api4 = function(View2) {
  View2.prototype.swap = swap_default;
};
var plugin_default17 = {
  api: api4
};

// node_modules/compromise/src/two.js
one_default.plugin(plugin_default13);
one_default.plugin(plugin_default14);
one_default.plugin(plugin_default15);
one_default.plugin(plugin_default16);
one_default.plugin(plugin_default17);
var two_default = one_default;

// node_modules/compromise/src/3-three/chunker/api/clauses.js
var byComma = function(doc) {
  let commas = doc.match("@hasComma");
  commas = commas.filter((m3) => {
    if (m3.growLeft(".").wordCount() === 1) {
      return false;
    }
    if (m3.growRight(". .").wordCount() === 1) {
      return false;
    }
    let more = m3.grow(".");
    more = more.ifNo("@hasComma @hasComma");
    more = more.ifNo("@hasComma (and|or) .");
    more = more.ifNo("(#City && @hasComma) #Country");
    more = more.ifNo("(#WeekDay && @hasComma) #Date");
    more = more.ifNo("(#Date+ && @hasComma) #Value");
    more = more.ifNo("(#Adjective && @hasComma) #Adjective");
    return more.found;
  });
  return doc.splitAfter(commas);
};
var splitParentheses = function(doc) {
  let matches3 = doc.parentheses();
  matches3 = matches3.filter((m3) => {
    return m3.wordCount() >= 3 && m3.has("#Verb") && m3.has("#Noun");
  });
  return doc.splitOn(matches3);
};
var splitQuotes = function(doc) {
  let matches3 = doc.quotations();
  matches3 = matches3.filter((m3) => {
    return m3.wordCount() >= 3 && m3.has("#Verb") && m3.has("#Noun");
  });
  return doc.splitOn(matches3);
};
var clauses = function(n3) {
  let found = this;
  found = splitParentheses(found);
  found = splitQuotes(found);
  found = byComma(found);
  found = found.splitAfter("(@hasEllipses|@hasSemicolon|@hasDash|@hasColon)");
  found = found.splitAfter("^#Pronoun (said|says)");
  found = found.splitBefore("(said|says) #ProperNoun$");
  found = found.splitBefore(". . if .{4}");
  found = found.splitBefore("and while");
  found = found.splitBefore("now that");
  found = found.splitBefore("ever since");
  found = found.splitBefore("(supposing|although)");
  found = found.splitBefore("even (while|if|though)");
  found = found.splitBefore("(whereas|whose)");
  found = found.splitBefore("as (though|if)");
  found = found.splitBefore("(til|until)");
  if (typeof n3 === "number") {
    found = found.get(n3);
  }
  return found;
};
var clauses_default = clauses;

// node_modules/compromise/src/3-three/chunker/api/chunks.js
var chunks = function(doc) {
  let carry = [];
  let ptr = null;
  let current = null;
  doc.docs.forEach((terms) => {
    terms.forEach((term) => {
      if (term.chunk !== current) {
        if (ptr) {
          ptr[2] = term.index[1];
          carry.push(ptr);
        }
        current = term.chunk;
        ptr = [term.index[0], term.index[1]];
      }
    });
  });
  if (ptr) {
    carry.push(ptr);
  }
  let parts = doc.update(carry);
  parts = parts.map((c2) => {
    if (c2.has("<Noun>")) {
      return c2.nouns();
    }
    return c2;
  });
  return parts;
};
var chunks_default2 = chunks;

// node_modules/compromise/src/3-three/chunker/api/api.js
var api5 = function(View2) {
  class Chunks extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Chunks";
    }
    isVerb() {
      return this.filter((c2) => c2.has("<Verb>"));
    }
    isNoun() {
      return this.filter((c2) => c2.has("<Noun>"));
    }
    isAdjective() {
      return this.filter((c2) => c2.has("<Adjective>"));
    }
    isPivot() {
      return this.filter((c2) => c2.has("<Pivot>"));
    }
    debug() {
      this.toView().debug("chunks");
      return this;
    }
    update(pointer) {
      let m3 = new Chunks(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  View2.prototype.chunks = function(n3) {
    let m3 = chunks_default2(this);
    m3 = m3.getNth(n3);
    return new Chunks(this.document, m3.pointer);
  };
  View2.prototype.clauses = clauses_default;
};
var api_default12 = api5;

// node_modules/compromise/src/3-three/chunker/compute/01-easy.js
var byWord2 = {
  this: "Noun",
  then: "Pivot"
};
var easyMode = function(document2) {
  for (let n3 = 0; n3 < document2.length; n3 += 1) {
    for (let t2 = 0; t2 < document2[n3].length; t2 += 1) {
      let term = document2[n3][t2];
      if (byWord2.hasOwnProperty(term.normal) === true) {
        term.chunk = byWord2[term.normal];
        continue;
      }
      if (term.tags.has("Verb")) {
        term.chunk = "Verb";
        continue;
      }
      if (term.tags.has("Noun") || term.tags.has("Determiner")) {
        term.chunk = "Noun";
        continue;
      }
      if (term.tags.has("Value")) {
        term.chunk = "Noun";
        continue;
      }
      if (term.tags.has("QuestionWord")) {
        term.chunk = "Pivot";
        continue;
      }
    }
  }
};
var easy_default = easyMode;

// node_modules/compromise/src/3-three/chunker/compute/02-neighbours.js
var byNeighbour = function(document2) {
  for (let n3 = 0; n3 < document2.length; n3 += 1) {
    for (let t2 = 0; t2 < document2[n3].length; t2 += 1) {
      let term = document2[n3][t2];
      if (term.chunk) {
        continue;
      }
      let onRight = document2[n3][t2 + 1];
      let onLeft = document2[n3][t2 - 1];
      if (term.tags.has("Adjective")) {
        if (onLeft && onLeft.tags.has("Copula")) {
          term.chunk = "Adjective";
          continue;
        }
        if (onLeft && onLeft.tags.has("Determiner")) {
          term.chunk = "Noun";
          continue;
        }
        if (onRight && onRight.tags.has("Noun")) {
          term.chunk = "Noun";
          continue;
        }
        continue;
      }
      if (term.tags.has("Adverb") || term.tags.has("Negative")) {
        if (onLeft && onLeft.tags.has("Adjective")) {
          term.chunk = "Adjective";
          continue;
        }
        if (onLeft && onLeft.tags.has("Verb")) {
          term.chunk = "Verb";
          continue;
        }
        if (onRight && onRight.tags.has("Adjective")) {
          term.chunk = "Adjective";
          continue;
        }
        if (onRight && onRight.tags.has("Verb")) {
          term.chunk = "Verb";
          continue;
        }
      }
    }
  }
};
var neighbours_default3 = byNeighbour;

// node_modules/compromise/src/3-three/chunker/compute/03-matcher.js
var rules = [
  { match: "[that] #Determiner #Noun", group: 0, chunk: "Pivot" },
  { match: "#PastTense [that]", group: 0, chunk: "Pivot" },
  { match: "[so] #Determiner", group: 0, chunk: "Pivot" },
  { match: "#Copula #Adverb+? [#Adjective]", group: 0, chunk: "Adjective" },
  { match: "#Adjective and #Adjective", chunk: "Adjective" },
  { match: "#Adverb+ and #Adverb #Verb", chunk: "Verb" },
  { match: "#Gerund #Adjective", chunk: "Verb" },
  { match: "#Gerund to #Verb", chunk: "Verb" },
  { match: "#PresentTense and #PresentTense", chunk: "Verb" },
  { match: "#Adverb #Negative", chunk: "Verb" },
  { match: "(want|wants|wanted) to #Infinitive", chunk: "Verb" },
  { match: "#Verb #Reflexive", chunk: "Verb" },
  { match: "#PresentTense [#Pronoun] #Determiner", group: 0, chunk: "Verb" },
  { match: "#Verb [to] #Adverb? #Infinitive", group: 0, chunk: "Verb" },
  { match: "[#Preposition] #Gerund", group: 0, chunk: "Verb" },
  { match: "#Noun of #Determiner? #Noun", chunk: "Noun" },
  { match: "#Noun in #Determiner? #Noun", chunk: "Noun" },
  { match: "#Singular and #Determiner? #Singular", chunk: "Noun" }
];
var net2 = null;
var matcher = function(view, _2, world2) {
  const { methods: methods16 } = world2;
  net2 = net2 || methods16.one.buildNet(rules, world2);
  view.sweep(net2);
};
var matcher_default = matcher;

// node_modules/compromise/src/3-three/chunker/compute/04-fallback.js
var setChunk = function(term, chunk) {
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2.DEBUG_CHUNKS) {
    let str = (term.normal + "'").padEnd(8);
    console.log(`  | '${str}  \u2192  \x1B[34m${chunk.padEnd(12)}\x1B[0m \x1B[2m -fallback- \x1B[0m`);
  }
  term.chunk = chunk;
};
var fallback = function(document2) {
  for (let n3 = 0; n3 < document2.length; n3 += 1) {
    for (let t2 = 0; t2 < document2[n3].length; t2 += 1) {
      let term = document2[n3][t2];
      if (term.chunk === void 0) {
        if (term.tags.has("Conjunction")) {
          setChunk(term, "Pivot");
        } else if (term.tags.has("Preposition")) {
          setChunk(term, "Pivot");
        } else if (term.tags.has("Adverb")) {
          setChunk(term, "Verb");
        } else {
          term.chunk = "Noun";
        }
      }
    }
  }
};
var fallback_default2 = fallback;

// node_modules/compromise/src/3-three/chunker/compute/05-fixUp.js
var fixUp = function(docs) {
  let byChunk = [];
  let current = null;
  docs.forEach((terms) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let term = terms[i3];
      if (current && term.chunk === current) {
        byChunk[byChunk.length - 1].terms.push(term);
      } else {
        byChunk.push({ chunk: term.chunk, terms: [term] });
        current = term.chunk;
      }
    }
  });
  byChunk.forEach((c2) => {
    if (c2.chunk === "Verb") {
      const hasVerb = c2.terms.find((t2) => t2.tags.has("Verb"));
      if (!hasVerb) {
        c2.terms.forEach((t2) => t2.chunk = null);
      }
    }
  });
};
var fixUp_default = fixUp;

// node_modules/compromise/src/3-three/chunker/compute/index.js
var findChunks = function(view) {
  const { document: document2, world: world2 } = view;
  easy_default(document2);
  neighbours_default3(document2);
  matcher_default(view, document2, world2);
  fallback_default2(document2, world2);
  fixUp_default(document2, world2);
};
var compute_default11 = { chunks: findChunks };

// node_modules/compromise/src/3-three/chunker/plugin.js
var plugin_default18 = {
  compute: compute_default11,
  api: api_default12,
  hooks: ["chunks"]
};

// node_modules/compromise/src/3-three/misc/acronyms/index.js
var hasPeriod = /\./g;
var api6 = function(View2) {
  class Acronyms extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Acronyms";
    }
    strip() {
      this.docs.forEach((terms) => {
        terms.forEach((term) => {
          term.text = term.text.replace(hasPeriod, "");
          term.normal = term.normal.replace(hasPeriod, "");
        });
      });
      return this;
    }
    addPeriods() {
      this.docs.forEach((terms) => {
        terms.forEach((term) => {
          term.text = term.text.replace(hasPeriod, "");
          term.normal = term.normal.replace(hasPeriod, "");
          term.text = term.text.split("").join(".") + ".";
          term.normal = term.normal.split("").join(".") + ".";
        });
      });
      return this;
    }
  }
  View2.prototype.acronyms = function(n3) {
    let m3 = this.match("#Acronym");
    m3 = m3.getNth(n3);
    return new Acronyms(m3.document, m3.pointer);
  };
};
var acronyms_default2 = api6;

// node_modules/compromise/src/3-three/misc/adjectives/index.js
var toRoot2 = function(adj) {
  const { fromComparative: fromComparative3, fromSuperlative: fromSuperlative3 } = adj.methods.two.transform.adjective;
  let str = adj.text("normal");
  if (adj.has("#Comparative")) {
    return fromComparative3(str, adj.model);
  }
  if (adj.has("#Superlative")) {
    return fromSuperlative3(str, adj.model);
  }
  return str;
};
var api7 = function(View2) {
  class Adjectives extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Adjectives";
    }
    json(opts2 = {}) {
      const { toAdverb: toAdverb2, toNoun: toNoun2, toSuperlative: toSuperlative3, toComparative: toComparative3 } = this.methods.two.transform.adjective;
      opts2.normal = true;
      return this.map((m3) => {
        let json = m3.toView().json(opts2)[0] || {};
        let str = toRoot2(m3);
        json.adjective = {
          adverb: toAdverb2(str),
          noun: toNoun2(str),
          superlative: toSuperlative3(str, this.model),
          comparative: toComparative3(str, this.model)
        };
        return json;
      }, []);
    }
    adverbs() {
      return this.before("#Adverb+$").concat(this.after("^#Adverb+"));
    }
    conjugate(n3) {
      const { toComparative: toComparative3, toSuperlative: toSuperlative3, toNoun: toNoun2, toAdverb: toAdverb2 } = this.methods.two.transform.adjective;
      return this.getNth(n3).map((adj) => {
        let root = toRoot2(adj);
        return {
          Adjective: root,
          Comparative: toComparative3(root, this.model),
          Superlative: toSuperlative3(root, this.model),
          Noun: toNoun2(root, this.model),
          Adverb: toAdverb2(root, this.model)
        };
      }, []);
    }
    toComparative(n3) {
      const { toComparative: toComparative3 } = this.methods.two.transform.adjective;
      return this.getNth(n3).map((adj) => {
        let root = toRoot2(adj);
        let str = toComparative3(root, this.model);
        return adj.replaceWith(str);
      });
    }
    toSuperlative(n3) {
      const { toSuperlative: toSuperlative3 } = this.methods.two.transform.adjective;
      return this.getNth(n3).map((adj) => {
        let root = toRoot2(adj);
        let str = toSuperlative3(root, this.model);
        return adj.replaceWith(str);
      });
    }
    toAdverb(n3) {
      const { toAdverb: toAdverb2 } = this.methods.two.transform.adjective;
      return this.getNth(n3).map((adj) => {
        let root = toRoot2(adj);
        let str = toAdverb2(root, this.model);
        return adj.replaceWith(str);
      });
    }
    toNoun(n3) {
      const { toNoun: toNoun2 } = this.methods.two.transform.adjective;
      return this.getNth(n3).map((adj) => {
        let root = toRoot2(adj);
        let str = toNoun2(root, this.model);
        return adj.replaceWith(str);
      });
    }
  }
  View2.prototype.adjectives = function(n3) {
    let m3 = this.match("#Adjective");
    m3 = m3.getNth(n3);
    return new Adjectives(m3.document, m3.pointer);
  };
  View2.prototype.superlatives = function(n3) {
    let m3 = this.match("#Superlative");
    m3 = m3.getNth(n3);
    return new Adjectives(m3.document, m3.pointer);
  };
  View2.prototype.comparatives = function(n3) {
    let m3 = this.match("#Comparative");
    m3 = m3.getNth(n3);
    return new Adjectives(m3.document, m3.pointer);
  };
};
var adjectives_default2 = api7;

// node_modules/compromise/src/3-three/misc/adverbs/index.js
var api8 = function(View2) {
  class Adverbs extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Adverbs";
    }
    json(opts2 = {}) {
      const fromAdverb = this.methods.two.transform.adjective.fromAdverb;
      opts2.normal = true;
      return this.map((m3) => {
        let json = m3.toView().json(opts2)[0] || {};
        json.adverb = {
          adjective: fromAdverb(json.normal)
        };
        return json;
      }, []);
    }
  }
  View2.prototype.adverbs = function(n3) {
    let m3 = this.match("#Adverb");
    m3 = m3.getNth(n3);
    return new Adverbs(m3.document, m3.pointer);
  };
};
var adverbs_default = api8;

// node_modules/compromise/src/3-three/misc/parentheses/fns.js
var hasOpen2 = /\(/;
var hasClosed2 = /\)/;
var findEnd = function(terms, i3) {
  for (; i3 < terms.length; i3 += 1) {
    if (terms[i3].post && hasClosed2.test(terms[i3].post)) {
      return i3;
    }
  }
  return null;
};
var find2 = function(doc) {
  let ptrs = [];
  doc.docs.forEach((terms) => {
    let isOpen = false;
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let term = terms[i3];
      if (!isOpen && term.pre && hasOpen2.test(term.pre)) {
        let end2 = findEnd(terms, i3);
        if (end2 !== null) {
          let [n3, start2] = terms[i3].index;
          ptrs.push([n3, start2, end2 + 1, terms[i3].id]);
          i3 = end2;
        }
      }
    }
  });
  return doc.update(ptrs);
};
var strip = function(m3) {
  m3.docs.forEach((terms) => {
    terms[0].pre = terms[0].pre.replace(hasOpen2, "");
    let last = terms[terms.length - 1];
    last.post = last.post.replace(hasClosed2, "");
  });
  return m3;
};

// node_modules/compromise/src/3-three/misc/parentheses/index.js
var api9 = function(View2) {
  class Parentheses extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Possessives";
    }
    strip() {
      return strip(this);
    }
  }
  View2.prototype.parentheses = function(n3) {
    let m3 = find2(this);
    m3 = m3.getNth(n3);
    return new Parentheses(m3.document, m3.pointer);
  };
};
var parentheses_default = api9;

// node_modules/compromise/src/3-three/misc/possessives/index.js
var apostropheS2 = /'s$/;
var find3 = function(doc) {
  let m3 = doc.match("#Possessive+");
  if (m3.has("#Person")) {
    m3 = m3.growLeft("#Person+");
  }
  if (m3.has("#Place")) {
    m3 = m3.growLeft("#Place+");
  }
  if (m3.has("#Organization")) {
    m3 = m3.growLeft("#Organization+");
  }
  return m3;
};
var api10 = function(View2) {
  class Possessives extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Possessives";
    }
    strip() {
      this.docs.forEach((terms) => {
        terms.forEach((term) => {
          term.text = term.text.replace(apostropheS2, "");
          term.normal = term.normal.replace(apostropheS2, "");
        });
      });
      return this;
    }
  }
  View2.prototype.possessives = function(n3) {
    let m3 = find3(this);
    m3 = m3.getNth(n3);
    return new Possessives(m3.document, m3.pointer);
  };
};
var possessives_default = api10;

// node_modules/compromise/src/3-three/misc/quotations/fns.js
var pairs2 = {
  '"': '"',
  "\uFF02": "\uFF02",
  "'": "'",
  "\u201C": "\u201D",
  "\u2018": "\u2019",
  "\u201F": "\u201D",
  "\u201B": "\u2019",
  "\u201E": "\u201D",
  "\u2E42": "\u201D",
  "\u201A": "\u2019",
  "\xAB": "\xBB",
  "\u2039": "\u203A",
  "\u2035": "\u2032",
  "\u2036": "\u2033",
  "\u2037": "\u2034",
  "\u301D": "\u301E",
  "`": "\xB4",
  "\u301F": "\u301E"
};
var hasOpen3 = RegExp("(" + Object.keys(pairs2).join("|") + ")");
var hasClosed3 = RegExp("(" + Object.values(pairs2).join("|") + ")");
var findEnd2 = function(terms, i3) {
  const have = terms[i3].pre.match(hasOpen3)[0] || "";
  if (!have || !pairs2[have]) {
    return null;
  }
  const want = pairs2[have];
  for (; i3 < terms.length; i3 += 1) {
    if (terms[i3].post && terms[i3].post.match(want)) {
      return i3;
    }
  }
  return null;
};
var find4 = function(doc) {
  let ptrs = [];
  doc.docs.forEach((terms) => {
    let isOpen = false;
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let term = terms[i3];
      if (!isOpen && term.pre && hasOpen3.test(term.pre)) {
        let end2 = findEnd2(terms, i3);
        if (end2 !== null) {
          let [n3, start2] = terms[i3].index;
          ptrs.push([n3, start2, end2 + 1, terms[i3].id]);
          i3 = end2;
        }
      }
    }
  });
  return doc.update(ptrs);
};
var strip2 = function(m3) {
  m3.docs.forEach((terms) => {
    terms[0].pre = terms[0].pre.replace(hasOpen3, "");
    let lastTerm = terms[terms.length - 1];
    lastTerm.post = lastTerm.post.replace(hasClosed3, "");
  });
};

// node_modules/compromise/src/3-three/misc/quotations/index.js
var api11 = function(View2) {
  class Quotations extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Possessives";
    }
    strip() {
      return strip2(this);
    }
  }
  View2.prototype.quotations = function(n3) {
    let m3 = find4(this);
    m3 = m3.getNth(n3);
    return new Quotations(m3.document, m3.pointer);
  };
};
var quotations_default = api11;

// node_modules/compromise/src/3-three/misc/selections/index.js
var phoneNumbers = function(n3) {
  let m3 = this.splitAfter("@hasComma");
  m3 = m3.match("#PhoneNumber+");
  m3 = m3.getNth(n3);
  return m3;
};
var selections = [
  ["hyphenated", "@hasHyphen ."],
  ["hashTags", "#HashTag"],
  ["emails", "#Email"],
  ["emoji", "#Emoji"],
  ["emoticons", "#Emoticon"],
  ["atMentions", "#AtMention"],
  ["urls", "#Url"],
  ["conjunctions", "#Conjunction"],
  ["prepositions", "#Preposition"],
  ["abbreviations", "#Abbreviation"],
  ["honorifics", "#Honorific"]
];
var aliases2 = [
  ["emojis", "emoji"],
  ["atmentions", "atMentions"]
];
var addMethods = function(View2) {
  selections.forEach((a2) => {
    View2.prototype[a2[0]] = function(n3) {
      let m3 = this.match(a2[1]);
      return typeof n3 === "number" ? m3.get(n3) : m3;
    };
  });
  View2.prototype.phoneNumbers = phoneNumbers;
  aliases2.forEach((a2) => {
    View2.prototype[a2[0]] = View2.prototype[a2[1]];
  });
};
var selections_default = addMethods;

// node_modules/compromise/src/3-three/misc/plugin.js
var plugin_default19 = {
  api: function(View2) {
    acronyms_default2(View2);
    adjectives_default2(View2);
    adverbs_default(View2);
    parentheses_default(View2);
    possessives_default(View2);
    quotations_default(View2);
    selections_default(View2);
  }
};

// node_modules/compromise/src/3-three/normalize/methods.js
var termLoop2 = function(view, cb) {
  view.docs.forEach((terms) => {
    terms.forEach(cb);
  });
};
var methods_default10 = {
  "case": (doc) => {
    termLoop2(doc, (term) => {
      term.text = term.text.toLowerCase();
    });
  },
  "unicode": (doc) => {
    const world2 = doc.world;
    const killUnicode2 = world2.methods.one.killUnicode;
    termLoop2(doc, (term) => term.text = killUnicode2(term.text, world2));
  },
  "whitespace": (doc) => {
    termLoop2(doc, (term) => {
      term.post = term.post.replace(/\s+/g, " ");
      term.post = term.post.replace(/\s([.,?!:;])/g, "$1");
      term.pre = term.pre.replace(/\s+/g, "");
    });
  },
  "punctuation": (doc) => {
    termLoop2(doc, (term) => {
      term.post = term.post.replace(/[–—-]/g, " ");
      term.post = term.post.replace(/[,:;]/g, "");
      term.post = term.post.replace(/\.{2,}/g, "");
      term.post = term.post.replace(/\?{2,}/g, "?");
      term.post = term.post.replace(/!{2,}/g, "!");
      term.post = term.post.replace(/\?!+/g, "?");
    });
    let docs = doc.docs;
    let terms = docs[docs.length - 1];
    if (terms && terms.length > 0) {
      let lastTerm = terms[terms.length - 1];
      lastTerm.post = lastTerm.post.replace(/ /g, "");
    }
  },
  "contractions": (doc) => {
    doc.contractions().expand();
  },
  "acronyms": (doc) => {
    doc.acronyms().strip();
  },
  "parentheses": (doc) => {
    doc.parentheses().strip();
  },
  "possessives": (doc) => {
    doc.possessives().strip();
  },
  "quotations": (doc) => {
    doc.quotations().strip();
  },
  "emoji": (doc) => {
    doc.emojis().remove();
  },
  "honorifics": (doc) => {
    doc.match("#Honorific+ #Person").honorifics().remove();
  },
  "adverbs": (doc) => {
    doc.adverbs().remove();
  },
  "nouns": (doc) => {
    doc.nouns().toSingular();
  },
  "verbs": (doc) => {
    doc.verbs().toInfinitive();
  },
  "numbers": (doc) => {
    doc.numbers().toNumber();
  }
};

// node_modules/compromise/src/3-three/normalize/api.js
var split2 = (str) => {
  return str.split("|").reduce((h2, k2) => {
    h2[k2] = true;
    return h2;
  }, {});
};
var light = "unicode|punctuation|whitespace|acronyms";
var medium = "|case|contractions|parentheses|quotations|emoji|honorifics";
var heavy = "|possessives|adverbs|nouns|verbs";
var presets = {
  light: split2(light),
  medium: split2(light + medium),
  heavy: split2(light + medium + heavy)
};
function api_default13(View2) {
  View2.prototype.normalize = function(opts2 = "light") {
    if (typeof opts2 === "string") {
      opts2 = presets[opts2];
    }
    Object.keys(opts2).forEach((fn) => {
      if (methods_default10.hasOwnProperty(fn)) {
        methods_default10[fn](this, opts2[fn]);
      }
    });
    return this;
  };
}

// node_modules/compromise/src/3-three/normalize/plugin.js
var plugin_default20 = {
  api: api_default13
};

// node_modules/compromise/src/3-three/nouns/find.js
var findNouns = function(doc) {
  let m3 = doc.match("<Noun>");
  let commas = m3.match("@hasComma");
  commas = commas.not("#Place");
  if (commas.found) {
    m3 = m3.splitAfter(commas);
  }
  m3 = m3.splitOn("#Expression");
  m3 = m3.splitOn("(he|she|we|you|they|i)");
  m3 = m3.splitOn("(#Noun|#Adjective) [(he|him|she|it)]", 0);
  m3 = m3.splitOn("[(he|him|she|it)] (#Determiner|#Value)", 0);
  m3 = m3.splitBefore("#Noun [(the|a|an)] #Adjective? #Noun", 0);
  m3 = m3.splitOn("[(here|there)] #Noun", 0);
  m3 = m3.splitOn("[#Noun] (here|there)", 0);
  m3 = m3.splitBefore("(our|my|their|your)");
  m3 = m3.if("#Noun");
  return m3;
};
var find_default = findNouns;

// node_modules/compromise/src/3-three/nouns/api/isSubordinate.js
var list2 = [
  "after",
  "although",
  "as if",
  "as long as",
  "as",
  "because",
  "before",
  "even if",
  "even though",
  "ever since",
  "if",
  "in order that",
  "provided that",
  "since",
  "so that",
  "than",
  "that",
  "though",
  "unless",
  "until",
  "what",
  "whatever",
  "when",
  "whenever",
  "where",
  "whereas",
  "wherever",
  "whether",
  "which",
  "whichever",
  "who",
  "whoever",
  "whom",
  "whomever",
  "whose"
];
var isSubordinate = function(m3) {
  if (m3.before("#Preposition$").found) {
    return true;
  }
  let leadIn = m3.before();
  if (!leadIn.found) {
    return false;
  }
  for (let i3 = 0; i3 < list2.length; i3 += 1) {
    if (m3.has(list2[i3])) {
      return true;
    }
  }
  return false;
};
var isSubordinate_default = isSubordinate;

// node_modules/compromise/src/3-three/nouns/api/isPlural.js
var notPlural2 = "(#Pronoun|#Place|#Value|#Person|#Uncountable|#Month|#WeekDay|#Holiday|#Possessive)";
var isPlural2 = function(m3, root) {
  if (m3.has("#Plural")) {
    return true;
  }
  if (m3.has("#Noun and #Noun")) {
    return true;
  }
  if (m3.has("(we|they)")) {
    return true;
  }
  if (root.has(notPlural2) === true) {
    return false;
  }
  if (m3.has("#Singular")) {
    return false;
  }
  let str = root.text("normal");
  return str.length > 3 && str.endsWith("s") && !str.endsWith("ss");
};
var isPlural_default = isPlural2;

// node_modules/compromise/src/3-three/nouns/api/parse.js
var getRoot2 = function(m3) {
  let tmp = m3.clone();
  tmp = tmp.match("#Noun+");
  tmp = tmp.remove("(#Adjective|#Preposition|#Determiner|#Value)");
  tmp = tmp.not("#Possessive");
  tmp = tmp.first();
  if (!tmp.found) {
    return m3;
  }
  return tmp;
};
var parseNoun = function(m3) {
  let root = getRoot2(m3);
  return {
    determiner: m3.match("#Determiner").eq(0),
    adjectives: m3.match("#Adjective"),
    number: m3.values(),
    isPlural: isPlural_default(m3, root),
    isSubordinate: isSubordinate_default(m3),
    root
  };
};
var parse_default3 = parseNoun;

// node_modules/compromise/src/3-three/nouns/api/toJSON.js
var toText2 = (m3) => m3.text();
var toArray3 = (m3) => m3.json({ terms: false, normal: true }).map((s3) => s3.normal);
var getNum = function(m3) {
  let num = null;
  if (!m3.found) {
    return num;
  }
  let val = m3.values(0);
  if (val.found) {
    let obj = val.parse()[0] || {};
    return obj.num;
  }
  return num;
};
var toJSON2 = function(m3) {
  let res = parse_default3(m3);
  return {
    root: toText2(res.root),
    number: getNum(res.number),
    determiner: toText2(res.determiner),
    adjectives: toArray3(res.adjectives),
    isPlural: res.isPlural,
    isSubordinate: res.isSubordinate
  };
};
var toJSON_default = toJSON2;

// node_modules/compromise/src/3-three/nouns/api/toPlural.js
var keep = { tags: true };
var hasPlural = function(parsed) {
  let { root } = parsed;
  if (root.has("^(#Uncountable|#Possessive|#ProperNoun|#Place|#Pronoun|#Acronym)+$")) {
    return false;
  }
  return true;
};
var nounToPlural = function(m3, parsed) {
  if (parsed.isPlural === true) {
    return m3;
  }
  if (!hasPlural(parsed)) {
    return m3;
  }
  const { methods: methods16, model: model5 } = m3.world;
  const { toPlural } = methods16.two.transform.noun;
  let str = parsed.root.text({ keepPunct: false });
  let plural2 = toPlural(str, model5);
  m3.match(parsed.root).replaceWith(plural2, keep).tag("Plural", "toPlural");
  if (parsed.determiner.has("(a|an)")) {
    m3.remove(parsed.determiner);
  }
  let copula = parsed.root.after("not? #Adverb+? [#Copula]", 0);
  if (copula.found) {
    if (copula.has("is")) {
      m3.replace(copula, "are");
    } else if (copula.has("was")) {
      m3.replace(copula, "were");
    }
  }
  return m3;
};
var toPlural_default2 = nounToPlural;

// node_modules/compromise/src/3-three/nouns/api/toSingular.js
var keep2 = { tags: true };
var nounToSingular = function(m3, parsed) {
  if (parsed.isPlural === false) {
    return m3;
  }
  const { methods: methods16, model: model5 } = m3.world;
  const { toSingular: toSingular2 } = methods16.two.transform.noun;
  let str = parsed.root.text("normal");
  let single = toSingular2(str, model5);
  m3.replace(parsed.root, single, keep2).tag("Singular", "toPlural");
  return m3;
};
var toSingular_default2 = nounToSingular;

// node_modules/compromise/src/3-three/nouns/api/api.js
var api12 = function(View2) {
  class Nouns extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Nouns";
    }
    parse(n3) {
      return this.getNth(n3).map(parse_default3);
    }
    json(n3) {
      let opts2 = typeof n3 === "object" ? n3 : {};
      return this.getNth(n3).map((m3) => {
        let json = m3.toView().json(opts2)[0] || {};
        if (opts2 && opts2.noun !== true) {
          json.noun = toJSON_default(m3);
        }
        return json;
      }, []);
    }
    isPlural(n3) {
      let res = this.filter((m3) => parse_default3(m3).isPlural);
      return res.getNth(n3);
    }
    isSingular(n3) {
      let res = this.filter((m3) => !parse_default3(m3).isPlural);
      return res.getNth(n3);
    }
    adjectives(n3) {
      let res = this.update([]);
      this.forEach((m3) => {
        let adj = parse_default3(m3).adjectives;
        if (adj.found) {
          res = res.concat(adj);
        }
      });
      return res.getNth(n3);
    }
    toPlural(n3) {
      return this.getNth(n3).map((m3) => {
        return toPlural_default2(m3, parse_default3(m3));
      });
    }
    toSingular(n3) {
      return this.getNth(n3).map((m3) => {
        let res = parse_default3(m3);
        return toSingular_default2(m3, res);
      });
    }
    update(pointer) {
      let m3 = new Nouns(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  View2.prototype.nouns = function(n3) {
    let m3 = find_default(this);
    m3 = m3.getNth(n3);
    return new Nouns(this.document, m3.pointer);
  };
};
var api_default14 = api12;

// node_modules/compromise/src/3-three/nouns/plugin.js
var plugin_default21 = {
  api: api_default14
};

// node_modules/compromise/src/3-three/numbers/fractions/find.js
var findFractions = function(doc, n3) {
  let m3 = doc.match("#Fraction+");
  m3 = m3.filter((r2) => {
    return !r2.lookBehind("#Value and$").found;
  });
  m3 = m3.notIf("#Value seconds");
  if (typeof n3 === "number") {
    m3 = m3.eq(n3);
  }
  return m3;
};
var find_default2 = findFractions;

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/findModifiers.js
var findModifiers = (str) => {
  const mults = [
    {
      reg: /^(minus|negative)[\s-]/i,
      mult: -1
    },
    {
      reg: /^(a\s)?half[\s-](of\s)?/i,
      mult: 0.5
    }
  ];
  for (let i3 = 0; i3 < mults.length; i3++) {
    if (mults[i3].reg.test(str) === true) {
      return {
        amount: mults[i3].mult,
        str: str.replace(mults[i3].reg, "")
      };
    }
  }
  return {
    amount: 1,
    str
  };
};
var findModifiers_default = findModifiers;

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/data.js
var data_default3 = {
  ones: {
    zeroth: 0,
    first: 1,
    second: 2,
    third: 3,
    fourth: 4,
    fifth: 5,
    sixth: 6,
    seventh: 7,
    eighth: 8,
    ninth: 9,
    zero: 0,
    one: 1,
    two: 2,
    three: 3,
    four: 4,
    five: 5,
    six: 6,
    seven: 7,
    eight: 8,
    nine: 9
  },
  teens: {
    tenth: 10,
    eleventh: 11,
    twelfth: 12,
    thirteenth: 13,
    fourteenth: 14,
    fifteenth: 15,
    sixteenth: 16,
    seventeenth: 17,
    eighteenth: 18,
    nineteenth: 19,
    ten: 10,
    eleven: 11,
    twelve: 12,
    thirteen: 13,
    fourteen: 14,
    fifteen: 15,
    sixteen: 16,
    seventeen: 17,
    eighteen: 18,
    nineteen: 19
  },
  tens: {
    twentieth: 20,
    thirtieth: 30,
    fortieth: 40,
    fourtieth: 40,
    fiftieth: 50,
    sixtieth: 60,
    seventieth: 70,
    eightieth: 80,
    ninetieth: 90,
    twenty: 20,
    thirty: 30,
    forty: 40,
    fourty: 40,
    fifty: 50,
    sixty: 60,
    seventy: 70,
    eighty: 80,
    ninety: 90
  },
  multiples: {
    hundredth: 100,
    thousandth: 1e3,
    millionth: 1e6,
    billionth: 1e9,
    trillionth: 1e12,
    quadrillionth: 1e15,
    quintillionth: 1e18,
    sextillionth: 1e21,
    septillionth: 1e24,
    hundred: 100,
    thousand: 1e3,
    million: 1e6,
    billion: 1e9,
    trillion: 1e12,
    quadrillion: 1e15,
    quintillion: 1e18,
    sextillion: 1e21,
    septillion: 1e24,
    grand: 1e3
  }
};

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/validate.js
var isValid = (w, has2) => {
  if (data_default3.ones.hasOwnProperty(w)) {
    if (has2.ones || has2.teens) {
      return false;
    }
  } else if (data_default3.teens.hasOwnProperty(w)) {
    if (has2.ones || has2.teens || has2.tens) {
      return false;
    }
  } else if (data_default3.tens.hasOwnProperty(w)) {
    if (has2.ones || has2.teens || has2.tens) {
      return false;
    }
  }
  return true;
};
var validate_default2 = isValid;

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/parseDecimals.js
var parseDecimals = function(arr) {
  let str = "0.";
  for (let i3 = 0; i3 < arr.length; i3++) {
    let w = arr[i3];
    if (data_default3.ones.hasOwnProperty(w) === true) {
      str += data_default3.ones[w];
    } else if (data_default3.teens.hasOwnProperty(w) === true) {
      str += data_default3.teens[w];
    } else if (data_default3.tens.hasOwnProperty(w) === true) {
      str += data_default3.tens[w];
    } else if (/^[0-9]$/.test(w) === true) {
      str += w;
    } else {
      return 0;
    }
  }
  return parseFloat(str);
};
var parseDecimals_default = parseDecimals;

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/parseNumeric.js
var parseNumeric = (str) => {
  str = str.replace(/1st$/, "1");
  str = str.replace(/2nd$/, "2");
  str = str.replace(/3rd$/, "3");
  str = str.replace(/([4567890])r?th$/, "$1");
  str = str.replace(/^[$€¥£¢]/, "");
  str = str.replace(/[%$€¥£¢]$/, "");
  str = str.replace(/,/g, "");
  str = str.replace(/([0-9])([a-z\u00C0-\u00FF]{1,2})$/, "$1");
  return str;
};
var parseNumeric_default = parseNumeric;

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/index.js
var improperFraction = /^([0-9,. ]+)\/([0-9,. ]+)$/;
var casualForms = {
  "a few": 3,
  "a couple": 2,
  "a dozen": 12,
  "two dozen": 24,
  zero: 0
};
var section_sum = (obj) => {
  return Object.keys(obj).reduce((sum, k2) => {
    sum += obj[k2];
    return sum;
  }, 0);
};
var parse4 = function(str) {
  if (casualForms.hasOwnProperty(str) === true) {
    return casualForms[str];
  }
  if (str === "a" || str === "an") {
    return 1;
  }
  const modifier = findModifiers_default(str);
  str = modifier.str;
  let last_mult = null;
  let has2 = {};
  let sum = 0;
  let isNegative = false;
  const terms = str.split(/[ -]/);
  for (let i3 = 0; i3 < terms.length; i3++) {
    let w = terms[i3];
    w = parseNumeric_default(w);
    if (!w || w === "and") {
      continue;
    }
    if (w === "-" || w === "negative") {
      isNegative = true;
      continue;
    }
    if (w.charAt(0) === "-") {
      isNegative = true;
      w = w.substring(1);
    }
    if (w === "point") {
      sum += section_sum(has2);
      sum += parseDecimals_default(terms.slice(i3 + 1, terms.length));
      sum *= modifier.amount;
      return sum;
    }
    const fm = w.match(improperFraction);
    if (fm) {
      const num = parseFloat(fm[1].replace(/[, ]/g, ""));
      const denom = parseFloat(fm[2].replace(/[, ]/g, ""));
      if (denom) {
        sum += num / denom || 0;
      }
      continue;
    }
    if (data_default3.tens.hasOwnProperty(w)) {
      if (has2.ones && Object.keys(has2).length === 1) {
        sum = has2.ones * 100;
        has2 = {};
      }
    }
    if (validate_default2(w, has2) === false) {
      return null;
    }
    if (/^[0-9.]+$/.test(w)) {
      has2.ones = parseFloat(w);
    } else if (data_default3.ones.hasOwnProperty(w) === true) {
      has2.ones = data_default3.ones[w];
    } else if (data_default3.teens.hasOwnProperty(w) === true) {
      has2.teens = data_default3.teens[w];
    } else if (data_default3.tens.hasOwnProperty(w) === true) {
      has2.tens = data_default3.tens[w];
    } else if (data_default3.multiples.hasOwnProperty(w) === true) {
      let mult = data_default3.multiples[w];
      if (mult === last_mult) {
        return null;
      }
      if (mult === 100 && terms[i3 + 1] !== void 0) {
        const w2 = terms[i3 + 1];
        if (data_default3.multiples[w2]) {
          mult *= data_default3.multiples[w2];
          i3 += 1;
        }
      }
      if (last_mult === null || mult < last_mult) {
        sum += (section_sum(has2) || 1) * mult;
        last_mult = mult;
        has2 = {};
      } else {
        sum += section_sum(has2);
        last_mult = mult;
        sum = (sum || 1) * mult;
        has2 = {};
      }
    }
  }
  sum += section_sum(has2);
  sum *= modifier.amount;
  sum *= isNegative ? -1 : 1;
  if (sum === 0 && Object.keys(has2).length === 0) {
    return null;
  }
  return sum;
};
var toNumber_default = parse4;

// node_modules/compromise/src/3-three/numbers/fractions/parse.js
var endS = /s$/;
var parseNumber = function(m3) {
  let str = m3.text("reduced");
  return toNumber_default(str);
};
var mapping2 = {
  half: 2,
  halve: 2,
  quarter: 4
};
var slashForm = function(m3) {
  let str = m3.text("reduced");
  let found = str.match(/^([-+]?[0-9]+)\/([-+]?[0-9]+)(st|nd|rd|th)?s?$/);
  if (found && found[1] && found[0]) {
    return {
      numerator: Number(found[1]),
      denominator: Number(found[2])
    };
  }
  return null;
};
var nOutOfN = function(m3) {
  let found = m3.match("[<num>#Value+] out of every? [<den>#Value+]");
  if (found.found !== true) {
    return null;
  }
  let { num, den } = found.groups();
  if (!num || !den) {
    return null;
  }
  num = parseNumber(num);
  den = parseNumber(den);
  if (!num || !den) {
    return null;
  }
  if (typeof num === "number" && typeof den === "number") {
    return {
      numerator: num,
      denominator: den
    };
  }
  return null;
};
var nOrinalth = function(m3) {
  let found = m3.match("[<num>(#Cardinal|a)+] [<den>#Fraction+]");
  if (found.found !== true) {
    return null;
  }
  let { num, den } = found.groups();
  if (num.has("a")) {
    num = 1;
  } else {
    num = parseNumber(num);
  }
  let str = den.text("reduced");
  if (endS.test(str)) {
    str = str.replace(endS, "");
    den = den.replaceWith(str);
  }
  if (mapping2.hasOwnProperty(str)) {
    den = mapping2[str];
  } else {
    den = parseNumber(den);
  }
  if (typeof num === "number" && typeof den === "number") {
    return {
      numerator: num,
      denominator: den
    };
  }
  return null;
};
var oneNth = function(m3) {
  let found = m3.match("^#Ordinal$");
  if (found.found !== true) {
    return null;
  }
  if (m3.lookAhead("^of .")) {
    let num = parseNumber(found);
    return {
      numerator: 1,
      denominator: num
    };
  }
  return null;
};
var named = function(m3) {
  let str = m3.text("reduced");
  if (mapping2.hasOwnProperty(str)) {
    return { numerator: 1, denominator: mapping2[str] };
  }
  return null;
};
var round2 = (n3) => {
  let rounded = Math.round(n3 * 1e3) / 1e3;
  if (rounded === 0 && n3 !== 0) {
    return n3;
  }
  return rounded;
};
var parseFraction = function(m3) {
  m3 = m3.clone();
  let res = named(m3) || slashForm(m3) || nOutOfN(m3) || nOrinalth(m3) || oneNth(m3) || null;
  if (res !== null) {
    if (res.numerator && res.denominator) {
      res.decimal = res.numerator / res.denominator;
      res.decimal = round2(res.decimal);
    }
  }
  return res;
};
var parse_default4 = parseFraction;

// node_modules/compromise/src/3-three/numbers/numbers/_toString.js
var numToString = function(n3) {
  if (n3 < 1e6) {
    return String(n3);
  }
  let str;
  if (typeof n3 === "number") {
    str = n3.toFixed(0);
  } else {
    str = n3;
  }
  if (str.indexOf("e+") === -1) {
    return str;
  }
  return str.replace(".", "").split("e+").reduce(function(p4, b) {
    return p4 + Array(b - p4.length + 2).join(0);
  });
};
var toString_default = numToString;

// node_modules/compromise/src/3-three/numbers/numbers/format/toText/data.js
var tens_mapping = [
  ["ninety", 90],
  ["eighty", 80],
  ["seventy", 70],
  ["sixty", 60],
  ["fifty", 50],
  ["forty", 40],
  ["thirty", 30],
  ["twenty", 20]
];
var ones_mapping = [
  "",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "ten",
  "eleven",
  "twelve",
  "thirteen",
  "fourteen",
  "fifteen",
  "sixteen",
  "seventeen",
  "eighteen",
  "nineteen"
];
var sequence = [
  [1e24, "septillion"],
  [1e20, "hundred sextillion"],
  [1e21, "sextillion"],
  [1e20, "hundred quintillion"],
  [1e18, "quintillion"],
  [1e17, "hundred quadrillion"],
  [1e15, "quadrillion"],
  [1e14, "hundred trillion"],
  [1e12, "trillion"],
  [1e11, "hundred billion"],
  [1e9, "billion"],
  [1e8, "hundred million"],
  [1e6, "million"],
  [1e5, "hundred thousand"],
  [1e3, "thousand"],
  [100, "hundred"],
  [1, "one"]
];

// node_modules/compromise/src/3-three/numbers/numbers/format/toText/index.js
var breakdown_magnitudes = function(num) {
  let working = num;
  let have = [];
  sequence.forEach((a2) => {
    if (num >= a2[0]) {
      let howmany = Math.floor(working / a2[0]);
      working -= howmany * a2[0];
      if (howmany) {
        have.push({
          unit: a2[1],
          count: howmany
        });
      }
    }
  });
  return have;
};
var breakdown_hundred = function(num) {
  let arr = [];
  if (num > 100) {
    return arr;
  }
  for (let i3 = 0; i3 < tens_mapping.length; i3++) {
    if (num >= tens_mapping[i3][1]) {
      num -= tens_mapping[i3][1];
      arr.push(tens_mapping[i3][0]);
    }
  }
  if (ones_mapping[num]) {
    arr.push(ones_mapping[num]);
  }
  return arr;
};
var handle_decimal = (num) => {
  const names = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
  let arr = [];
  let str = toString_default(num);
  let decimal = str.match(/\.([0-9]+)/);
  if (!decimal || !decimal[0]) {
    return arr;
  }
  arr.push("point");
  let decimals = decimal[0].split("");
  for (let i3 = 0; i3 < decimals.length; i3++) {
    arr.push(names[decimals[i3]]);
  }
  return arr;
};
var toText3 = function(obj) {
  let num = obj.num;
  if (num === 0 || num === "0") {
    return "zero";
  }
  if (num > 1e21) {
    num = toString_default(num);
  }
  let arr = [];
  if (num < 0) {
    arr.push("minus");
    num = Math.abs(num);
  }
  let units = breakdown_magnitudes(num);
  for (let i3 = 0; i3 < units.length; i3++) {
    let unit_name = units[i3].unit;
    if (unit_name === "one") {
      unit_name = "";
      if (arr.length > 1) {
        arr.push("and");
      }
    }
    arr = arr.concat(breakdown_hundred(units[i3].count));
    arr.push(unit_name);
  }
  arr = arr.concat(handle_decimal(num));
  arr = arr.filter((s3) => s3);
  if (arr.length === 0) {
    arr[0] = "";
  }
  return arr.join(" ");
};
var toText_default = toText3;

// node_modules/compromise/src/3-three/numbers/fractions/convert/toCardinal.js
var toCardinal = function(obj) {
  if (!obj.numerator || !obj.denominator) {
    return "";
  }
  let a2 = toText_default({ num: obj.numerator });
  let b = toText_default({ num: obj.denominator });
  return `${a2} out of ${b}`;
};
var toCardinal_default = toCardinal;

// node_modules/compromise/src/3-three/numbers/numbers/format/toOrdinal/textOrdinal.js
var irregulars = {
  one: "first",
  two: "second",
  three: "third",
  five: "fifth",
  eight: "eighth",
  nine: "ninth",
  twelve: "twelfth",
  twenty: "twentieth",
  thirty: "thirtieth",
  forty: "fortieth",
  fourty: "fourtieth",
  fifty: "fiftieth",
  sixty: "sixtieth",
  seventy: "seventieth",
  eighty: "eightieth",
  ninety: "ninetieth"
};
var textOrdinal = (obj) => {
  let words = toText_default(obj).split(" ");
  let last = words[words.length - 1];
  if (irregulars.hasOwnProperty(last)) {
    words[words.length - 1] = irregulars[last];
  } else {
    words[words.length - 1] = last.replace(/y$/, "i") + "th";
  }
  return words.join(" ");
};
var textOrdinal_default = textOrdinal;

// node_modules/compromise/src/3-three/numbers/fractions/convert/toOrdinal.js
var toOrdinal = function(obj) {
  if (!obj.numerator || !obj.denominator) {
    return "";
  }
  let start2 = toText_default({ num: obj.numerator });
  let end2 = textOrdinal_default({ num: obj.denominator });
  if (obj.denominator === 2) {
    end2 = "half";
  }
  if (start2 && end2) {
    if (obj.numerator !== 1) {
      end2 += "s";
    }
    return `${start2} ${end2}`;
  }
  return "";
};
var toOrdinal_default = toOrdinal;

// node_modules/compromise/src/3-three/numbers/fractions/api.js
var plugin3 = function(View2) {
  class Fractions extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Fractions";
    }
    parse(n3) {
      return this.getNth(n3).map(parse_default4);
    }
    get(n3) {
      return this.getNth(n3).map(parse_default4);
    }
    json(n3) {
      return this.getNth(n3).map((p4) => {
        let json = p4.toView().json(n3)[0];
        let parsed = parse_default4(p4);
        json.fraction = parsed;
        return json;
      }, []);
    }
    toDecimal(n3) {
      this.getNth(n3).forEach((m3) => {
        let { decimal } = parse_default4(m3);
        m3 = m3.replaceWith(String(decimal), true);
        m3.tag("NumericValue");
        m3.unTag("Fraction");
      });
      return this;
    }
    toFraction(n3) {
      this.getNth(n3).forEach((m3) => {
        let obj = parse_default4(m3);
        if (obj && typeof obj.numerator === "number" && typeof obj.denominator === "number") {
          let str = `${obj.numerator}/${obj.denominator}`;
          this.replace(m3, str);
        }
      });
      return this;
    }
    toOrdinal(n3) {
      this.getNth(n3).forEach((m3) => {
        let obj = parse_default4(m3);
        let str = toOrdinal_default(obj);
        if (m3.after("^#Noun").found) {
          str += " of";
        }
        m3.replaceWith(str);
      });
      return this;
    }
    toCardinal(n3) {
      this.getNth(n3).forEach((m3) => {
        let obj = parse_default4(m3);
        let str = toCardinal_default(obj);
        m3.replaceWith(str);
      });
      return this;
    }
    toPercentage(n3) {
      this.getNth(n3).forEach((m3) => {
        let { decimal } = parse_default4(m3);
        let percent = decimal * 100;
        percent = Math.round(percent * 100) / 100;
        m3.replaceWith(`${percent}%`);
      });
      return this;
    }
  }
  View2.prototype.fractions = function(n3) {
    let m3 = find_default2(this);
    m3 = m3.getNth(n3);
    return new Fractions(this.document, m3.pointer);
  };
};
var api_default15 = plugin3;

// node_modules/compromise/src/3-three/numbers/numbers/find.js
var ones = "one|two|three|four|five|six|seven|eight|nine";
var tens = "twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|fourty";
var teens = "eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen";
var findNumbers = function(doc) {
  let m3 = doc.match("#Value+");
  if (m3.has("#NumericValue #NumericValue")) {
    if (m3.has("#Value @hasComma #Value")) {
      m3.splitAfter("@hasComma");
    } else if (m3.has("#NumericValue #Fraction")) {
      m3.splitAfter("#NumericValue #Fraction");
    } else {
      m3 = m3.splitAfter("#NumericValue");
    }
  }
  if (m3.has("#Value #Value #Value") && !m3.has("#Multiple")) {
    if (m3.has("(" + tens + ") #Cardinal #Cardinal")) {
      m3 = m3.splitAfter("(" + tens + ") #Cardinal");
    }
  }
  if (m3.has("#Value #Value")) {
    if (m3.has("#NumericValue #NumericValue")) {
      m3 = m3.splitOn("#Year");
    }
    if (m3.has("(" + tens + ") (" + teens + ")")) {
      m3 = m3.splitAfter("(" + tens + ")");
    }
    let double = m3.match("#Cardinal #Cardinal");
    if (double.found && !m3.has("(point|decimal|#Fraction)")) {
      if (!double.has("#Cardinal (#Multiple|point|decimal)")) {
        let noMultiple = m3.has(`(${ones}) (${tens})`);
        let tensVal = double.has("(" + tens + ") #Cardinal");
        let multVal = double.has("#Multiple #Value");
        if (!noMultiple && !tensVal && !multVal) {
          double.terms().forEach((d2) => {
            m3 = m3.splitOn(d2);
          });
        }
      }
    }
    if (m3.match("#Ordinal #Ordinal").match("#TextValue").found && !m3.has("#Multiple")) {
      if (!m3.has("(" + tens + ") #Ordinal")) {
        m3 = m3.splitAfter("#Ordinal");
      }
    }
    m3 = m3.splitBefore("#Ordinal [#Cardinal]", 0);
    if (m3.has("#TextValue #NumericValue") && !m3.has("(" + tens + "|#Multiple)")) {
      m3 = m3.splitBefore("#TextValue #NumericValue");
    }
  }
  m3 = m3.splitAfter("#NumberRange");
  m3 = m3.splitBefore("#Year");
  return m3;
};
var find_default3 = findNumbers;

// node_modules/compromise/src/3-three/numbers/numbers/parse/index.js
var parseNumeric2 = function(str, m3) {
  str = str.replace(/,/g, "");
  let arr = str.split(/([0-9.,]*)/);
  let [prefix6, num] = arr;
  let suffix = arr.slice(2).join("");
  if (num !== "" && m3.length < 2) {
    num = Number(num || str);
    if (typeof num !== "number") {
      num = null;
    }
    suffix = suffix || "";
    if (suffix === "st" || suffix === "nd" || suffix === "rd" || suffix === "th") {
      suffix = "";
    }
    return {
      prefix: prefix6 || "",
      num,
      suffix
    };
  }
  return null;
};
var parseNumber2 = function(m3) {
  if (typeof m3 === "string") {
    return { num: toNumber_default(m3) };
  }
  let str = m3.text("reduced");
  let unit = m3.growRight("#Unit").match("#Unit$").text("machine");
  let hasComma = /[0-9],[0-9]/.test(m3.text("text"));
  if (m3.terms().length === 1 && !m3.has("#Multiple")) {
    let res = parseNumeric2(str, m3);
    if (res !== null) {
      res.hasComma = hasComma;
      res.unit = unit;
      return res;
    }
  }
  let frPart = m3.match("#Fraction{2,}$");
  frPart = frPart.found === false ? m3.match("^#Fraction$") : frPart;
  let fraction = null;
  if (frPart.found) {
    if (frPart.has("#Value and #Value #Fraction")) {
      frPart = frPart.match("and #Value #Fraction");
    }
    fraction = parse_default4(frPart);
    m3 = m3.not(frPart);
    m3 = m3.not("and$");
    str = m3.text("reduced");
  }
  let num = 0;
  if (str) {
    num = toNumber_default(str) || 0;
  }
  if (fraction && fraction.decimal) {
    num += fraction.decimal;
  }
  return {
    hasComma,
    prefix: "",
    num,
    suffix: "",
    isOrdinal: m3.has("#Ordinal"),
    isText: m3.has("#TextValue"),
    isFraction: m3.has("#Fraction"),
    isMoney: m3.has("#Money"),
    unit
  };
};
var parse_default5 = parseNumber2;

// node_modules/compromise/src/3-three/numbers/numbers/format/toOrdinal/numOrdinal.js
var numOrdinal = function(obj) {
  let num = obj.num;
  if (!num && num !== 0) {
    return null;
  }
  let tens2 = num % 100;
  if (tens2 > 10 && tens2 < 20) {
    return String(num) + "th";
  }
  const mapping3 = {
    0: "th",
    1: "st",
    2: "nd",
    3: "rd"
  };
  let str = toString_default(num);
  let last = str.slice(str.length - 1, str.length);
  if (mapping3[last]) {
    str += mapping3[last];
  } else {
    str += "th";
  }
  return str;
};
var numOrdinal_default = numOrdinal;

// node_modules/compromise/src/3-three/numbers/numbers/format/suffix.js
var prefixes = {
  "\xA2": "cents",
  $: "dollars",
  "\xA3": "pounds",
  "\xA5": "yen",
  "\u20AC": "euros",
  "\u20A1": "col\xF3n",
  "\u0E3F": "baht",
  "\u20AD": "kip",
  "\u20A9": "won",
  "\u20B9": "rupees",
  "\u20BD": "ruble",
  "\u20BA": "liras"
};
var suffixes5 = {
  "%": "percent",
  "\xB0": "degrees"
};
var addSuffix = function(obj) {
  let res = {
    suffix: "",
    prefix: obj.prefix
  };
  if (prefixes.hasOwnProperty(obj.prefix)) {
    res.suffix += " " + prefixes[obj.prefix];
    res.prefix = "";
  }
  if (suffixes5.hasOwnProperty(obj.suffix)) {
    res.suffix += " " + suffixes5[obj.suffix];
  }
  if (res.suffix && obj.num === 1) {
    res.suffix = res.suffix.replace(/s$/, "");
  }
  if (!res.suffix && obj.suffix) {
    res.suffix += " " + obj.suffix;
  }
  return res;
};
var suffix_default2 = addSuffix;

// node_modules/compromise/src/3-three/numbers/numbers/format/index.js
var format = function(obj, fmt2) {
  if (fmt2 === "TextOrdinal") {
    let { prefix: prefix6, suffix } = suffix_default2(obj);
    return prefix6 + textOrdinal_default(obj) + suffix;
  }
  if (fmt2 === "Ordinal") {
    return obj.prefix + numOrdinal_default(obj) + obj.suffix;
  }
  if (fmt2 === "TextCardinal") {
    let { prefix: prefix6, suffix } = suffix_default2(obj);
    return prefix6 + toText_default(obj) + suffix;
  }
  let num = obj.num;
  if (obj.hasComma) {
    num = num.toLocaleString();
  }
  return obj.prefix + String(num) + obj.suffix;
};
var format_default = format;

// node_modules/compromise/src/3-three/numbers/numbers/api.js
var addMethod = function(View2) {
  class Numbers extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Numbers";
    }
    parse(n3) {
      return this.getNth(n3).map(parse_default5);
    }
    get(n3) {
      return this.getNth(n3).map(parse_default5).map((o2) => o2.num);
    }
    json(n3) {
      let opts2 = typeof n3 === "object" ? n3 : {};
      return this.getNth(n3).map((p4) => {
        let json = p4.toView().json(opts2)[0];
        let parsed = parse_default5(p4);
        json.number = {
          prefix: parsed.prefix,
          num: parsed.num,
          suffix: parsed.suffix,
          hasComma: parsed.hasComma,
          unit: parsed.unit
        };
        return json;
      }, []);
    }
    units() {
      return this.growRight("#Unit").match("#Unit$");
    }
    isOrdinal() {
      return this.if("#Ordinal");
    }
    isCardinal() {
      return this.if("#Cardinal");
    }
    toNumber() {
      let m3 = this.if("#TextValue");
      m3.forEach((val) => {
        let obj = parse_default5(val);
        if (obj.num === null) {
          return;
        }
        let fmt2 = val.has("#Ordinal") ? "Ordinal" : "Cardinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        val.tag("NumericValue");
      });
      return this;
    }
    toLocaleString() {
      let m3 = this;
      m3.forEach((val) => {
        let obj = parse_default5(val);
        if (obj.num === null) {
          return;
        }
        let num = obj.num.toLocaleString();
        if (val.has("#Ordinal")) {
          let str = format_default(obj, "Ordinal");
          let end2 = str.match(/[a-z]+$/);
          if (end2) {
            num += end2[0] || "";
          }
        }
        val.replaceWith(num, { tags: true });
      });
      return this;
    }
    toText() {
      let m3 = this;
      let res = m3.map((val) => {
        if (val.has("#TextValue")) {
          return val;
        }
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#Ordinal") ? "TextOrdinal" : "TextCardinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        val.tag("TextValue");
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    toCardinal() {
      let m3 = this;
      let res = m3.map((val) => {
        if (!val.has("#Ordinal")) {
          return val;
        }
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#TextValue") ? "TextCardinal" : "Cardinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        val.tag("Cardinal");
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    toOrdinal() {
      let m3 = this;
      let res = m3.map((val) => {
        if (val.has("#Ordinal")) {
          return val;
        }
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#TextValue") ? "TextOrdinal" : "Ordinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        val.tag("Ordinal");
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    isEqual(n3) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num === n3;
      });
    }
    greaterThan(n3) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num > n3;
      });
    }
    lessThan(n3) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num < n3;
      });
    }
    between(min2, max3) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num > min2 && num < max3;
      });
    }
    set(n3) {
      if (n3 === void 0) {
        return this;
      }
      if (typeof n3 === "string") {
        n3 = parse_default5(n3).num;
      }
      let m3 = this;
      let res = m3.map((val) => {
        let obj = parse_default5(val);
        obj.num = n3;
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#Ordinal") ? "Ordinal" : "Cardinal";
        if (val.has("#TextValue")) {
          fmt2 = val.has("#Ordinal") ? "TextOrdinal" : "TextCardinal";
        }
        let str = format_default(obj, fmt2);
        if (obj.hasComma && fmt2 === "Cardinal") {
          str = Number(str).toLocaleString();
        }
        val = val.not("#Currency");
        val.replaceWith(str, { tags: true });
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    add(n3) {
      if (!n3) {
        return this;
      }
      if (typeof n3 === "string") {
        n3 = parse_default5(n3).num;
      }
      let m3 = this;
      let res = m3.map((val) => {
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        obj.num += n3;
        let fmt2 = val.has("#Ordinal") ? "Ordinal" : "Cardinal";
        if (obj.isText) {
          fmt2 = val.has("#Ordinal") ? "TextOrdinal" : "TextCardinal";
        }
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    subtract(n3, agree) {
      return this.add(n3 * -1, agree);
    }
    increment(agree) {
      return this.add(1, agree);
    }
    decrement(agree) {
      return this.add(-1, agree);
    }
    update(pointer) {
      let m3 = new Numbers(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  Numbers.prototype.toNice = Numbers.prototype.toLocaleString;
  Numbers.prototype.isBetween = Numbers.prototype.between;
  Numbers.prototype.minus = Numbers.prototype.subtract;
  Numbers.prototype.plus = Numbers.prototype.add;
  Numbers.prototype.equals = Numbers.prototype.isEqual;
  View2.prototype.numbers = function(n3) {
    let m3 = find_default3(this);
    m3 = m3.getNth(n3);
    return new Numbers(this.document, m3.pointer);
  };
  View2.prototype.percentages = function(n3) {
    let m3 = find_default3(this);
    m3 = m3.filter((v2) => v2.has("#Percent") || v2.after("^percent"));
    m3 = m3.getNth(n3);
    return new Numbers(this.document, m3.pointer);
  };
  View2.prototype.money = function(n3) {
    let m3 = find_default3(this);
    m3 = m3.filter((v2) => v2.has("#Money") || v2.after("^#Currency"));
    m3 = m3.getNth(n3);
    return new Numbers(this.document, m3.pointer);
  };
  View2.prototype.values = View2.prototype.numbers;
};
var api_default16 = addMethod;

// node_modules/compromise/src/3-three/numbers/plugin.js
var api13 = function(View2) {
  api_default15(View2);
  api_default16(View2);
};
var plugin_default22 = {
  api: api13
};

// node_modules/compromise/src/3-three/redact/plugin.js
var defaults3 = {
  people: true,
  emails: true,
  phoneNumbers: true,
  places: true
};
var redact = function(opts2 = {}) {
  opts2 = Object.assign({}, defaults3, opts2);
  if (opts2.people !== false) {
    this.people().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
  }
  if (opts2.emails !== false) {
    this.emails().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
  }
  if (opts2.places !== false) {
    this.places().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
  }
  if (opts2.phoneNumbers !== false) {
    this.phoneNumbers().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
  }
  return this;
};
var plugin4 = {
  api: function(View2) {
    View2.prototype.redact = redact;
  }
};
var plugin_default23 = plugin4;

// node_modules/compromise/src/3-three/sentences/questions.js
var isQuestion = function(doc) {
  let clauses2 = doc.clauses();
  if (/\.\.$/.test(doc.out("text"))) {
    return false;
  }
  if (doc.has("^#QuestionWord") && doc.has("@hasComma")) {
    return false;
  }
  if (doc.has("or not$")) {
    return true;
  }
  if (doc.has("^#QuestionWord")) {
    return true;
  }
  if (doc.has("^(do|does|did|is|was|can|could|will|would|may) #Noun")) {
    return true;
  }
  if (doc.has("^(have|must) you")) {
    return true;
  }
  if (clauses2.has("(do|does|is|was) #Noun+ #Adverb? (#Adjective|#Infinitive)$")) {
    return true;
  }
  return false;
};
var findQuestions = function(view) {
  const hasQ = /\?/;
  const { document: document2 } = view;
  return view.filter((m3) => {
    let terms = m3.docs[0] || [];
    let lastTerm = terms[terms.length - 1];
    if (!lastTerm || document2[lastTerm.index[0]].length !== terms.length) {
      return false;
    }
    if (hasQ.test(lastTerm.post)) {
      return true;
    }
    return isQuestion(m3);
  });
};
var questions_default = findQuestions;

// node_modules/compromise/src/3-three/sentences/parse/mainClause.js
var subordinate = `(after|although|as|because|before|if|since|than|that|though|when|whenever|where|whereas|wherever|whether|while|why|unless|until|once)`;
var relative = `(that|which|whichever|who|whoever|whom|whose|whomever)`;
var mainClause = function(s3) {
  let m3 = s3;
  if (m3.length === 1) {
    return m3;
  }
  m3 = m3.if("#Verb");
  if (m3.length === 1) {
    return m3;
  }
  m3 = m3.ifNo(subordinate);
  m3 = m3.ifNo("^even (if|though)");
  m3 = m3.ifNo("^so that");
  m3 = m3.ifNo("^rather than");
  m3 = m3.ifNo("^provided that");
  if (m3.length === 1) {
    return m3;
  }
  m3 = m3.ifNo(relative);
  if (m3.length === 1) {
    return m3;
  }
  m3 = m3.ifNo("(despite|during|before|through|throughout)");
  if (m3.length === 1) {
    return m3;
  }
  if (m3.length === 0) {
    m3 = s3;
  }
  return m3.eq(0);
};
var mainClause_default = mainClause;

// node_modules/compromise/src/3-three/sentences/parse/index.js
var grammar = function(vb3) {
  let tense = null;
  if (vb3.has("#PastTense")) {
    tense = "PastTense";
  } else if (vb3.has("#FutureTense")) {
    tense = "FutureTense";
  } else if (vb3.has("#PresentTense")) {
    tense = "PresentTense";
  }
  return {
    tense
  };
};
var parse5 = function(s3) {
  let clauses2 = s3.clauses();
  let main = mainClause_default(clauses2);
  let chunks2 = main.chunks();
  let subj = s3.none();
  let verb = s3.none();
  let pred = s3.none();
  chunks2.forEach((ch, i3) => {
    if (i3 === 0 && !ch.has("<Verb>")) {
      subj = ch;
      return;
    }
    if (!verb.found && ch.has("<Verb>")) {
      verb = ch;
      return;
    }
    if (verb.found) {
      pred = pred.concat(ch);
    }
  });
  if (verb.found && !subj.found) {
    subj = verb.before("<Noun>+").first();
  }
  return {
    subj,
    verb,
    pred,
    grammar: grammar(verb)
  };
};
var parse_default6 = parse5;

// node_modules/compromise/src/3-three/sentences/conjugate/toPast.js
var toPast2 = function(s3) {
  let verbs = s3.verbs();
  let first = verbs.eq(0);
  if (first.has("#PastTense")) {
    return s3;
  }
  first.toPastTense();
  if (verbs.length > 1) {
    verbs = verbs.slice(1);
    verbs = verbs.filter((v2) => !v2.lookBehind("to$").found);
    verbs = verbs.if("#PresentTense");
    verbs = verbs.notIf("#Gerund");
    let list4 = s3.match("to #Verb+ #Conjunction #Verb").terms();
    verbs = verbs.not(list4);
    if (verbs.found) {
      verbs.verbs().toPastTense();
    }
  }
  return s3;
};
var toPast_default = toPast2;

// node_modules/compromise/src/3-three/sentences/conjugate/toPresent.js
var toPresent2 = function(s3) {
  let verbs = s3.verbs();
  let first = verbs.eq(0);
  first.toPresentTense();
  if (verbs.length > 1) {
    verbs = verbs.slice(1);
    verbs = verbs.filter((v2) => !v2.lookBehind("to$").found);
    verbs = verbs.notIf("#Gerund");
    if (verbs.found) {
      verbs.verbs().toPresentTense();
    }
  }
  return s3;
};
var toPresent_default = toPresent2;

// node_modules/compromise/src/3-three/sentences/conjugate/toFuture.js
var toFuture = function(s3) {
  let verbs = s3.verbs();
  let first = verbs.eq(0);
  first.toFutureTense();
  s3 = s3.fullSentence();
  verbs = s3.verbs();
  if (verbs.length > 1) {
    verbs = verbs.slice(1);
    let toChange = verbs.filter((vb3) => {
      if (vb3.lookBehind("to$").found) {
        return false;
      }
      if (vb3.has("#Copula #Gerund")) {
        return true;
      }
      if (vb3.has("#Gerund")) {
        return false;
      }
      if (vb3.has("#Copula")) {
        return true;
      }
      if (vb3.has("#PresentTense") && !vb3.has("#Infinitive") && vb3.lookBefore("(he|she|it|that|which)$").found) {
        return false;
      }
      return true;
    });
    if (toChange.found) {
      toChange.forEach((m3) => {
        if (m3.has("#Copula")) {
          m3.match("was").replaceWith("is");
          m3.match("is").replaceWith("will be");
          return;
        }
        m3.toInfinitive();
      });
    }
  }
  return s3;
};
var toFuture_default = toFuture;

// node_modules/compromise/src/3-three/sentences/conjugate/toNegative.js
var toNegative = function(s3) {
  s3.verbs().first().toNegative().compute("chunks");
  return s3;
};
var toPositive = function(s3) {
  s3.verbs().first().toPositive().compute("chunks");
  return s3;
};

// node_modules/compromise/src/3-three/sentences/conjugate/toInfinitive.js
var toInfinitive2 = function(s3) {
  s3.verbs().toInfinitive();
  return s3;
};
var toInfinitive_default2 = toInfinitive2;

// node_modules/compromise/src/3-three/sentences/api.js
var api14 = function(View2) {
  class Sentences extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Sentences";
    }
    json(opts2 = {}) {
      return this.map((m3) => {
        let json = m3.toView().json(opts2)[0] || {};
        let { subj, verb, pred, grammar: grammar2 } = parse_default6(m3);
        json.sentence = {
          subject: subj.text("normal"),
          verb: verb.text("normal"),
          predicate: pred.text("normal"),
          grammar: grammar2
        };
        return json;
      }, []);
    }
    toPastTense(n3) {
      return this.getNth(n3).map((s3) => {
        let parsed = parse_default6(s3);
        return toPast_default(s3, parsed);
      });
    }
    toPresentTense(n3) {
      return this.getNth(n3).map((s3) => {
        let parsed = parse_default6(s3);
        return toPresent_default(s3, parsed);
      });
    }
    toFutureTense(n3) {
      return this.getNth(n3).map((s3) => {
        let parsed = parse_default6(s3);
        s3 = toFuture_default(s3, parsed);
        return s3;
      });
    }
    toInfinitive(n3) {
      return this.getNth(n3).map((s3) => {
        let parsed = parse_default6(s3);
        return toInfinitive_default2(s3, parsed);
      });
    }
    toNegative(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default6(vb3);
        return toNegative(vb3, parsed);
      });
    }
    toPositive(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default6(vb3);
        return toPositive(vb3, parsed);
      });
    }
    isQuestion(n3) {
      return this.questions(n3);
    }
    isExclamation(n3) {
      let res = this.filter((s3) => s3.lastTerm().has("@hasExclamation"));
      return res.getNth(n3);
    }
    isStatement(n3) {
      let res = this.filter((s3) => !s3.isExclamation().found && !s3.isQuestion().found);
      return res.getNth(n3);
    }
    update(pointer) {
      let m3 = new Sentences(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  Sentences.prototype.toPresent = Sentences.prototype.toPresentTense;
  Sentences.prototype.toPast = Sentences.prototype.toPastTense;
  Sentences.prototype.toFuture = Sentences.prototype.toFutureTense;
  const methods16 = {
    sentences: function(n3) {
      let m3 = this.map((s3) => s3.fullSentence());
      m3 = m3.getNth(n3);
      return new Sentences(this.document, m3.pointer);
    },
    questions: function(n3) {
      let m3 = questions_default(this);
      return m3.getNth(n3);
    }
  };
  Object.assign(View2.prototype, methods16);
};
var api_default17 = api14;

// node_modules/compromise/src/3-three/sentences/plugin.js
var plugin_default24 = { api: api_default17 };

// node_modules/compromise/src/3-three/topics/people/find.js
var find5 = function(doc) {
  let m3 = doc.match("#Honorific+? #Person+");
  return m3;
};
var find_default4 = find5;

// node_modules/compromise/src/3-three/topics/people/parse.js
var parse6 = function(m3) {
  let res = {};
  res.firstName = m3.match("#FirstName+");
  res.lastName = m3.match("#LastName+");
  res.honorific = m3.match("#Honorific+");
  let last = res.lastName;
  let first = res.firstName;
  if (!first.found || !last.found) {
    if (!first.found && !last.found && m3.has("^#Honorific .$")) {
      res.lastName = m3.match(".$");
      return res;
    }
  }
  return res;
};
var parse_default7 = parse6;

// node_modules/compromise/src/3-three/topics/people/gender.js
var m2 = "male";
var f2 = "female";
var honorifics = {
  mr: m2,
  mrs: f2,
  miss: f2,
  madam: f2,
  king: m2,
  queen: f2,
  duke: m2,
  duchess: f2,
  baron: m2,
  baroness: f2,
  count: m2,
  countess: f2,
  prince: m2,
  princess: f2,
  sire: m2,
  dame: f2,
  lady: f2,
  ayatullah: m2,
  congressman: m2,
  congresswoman: f2,
  "first lady": f2,
  mx: null
};
var predictGender = function(parsed, person) {
  let { firstName, honorific } = parsed;
  if (firstName.has("#FemaleName")) {
    return f2;
  }
  if (firstName.has("#MaleName")) {
    return m2;
  }
  if (honorific.found) {
    let hon = honorific.text("normal");
    hon = hon.replace(/\./g, "");
    if (honorifics.hasOwnProperty(hon)) {
      return honorifics[hon];
    }
    if (/^her /.test(hon)) {
      return f2;
    }
    if (/^his /.test(hon)) {
      return m2;
    }
  }
  let after2 = person.after();
  if (!after2.has("#Person") && after2.has("#Pronoun")) {
    let pro = after2.match("#Pronoun");
    if (pro.has("(they|their)")) {
      return null;
    }
    let hasMasc = pro.has("(he|his)");
    let hasFem = pro.has("(she|her|hers)");
    if (hasMasc && !hasFem) {
      return m2;
    }
    if (hasFem && !hasMasc) {
      return f2;
    }
  }
  return null;
};
var gender_default = predictGender;

// node_modules/compromise/src/3-three/topics/people/api.js
var addMethod2 = function(View2) {
  class People extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "People";
    }
    parse(n3) {
      return this.getNth(n3).map(parse_default7);
    }
    json(n3) {
      let opts2 = typeof n3 === "object" ? n3 : {};
      return this.getNth(n3).map((p4) => {
        let json = p4.toView().json(opts2)[0];
        let parsed = parse_default7(p4);
        json.person = {
          firstName: parsed.firstName.text("normal"),
          lastName: parsed.lastName.text("normal"),
          honorific: parsed.honorific.text("normal"),
          presumed_gender: gender_default(parsed, p4)
        };
        return json;
      }, []);
    }
    presumedMale() {
      return this.filter((m3) => {
        return m3.has("(#MaleName|mr|mister|sr|jr|king|pope|prince|sir)");
      });
    }
    presumedFemale() {
      return this.filter((m3) => {
        return m3.has("(#FemaleName|mrs|miss|queen|princess|madam)");
      });
    }
    update(pointer) {
      let m3 = new People(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  View2.prototype.people = function(n3) {
    let m3 = find_default4(this);
    m3 = m3.getNth(n3);
    return new People(this.document, m3.pointer);
  };
};
var api_default18 = addMethod2;

// node_modules/compromise/src/3-three/topics/places/find.js
var find6 = function(doc) {
  let m3 = doc.match("(#Place|#Address)+");
  let splits = m3.match("@hasComma");
  splits = splits.filter((c2) => {
    if (c2.has("(asia|africa|europe|america)$")) {
      return true;
    }
    if (c2.has("(#City|#Region|#ProperNoun)$") && c2.after("^(#Country|#Region)").found) {
      return false;
    }
    return true;
  });
  m3 = m3.splitAfter(splits);
  return m3;
};
var find_default5 = find6;

// node_modules/compromise/src/3-three/topics/places/api.js
var addMethod3 = function(View2) {
  View2.prototype.places = function(n3) {
    let m3 = find_default5(this);
    m3 = m3.getNth(n3);
    return new View2(this.document, m3.pointer);
  };
};
var api_default19 = addMethod3;

// node_modules/compromise/src/3-three/topics/orgs/api.js
var api15 = function(View2) {
  View2.prototype.organizations = function(n3) {
    let m3 = this.match("#Organization+");
    return m3.getNth(n3);
  };
};
var api_default20 = api15;

// node_modules/compromise/src/3-three/topics/topics.js
var find7 = function(n3) {
  let r2 = this.clauses();
  let m3 = r2.people();
  m3 = m3.concat(r2.places());
  m3 = m3.concat(r2.organizations());
  m3 = m3.not("(someone|man|woman|mother|brother|sister|father)");
  m3 = m3.sort("seq");
  m3 = m3.getNth(n3);
  return m3;
};
var api16 = function(View2) {
  View2.prototype.topics = find7;
};
var topics_default = api16;

// node_modules/compromise/src/3-three/topics/plugin.js
var api17 = function(View2) {
  api_default18(View2);
  api_default19(View2);
  api_default20(View2);
  topics_default(View2);
};
var plugin_default25 = { api: api17 };

// node_modules/compromise/src/3-three/verbs/find.js
var findVerbs = function(doc) {
  let m3 = doc.match("<Verb>");
  m3 = m3.not("(#Conjunction && !to)");
  m3 = m3.not("#Preposition");
  m3 = m3.splitAfter("@hasComma");
  m3 = m3.splitAfter("[(do|did|am|was|is|will)] (is|was)", 0);
  m3 = m3.splitBefore("(#Verb && !#Copula) [being] #Verb", 0);
  m3 = m3.splitBefore("#Verb [to be] #Verb", 0);
  m3 = m3.splitAfter("[help] #PresentTense", 0);
  m3 = m3.splitBefore("(#PresentTense|#PastTense) [#Copula]$", 0);
  m3 = m3.splitBefore("(#PresentTense|#PastTense) [will be]$", 0);
  m3 = m3.not("#Reflexive$");
  m3 = m3.splitAfter("[#PastTense] #PastTense", 0);
  m3 = m3.splitAfter("[#PastTense] #Auxiliary+ #PastTense", 0);
  m3 = m3.splitAfter("#Copula [#Gerund] #PastTense", 0);
  m3 = m3.if("#Verb");
  if (m3.has("(#Verb && !#Auxiliary) #Adverb+? #Copula")) {
    m3 = m3.splitBefore("#Copula");
  }
  return m3;
};
var find_default6 = findVerbs;

// node_modules/compromise/src/3-three/verbs/api/parse/root.js
var getMain = function(vb3) {
  let root = vb3;
  if (vb3.wordCount() > 1) {
    root = vb3.not("(#Negative|#Auxiliary|#Modal|#Adverb|#Prefix)");
  }
  if (root.length > 1 && !root.has("#Phrasal #Particle")) {
    root = root.last();
  }
  root = root.not("(want|wants|wanted) to");
  if (!root.found) {
    root = vb3.not("#Negative");
    return root;
  }
  return root;
};
var root_default2 = getMain;

// node_modules/compromise/src/3-three/verbs/api/parse/adverbs.js
var getAdverbs = function(vb3, root) {
  let res = {
    pre: vb3.none(),
    post: vb3.none()
  };
  if (!vb3.has("#Adverb")) {
    return res;
  }
  let parts = vb3.splitOn(root);
  if (parts.length === 3) {
    return {
      pre: parts.eq(0).adverbs(),
      post: parts.eq(2).adverbs()
    };
  }
  if (parts.eq(0).isDoc(root)) {
    res.post = parts.eq(1).adverbs();
    return res;
  }
  res.pre = parts.eq(0).adverbs();
  return res;
};
var adverbs_default2 = getAdverbs;

// node_modules/compromise/src/3-three/verbs/api/parse/index.js
var getAuxiliary = function(vb3, root) {
  let parts = vb3.splitBefore(root);
  if (parts.length <= 1) {
    return vb3.none();
  }
  let aux = parts.eq(0);
  aux = aux.not("(#Adverb|#Negative|#Prefix)");
  return aux;
};
var getNegative = function(vb3) {
  return vb3.match("#Negative");
};
var getPhrasal = function(root) {
  if (!root.has("(#Particle|#PhrasalVerb)")) {
    return {
      verb: root.none(),
      particle: root.none()
    };
  }
  let particle = root.match("#Particle$");
  return {
    verb: root.not(particle),
    particle
  };
};
var parseVerb = function(view) {
  let vb3 = view.clone();
  vb3.contractions().expand();
  const root = root_default2(vb3);
  let res = {
    root,
    prefix: vb3.match("#Prefix"),
    adverbs: adverbs_default2(vb3, root),
    auxiliary: getAuxiliary(vb3, root),
    negative: getNegative(vb3),
    phrasal: getPhrasal(root)
  };
  return res;
};
var parse_default8 = parseVerb;

// node_modules/compromise/src/3-three/verbs/api/parse/grammar/forms.js
var present = { tense: "PresentTense" };
var conditional = { conditional: true };
var future = { tense: "FutureTense" };
var prog = { progressive: true };
var past2 = { tense: "PastTense" };
var complete = { complete: true, progressive: false };
var passive = { passive: true };
var plural = { plural: true };
var singular = { plural: false };
var getData = function(tags) {
  let data = {};
  tags.forEach((o2) => {
    Object.assign(data, o2);
  });
  return data;
};
var verbForms = {
  "imperative": [
    ["#Imperative", []]
  ],
  "want-infinitive": [
    ["^(want|wants|wanted) to #Infinitive$", [present]],
    ["^wanted to #Infinitive$", [past2]],
    ["^will want to #Infinitive$", [future]]
  ],
  "gerund-phrase": [
    ["^#PastTense #Gerund$", [past2]],
    ["^#PresentTense #Gerund$", [present]],
    ["^#Infinitive #Gerund$", [present]],
    ["^will #Infinitive #Gerund$", [future]],
    ["^have #PastTense #Gerund$", [past2]],
    ["^will have #PastTense #Gerund$", [past2]]
  ],
  "simple-present": [
    ["^#PresentTense$", [present]],
    ["^#Infinitive$", [present]]
  ],
  "simple-past": [
    ["^#PastTense$", [past2]]
  ],
  "simple-future": [
    ["^will #Adverb? #Infinitive", [future]]
  ],
  "present-progressive": [
    ["^(is|are|am) #Gerund$", [present, prog]]
  ],
  "past-progressive": [
    ["^(was|were) #Gerund$", [past2, prog]]
  ],
  "future-progressive": [
    ["^will be #Gerund$", [future, prog]]
  ],
  "present-perfect": [
    ["^(has|have) #PastTense$", [past2, complete]]
  ],
  "past-perfect": [
    ["^had #PastTense$", [past2, complete]],
    ["^had #PastTense to #Infinitive", [past2, complete]]
  ],
  "future-perfect": [
    ["^will have #PastTense$", [future, complete]]
  ],
  "present-perfect-progressive": [
    ["^(has|have) been #Gerund$", [past2, prog]]
  ],
  "past-perfect-progressive": [
    ["^had been #Gerund$", [past2, prog]]
  ],
  "future-perfect-progressive": [
    ["^will have been #Gerund$", [future, prog]]
  ],
  "passive-past": [
    ["(got|were|was) #Passive", [past2, passive]],
    ["^(was|were) being #Passive", [past2, passive]],
    ["^(had|have) been #Passive", [past2, passive]]
  ],
  "passive-present": [
    ["^(is|are|am) #Passive", [present, passive]],
    ["^(is|are|am) being #Passive", [present, passive]],
    ["^has been #Passive", [present, passive]]
  ],
  "passive-future": [
    ["will have been #Passive", [future, passive, conditional]],
    ["will be being? #Passive", [future, passive, conditional]]
  ],
  "present-conditional": [
    ["would be #PastTense", [present, conditional]]
  ],
  "past-conditional": [
    ["would have been #PastTense", [past2, conditional]]
  ],
  "auxiliary-future": [
    ["(is|are|am|was) going to (#Infinitive|#PresentTense)", [future]]
  ],
  "auxiliary-past": [
    ["^did #Infinitive$", [past2, singular]],
    ["^used to #Infinitive$", [past2, complete]]
  ],
  "auxiliary-present": [
    ["^(does|do) #Infinitive$", [present, complete, plural]]
  ],
  "modal-past": [
    ["^(could|must|should|shall) have #PastTense$", [past2]]
  ],
  "modal-infinitive": [
    ["^#Modal #Infinitive$", []]
  ],
  "infinitive": [
    ["^#Infinitive$", []]
  ]
};
var list3 = [];
Object.keys(verbForms).map((k2) => {
  verbForms[k2].forEach((a2) => {
    list3.push({
      name: k2,
      match: a2[0],
      data: getData(a2[1])
    });
  });
});
var forms_default = list3;

// node_modules/compromise/src/3-three/verbs/api/parse/grammar/index.js
var cleanUp2 = function(vb3, res) {
  vb3 = vb3.clone();
  if (res.adverbs.post && res.adverbs.post.found) {
    vb3.remove(res.adverbs.post);
  }
  if (res.adverbs.pre && res.adverbs.pre.found) {
    vb3.remove(res.adverbs.pre);
  }
  if (vb3.has("#Negative")) {
    vb3 = vb3.remove("#Negative");
  }
  if (vb3.has("#Prefix")) {
    vb3 = vb3.remove("#Prefix");
  }
  if (res.root.has("#PhrasalVerb #Particle")) {
    vb3.remove("#Particle$");
  }
  vb3 = vb3.not("#Adverb");
  return vb3;
};
var getGrammar = function(vb3, res) {
  let grammar2 = {};
  vb3 = cleanUp2(vb3, res);
  for (let i3 = 0; i3 < forms_default.length; i3 += 1) {
    let todo = forms_default[i3];
    if (vb3.has(todo.match) === true) {
      grammar2.form = todo.name;
      Object.assign(grammar2, todo.data);
      break;
    }
  }
  if (!grammar2.form) {
    if (vb3.has("^#Verb$")) {
      grammar2.form = "infinitive";
    }
  }
  if (!grammar2.tense) {
    grammar2.tense = res.root.has("#PastTense") ? "PastTense" : "PresentTense";
  }
  grammar2.copula = res.root.has("#Copula");
  return grammar2;
};
var grammar_default = getGrammar;

// node_modules/compromise/src/3-three/verbs/api/parse/getSubject.js
var shouldSkip = function(last) {
  if (last.length <= 1) {
    return false;
  }
  let obj = last.parse()[0] || {};
  return obj.isSubordinate;
};
var noSubClause = function(before2) {
  let parts = before2.clauses();
  parts = parts.filter((m3, i3) => {
    if (m3.has("^(if|unless|while|but|for|per|at|by|that|which|who|from)")) {
      return false;
    }
    if (i3 > 0 && m3.has("^#Verb . #Noun+$")) {
      return false;
    }
    if (i3 > 0 && m3.has("^#Adverb")) {
      return false;
    }
    return true;
  });
  if (parts.length === 0) {
    return before2;
  }
  return parts;
};
var lastNoun2 = function(vb3) {
  let before2 = vb3.before();
  before2 = noSubClause(before2);
  let nouns = before2.nouns();
  let last = nouns.last();
  let pronoun = last.match("(i|he|she|we|you|they)");
  if (pronoun.found) {
    return pronoun.nouns();
  }
  let det = nouns.if("^(that|this|those)");
  if (det.found) {
    return det;
  }
  if (nouns.found === false) {
    det = before2.match("^(that|this|those)");
    if (det.found) {
      return det;
    }
  }
  last = nouns.last();
  if (shouldSkip(last)) {
    nouns.remove(last);
    last = nouns.last();
  }
  if (shouldSkip(last)) {
    nouns.remove(last);
    last = nouns.last();
  }
  return last;
};
var isPlural3 = function(subj, vb3) {
  if (vb3.has("(are|were|does)")) {
    return true;
  }
  if (subj.has("(those|they|we)")) {
    return true;
  }
  if (subj.found && subj.isPlural) {
    return subj.isPlural().found;
  }
  return false;
};
var getSubject = function(vb3) {
  let subj = lastNoun2(vb3);
  return {
    subject: subj,
    plural: isPlural3(subj, vb3)
  };
};
var getSubject_default = getSubject;

// node_modules/compromise/src/3-three/verbs/api/lib.js
var noop = (vb3) => vb3;
var isPlural4 = (vb3, parsed) => {
  let subj = getSubject_default(vb3, parsed);
  let m3 = subj.subject;
  if (m3.has("i") || m3.has("we")) {
    return true;
  }
  return subj.plural;
};
var wasWere = (vb3, parsed) => {
  let { subject, plural: plural2 } = getSubject_default(vb3, parsed);
  if (plural2 || subject.has("we")) {
    return "were";
  }
  return "was";
};
var isAreAm = function(vb3, parsed) {
  if (vb3.has("were")) {
    return "are";
  }
  let { subject, plural: plural2 } = getSubject_default(vb3, parsed);
  if (subject.has("i")) {
    return "am";
  }
  if (subject.has("we") || plural2) {
    return "are";
  }
  return "is";
};
var doDoes = function(vb3, parsed) {
  let subj = getSubject_default(vb3, parsed);
  let m3 = subj.subject;
  if (m3.has("i") || m3.has("we")) {
    return "do";
  }
  if (subj.plural) {
    return "do";
  }
  return "does";
};
var getTense2 = function(m3) {
  if (m3.has("#Infinitive")) {
    return "Infinitive";
  }
  if (m3.has("#Participle")) {
    return "Participle";
  }
  if (m3.has("#PastTense")) {
    return "PastTense";
  }
  if (m3.has("#Gerund")) {
    return "Gerund";
  }
  if (m3.has("#PresentTense")) {
    return "PresentTense";
  }
  return void 0;
};
var toInf = function(vb3, parsed) {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  let str = parsed.root.text({ keepPunct: false });
  str = toInfinitive3(str, vb3.model, getTense2(vb3));
  if (str) {
    vb3.replace(parsed.root, str);
  }
  return vb3;
};
var noWill = (vb3) => {
  if (vb3.has("will not")) {
    return vb3.replace("will not", "have not");
  }
  return vb3.remove("will");
};

// node_modules/compromise/src/3-three/verbs/api/toJSON.js
var toArray4 = function(m3) {
  if (!m3 || !m3.isView) {
    return [];
  }
  const opts2 = { normal: true, terms: false, text: false };
  return m3.json(opts2).map((s3) => s3.normal);
};
var toText4 = function(m3) {
  if (!m3 || !m3.isView) {
    return "";
  }
  return m3.text("normal");
};
var toInf2 = function(root) {
  const { toInfinitive: toInfinitive3 } = root.methods.two.transform.verb;
  let str = root.text("normal");
  return toInfinitive3(str, root.model, getTense2(root));
};
var toJSON3 = function(vb3) {
  let parsed = parse_default8(vb3);
  vb3 = vb3.clone().toView();
  const info = grammar_default(vb3, parsed);
  return {
    root: parsed.root.text(),
    preAdverbs: toArray4(parsed.adverbs.pre),
    postAdverbs: toArray4(parsed.adverbs.post),
    auxiliary: toText4(parsed.auxiliary),
    negative: parsed.negative.found,
    prefix: toText4(parsed.prefix),
    infinitive: toInf2(parsed.root),
    grammar: info
  };
};
var toJSON_default2 = toJSON3;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toInfinitive.js
var keep3 = { tags: true };
var toInf3 = function(vb3, parsed) {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const { root, auxiliary } = parsed;
  let aux = auxiliary.terms().harden();
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (str) {
    vb3.replace(root, str, keep3).tag("Verb").firstTerm().tag("Infinitive");
  }
  if (aux.found) {
    vb3.remove(aux);
  }
  if (parsed.negative.found) {
    if (!vb3.has("not")) {
      vb3.prepend("not");
    }
    let does = doDoes(vb3, parsed);
    vb3.prepend(does);
  }
  vb3.fullSentence().compute(["lexicon", "preTagger", "postTagger", "chunks"]);
  return vb3;
};
var toInfinitive_default3 = toInf3;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toPast.js
var keep4 = { tags: true };
var fns6 = {
  noAux: (vb3, parsed) => {
    if (parsed.auxiliary.found) {
      vb3 = vb3.remove(parsed.auxiliary);
    }
    return vb3;
  },
  simple: (vb3, parsed) => {
    const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
    const root = parsed.root;
    if (root.has("#Modal")) {
      return vb3;
    }
    let str = root.text({ keepPunct: false });
    str = toInfinitive3(str, vb3.model, getTense2(root));
    let all4 = conjugate2(str, vb3.model);
    str = all4.PastTense;
    str = str === "been" ? "was" : str;
    if (str === "was") {
      str = wasWere(vb3, parsed);
    }
    if (str) {
      vb3.replace(root, str, keep4);
    }
    return vb3;
  },
  both: function(vb3, parsed) {
    if (parsed.negative.found) {
      vb3.replace("will", "did");
      return vb3;
    }
    vb3 = fns6.simple(vb3, parsed);
    vb3 = fns6.noAux(vb3, parsed);
    return vb3;
  },
  hasHad: (vb3) => {
    vb3.replace("has", "had", keep4);
    return vb3;
  },
  hasParticiple: (vb3, parsed) => {
    const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
    const root = parsed.root;
    let str = root.text("normal");
    str = toInfinitive3(str, vb3.model, getTense2(root));
    return conjugate2(str, vb3.model).Participle;
  }
};
var forms = {
  "infinitive": fns6.simple,
  "simple-present": fns6.simple,
  "simple-past": noop,
  "simple-future": fns6.both,
  "present-progressive": (vb3) => {
    vb3.replace("are", "were", keep4);
    vb3.replace("(is|are|am)", "was", keep4);
    return vb3;
  },
  "past-progressive": noop,
  "future-progressive": (vb3, parsed) => {
    vb3.match(parsed.root).insertBefore("was");
    vb3.remove("(will|be)");
    return vb3;
  },
  "present-perfect": fns6.hasHad,
  "past-perfect": noop,
  "future-perfect": (vb3, parsed) => {
    vb3.match(parsed.root).insertBefore("had");
    if (vb3.has("will")) {
      vb3 = noWill(vb3);
    }
    vb3.remove("have");
    return vb3;
  },
  "present-perfect-progressive": fns6.hasHad,
  "past-perfect-progressive": noop,
  "future-perfect-progressive": (vb3) => {
    vb3.remove("will");
    vb3.replace("have", "had", keep4);
    return vb3;
  },
  "passive-past": (vb3) => {
    vb3.replace("have", "had", keep4);
    return vb3;
  },
  "passive-present": (vb3) => {
    vb3.replace("(is|are)", "was", keep4);
    return vb3;
  },
  "passive-future": (vb3, parsed) => {
    if (parsed.auxiliary.has("will be")) {
      vb3.match(parsed.root).insertBefore("had been");
      vb3.remove("(will|be)");
    }
    if (parsed.auxiliary.has("will have been")) {
      vb3.replace("have", "had", keep4);
      vb3.remove("will");
    }
    return vb3;
  },
  "present-conditional": (vb3) => {
    vb3.replace("be", "have been");
    return vb3;
  },
  "past-conditional": noop,
  "auxiliary-future": (vb3) => {
    vb3.replace("(is|are|am)", "was", keep4);
    return vb3;
  },
  "auxiliary-past": noop,
  "auxiliary-present": (vb3) => {
    vb3.replace("(do|does)", "did", keep4);
    return vb3;
  },
  "modal-infinitive": (vb3, parsed) => {
    if (vb3.has("can")) {
      vb3.replace("can", "could", keep4);
    } else {
      fns6.simple(vb3, parsed);
      vb3.match("#Modal").insertAfter("have").tag("Auxiliary");
    }
    return vb3;
  },
  "modal-past": noop,
  "want-infinitive": (vb3) => {
    vb3.replace("(want|wants)", "wanted", keep4);
    vb3.remove("will");
    return vb3;
  },
  "gerund-phrase": (vb3, parsed) => {
    parsed.root = parsed.root.not("#Gerund$");
    fns6.simple(vb3, parsed);
    noWill(vb3);
    return vb3;
  }
};
var toPast3 = function(vb3, parsed, form) {
  if (forms.hasOwnProperty(form)) {
    vb3 = forms[form](vb3, parsed);
    vb3.fullSentence().compute(["tagger", "chunks"]);
    return vb3;
  }
  return vb3;
};
var toPast_default2 = toPast3;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toPresent.js
var keep5 = { tags: true };
var simple = (vb3, parsed) => {
  const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const root = parsed.root;
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (isPlural4(vb3, parsed) === false) {
    str = conjugate2(str, vb3.model).PresentTense;
  }
  if (root.has("#Copula")) {
    str = isAreAm(vb3, parsed);
  }
  if (str) {
    vb3 = vb3.replace(root, str, keep5);
    vb3.not("#Particle").tag("PresentTense");
  }
  return vb3;
};
var toGerund2 = (vb3, parsed) => {
  const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const root = parsed.root;
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (isPlural4(vb3, parsed) === false) {
    str = conjugate2(str, vb3.model).Gerund;
  }
  if (str) {
    vb3 = vb3.replace(root, str, keep5);
    vb3.not("#Particle").tag("Gerund");
  }
  return vb3;
};
var vbToInf = (vb3, parsed) => {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const root = parsed.root;
  let str = parsed.root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (str) {
    vb3 = vb3.replace(parsed.root, str, keep5);
  }
  return vb3;
};
var forms2 = {
  "infinitive": simple,
  "simple-present": (vb3, parsed) => {
    const { conjugate: conjugate2 } = vb3.methods.two.transform.verb;
    let { root } = parsed;
    if (root.has("#Infinitive")) {
      let subj = getSubject_default(vb3, parsed);
      let m3 = subj.subject;
      if (isPlural4(vb3, parsed) || m3.has("i")) {
        return vb3;
      }
      let str = root.text("normal");
      let pres = conjugate2(str, vb3.model).PresentTense;
      if (str !== pres) {
        vb3.replace(root, pres, keep5);
      }
    } else {
      return simple(vb3, parsed);
    }
    return vb3;
  },
  "simple-past": simple,
  "simple-future": (vb3, parsed) => {
    const { root, auxiliary } = parsed;
    if (auxiliary.has("will") && root.has("be")) {
      let str = isAreAm(vb3, parsed);
      vb3.replace(root, str);
      vb3 = vb3.remove("will");
      vb3.replace("not " + str, str + " not");
    } else {
      simple(vb3, parsed);
      vb3 = vb3.remove("will");
    }
    return vb3;
  },
  "present-progressive": noop,
  "past-progressive": (vb3, parsed) => {
    let str = isAreAm(vb3, parsed);
    return vb3.replace("(were|was)", str, keep5);
  },
  "future-progressive": (vb3) => {
    vb3.match("will").insertBefore("is");
    vb3.remove("be");
    return vb3.remove("will");
  },
  "present-perfect": (vb3, parsed) => {
    simple(vb3, parsed);
    vb3 = vb3.remove("(have|had|has)");
    return vb3;
  },
  "past-perfect": (vb3, parsed) => {
    let subj = getSubject_default(vb3, parsed);
    let m3 = subj.subject;
    if (isPlural4(vb3, parsed) || m3.has("i")) {
      vb3 = toInf(vb3, parsed);
      vb3.remove("had");
      return vb3;
    }
    vb3.replace("had", "has", keep5);
    return vb3;
  },
  "future-perfect": (vb3) => {
    vb3.match("will").insertBefore("has");
    return vb3.remove("have").remove("will");
  },
  "present-perfect-progressive": noop,
  "past-perfect-progressive": (vb3) => vb3.replace("had", "has", keep5),
  "future-perfect-progressive": (vb3) => {
    vb3.match("will").insertBefore("has");
    return vb3.remove("have").remove("will");
  },
  "passive-past": (vb3, parsed) => {
    let str = isAreAm(vb3, parsed);
    if (vb3.has("(had|have|has)") && vb3.has("been")) {
      vb3.replace("(had|have|has)", str, keep5);
      vb3.replace("been", "being");
      return vb3;
    }
    return vb3.replace("(got|was|were)", str);
  },
  "passive-present": noop,
  "passive-future": (vb3) => {
    vb3.replace("will", "is");
    return vb3.replace("be", "being");
  },
  "present-conditional": noop,
  "past-conditional": (vb3) => {
    vb3.replace("been", "be");
    return vb3.remove("have");
  },
  "auxiliary-future": (vb3, parsed) => {
    toGerund2(vb3, parsed);
    vb3.remove("(going|to)");
    return vb3;
  },
  "auxiliary-past": (vb3, parsed) => {
    if (parsed.auxiliary.has("did")) {
      let str = doDoes(vb3, parsed);
      vb3.replace(parsed.auxiliary, str);
      return vb3;
    }
    toGerund2(vb3, parsed);
    vb3.replace(parsed.auxiliary, "is");
    return vb3;
  },
  "auxiliary-present": noop,
  "modal-infinitive": noop,
  "modal-past": (vb3, parsed) => {
    vbToInf(vb3, parsed);
    return vb3.remove("have");
  },
  "gerund-phrase": (vb3, parsed) => {
    parsed.root = parsed.root.not("#Gerund$");
    simple(vb3, parsed);
    return vb3.remove("(will|have)");
  },
  "want-infinitive": (vb3, parsed) => {
    let str = "wants";
    if (isPlural4(vb3, parsed)) {
      str = "want";
    }
    vb3.replace("(want|wanted|wants)", str, keep5);
    vb3.remove("will");
    return vb3;
  }
};
var toPresent3 = function(vb3, parsed, form) {
  if (forms2.hasOwnProperty(form)) {
    vb3 = forms2[form](vb3, parsed);
    vb3.fullSentence().compute(["tagger", "chunks"]);
    return vb3;
  }
  return vb3;
};
var toPresent_default2 = toPresent3;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toFuture.js
var keep6 = { tags: true };
var simple2 = (vb3, parsed) => {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const { root, auxiliary } = parsed;
  if (root.has("#Modal")) {
    return vb3;
  }
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (str) {
    vb3 = vb3.replace(root, str, keep6);
    vb3.not("#Particle").tag("Verb");
  }
  vb3.prepend("will").match("will").tag("Auxiliary");
  vb3.remove(auxiliary);
  return vb3;
};
var progressive = (vb3, parsed) => {
  const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const { root, auxiliary } = parsed;
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (str) {
    str = conjugate2(str, vb3.model).Gerund;
    vb3.replace(root, str, keep6);
    vb3.not("#Particle").tag("PresentTense");
  }
  vb3.remove(auxiliary);
  vb3.prepend("will be").match("will be").tag("Auxiliary");
  return vb3;
};
var forms3 = {
  "infinitive": simple2,
  "simple-present": simple2,
  "simple-past": simple2,
  "simple-future": noop,
  "present-progressive": progressive,
  "past-progressive": progressive,
  "future-progressive": noop,
  "present-perfect": (vb3) => {
    vb3.match("(have|has)").replaceWith("will have");
    return vb3;
  },
  "past-perfect": (vb3) => vb3.replace("(had|has)", "will have"),
  "future-perfect": noop,
  "present-perfect-progressive": (vb3) => vb3.replace("has", "will have"),
  "past-perfect-progressive": (vb3) => vb3.replace("had", "will have"),
  "future-perfect-progressive": noop,
  "passive-past": (vb3) => {
    if (vb3.has("got")) {
      return vb3.replace("got", "will get");
    }
    if (vb3.has("(was|were)")) {
      vb3.replace("(was|were)", "will be");
      return vb3.remove("being");
    }
    if (vb3.has("(have|has|had) been")) {
      return vb3.replace("(have|has|had) been", "will be");
    }
    return vb3;
  },
  "passive-present": (vb3) => {
    vb3.replace("being", "will be");
    vb3.remove("(is|are|am)");
    return vb3;
  },
  "passive-future": noop,
  "present-conditional": (vb3) => vb3.replace("would", "will"),
  "past-conditional": (vb3) => vb3.replace("would", "will"),
  "auxiliary-future": noop,
  "auxiliary-past": (vb3) => {
    if (vb3.has("used") && vb3.has("to")) {
      vb3.replace("used", "will");
      return vb3.remove("to");
    }
    vb3.replace("did", "will");
    return vb3;
  },
  "auxiliary-present": (vb3) => {
    return vb3.replace("(do|does)", "will");
  },
  "modal-infinitive": noop,
  "modal-past": noop,
  "gerund-phrase": (vb3, parsed) => {
    parsed.root = parsed.root.not("#Gerund$");
    simple2(vb3, parsed);
    return vb3.remove("(had|have)");
  },
  "want-infinitive": (vb3) => {
    vb3.replace("(want|wants|wanted)", "will want");
    return vb3;
  }
};
var toFuture2 = function(vb3, parsed, form) {
  if (vb3.has("will") || vb3.has("going to")) {
    return vb3;
  }
  if (forms3.hasOwnProperty(form)) {
    vb3 = forms3[form](vb3, parsed);
    vb3.fullSentence().compute(["tagger", "chunks"]);
    return vb3;
  }
  return vb3;
};
var toFuture_default2 = toFuture2;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toGerund.js
var keep7 = { tags: true };
var toGerund3 = function(vb3, parsed) {
  const { toInfinitive: toInfinitive3, conjugate: conjugate2 } = vb3.methods.two.transform.verb;
  const { root, auxiliary } = parsed;
  if (vb3.has("#Gerund")) {
    return vb3;
  }
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  let gerund = conjugate2(str, vb3.model).Gerund;
  if (gerund) {
    gerund = `${isAreAm(vb3, parsed)} ${gerund}`;
    vb3.replace(root, gerund, keep7);
  }
  if (auxiliary.found) {
    vb3.remove(auxiliary);
  }
  vb3.replace("not is", "is not");
  vb3.replace("not are", "are not");
  vb3.fullSentence().compute(["tagger", "chunks"]);
  return vb3;
};
var toGerund_default = toGerund3;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toNegative.js
var keep8 = { tags: true };
var doesNot = function(vb3, parsed) {
  let does = doDoes(vb3, parsed);
  vb3.prepend(does + " not");
  return vb3;
};
var isWas = function(vb3) {
  let m3 = vb3.match("be");
  if (m3.found) {
    m3.prepend("not");
    return vb3;
  }
  m3 = vb3.match("(is|was|am|are|will|were)");
  if (m3.found) {
    m3.append("not");
    return vb3;
  }
  return vb3;
};
var hasCopula = (vb3) => vb3.has("(is|was|am|are|will|were|be)");
var forms4 = {
  "simple-present": (vb3, parsed) => {
    if (hasCopula(vb3) === true) {
      return isWas(vb3, parsed);
    }
    vb3 = toInf(vb3, parsed);
    vb3 = doesNot(vb3, parsed);
    return vb3;
  },
  "simple-past": (vb3, parsed) => {
    if (hasCopula(vb3) === true) {
      return isWas(vb3, parsed);
    }
    vb3 = toInf(vb3, parsed);
    vb3.prepend("did not");
    return vb3;
  },
  "imperative": (vb3) => {
    vb3.prepend("do not");
    return vb3;
  },
  "infinitive": (vb3, parsed) => {
    if (hasCopula(vb3) === true) {
      return isWas(vb3, parsed);
    }
    return doesNot(vb3, parsed);
  },
  "passive-past": (vb3) => {
    if (vb3.has("got")) {
      vb3.replace("got", "get", keep8);
      vb3.prepend("did not");
      return vb3;
    }
    let m3 = vb3.match("(was|were|had|have)");
    if (m3.found) {
      m3.append("not");
    }
    return vb3;
  },
  "auxiliary-past": (vb3) => {
    if (vb3.has("used")) {
      vb3.prepend("did not");
      return vb3;
    }
    let m3 = vb3.match("(did|does|do)");
    if (m3.found) {
      m3.append("not");
    }
    return vb3;
  },
  "want-infinitive": (vb3, parsed) => {
    vb3 = doesNot(vb3, parsed);
    vb3 = vb3.replace("wants", "want", keep8);
    return vb3;
  }
};
var toNegative2 = function(vb3, parsed, form) {
  if (vb3.has("#Negative")) {
    return vb3;
  }
  if (forms4.hasOwnProperty(form)) {
    vb3 = forms4[form](vb3, parsed);
    return vb3;
  }
  let m3 = vb3.matchOne("be");
  if (m3.found) {
    m3.prepend("not");
    return vb3;
  }
  if (hasCopula(vb3) === true) {
    return isWas(vb3, parsed);
  }
  m3 = vb3.matchOne("(will|had|have|has|did|does|do|#Modal)");
  if (m3.found) {
    m3.append("not");
    return vb3;
  }
  return vb3;
};
var toNegative_default = toNegative2;

// node_modules/compromise/src/3-three/verbs/api/api.js
var api18 = function(View2) {
  class Verbs extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Verbs";
    }
    parse(n3) {
      return this.getNth(n3).map(parse_default8);
    }
    json(opts2, n3) {
      let m3 = this.getNth(n3);
      let arr = m3.map((vb3) => {
        let json = vb3.toView().json(opts2)[0] || {};
        json.verb = toJSON_default2(vb3);
        return json;
      }, []);
      return arr;
    }
    subjects(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        return getSubject_default(vb3, parsed).subject;
      });
    }
    adverbs(n3) {
      return this.getNth(n3).map((vb3) => vb3.match("#Adverb"));
    }
    isSingular(n3) {
      return this.getNth(n3).filter((vb3) => {
        return getSubject_default(vb3).plural !== true;
      });
    }
    isPlural(n3) {
      return this.getNth(n3).filter((vb3) => {
        return getSubject_default(vb3).plural === true;
      });
    }
    isImperative(n3) {
      return this.getNth(n3).filter((vb3) => vb3.has("#Imperative"));
    }
    toInfinitive(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        return toInfinitive_default3(vb3, parsed, info.form);
      });
    }
    toPresentTense(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        return toPresent_default2(vb3, parsed, info.form);
      });
    }
    toPastTense(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        return toPast_default2(vb3, parsed, info.form);
      });
    }
    toFutureTense(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        return toFuture_default2(vb3, parsed, info.form);
      });
    }
    toGerund(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        return toGerund_default(vb3, parsed, info.form);
      });
    }
    conjugate(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.form === "imperative") {
          info.form = "simple-present";
        }
        return {
          Infinitive: toInfinitive_default3(vb3.clone(), parsed, info.form).text("normal"),
          PastTense: toPast_default2(vb3.clone(), parsed, info.form).text("normal"),
          PresentTense: toPresent_default2(vb3.clone(), parsed, info.form).text("normal"),
          FutureTense: toFuture_default2(vb3.clone(), parsed, info.form).text("normal")
        };
      }, []);
    }
    isNegative() {
      return this.if("#Negative");
    }
    isPositive() {
      return this.ifNo("#Negative");
    }
    toPositive() {
      let m3 = this.match("do not #Verb");
      if (m3.found) {
        m3.remove("do not");
      }
      return this.remove("#Negative");
    }
    toNegative(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        return toNegative_default(vb3, parsed, info.form);
      });
    }
    update(pointer) {
      let m3 = new Verbs(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  Verbs.prototype.toPast = Verbs.prototype.toPastTense;
  Verbs.prototype.toPresent = Verbs.prototype.toPresentTense;
  Verbs.prototype.toFuture = Verbs.prototype.toFutureTense;
  View2.prototype.verbs = function(n3) {
    let vb3 = find_default6(this);
    vb3 = vb3.getNth(n3);
    return new Verbs(this.document, vb3.pointer);
  };
};
var api_default21 = api18;

// node_modules/compromise/src/3-three/verbs/plugin.js
var plugin_default26 = {
  api: api_default21
};

// node_modules/compromise/src/3-three/coreference/compute/lib.js
var findChained = function(want, s3) {
  let m3 = s3.match(want);
  if (m3.found) {
    let ref = m3.pronouns().refersTo();
    if (ref.found) {
      return ref;
    }
  }
  return s3.none();
};
var prevSentence = function(m3) {
  if (!m3.found) {
    return m3;
  }
  let [n3] = m3.fullPointer[0];
  if (n3 && n3 > 0) {
    return m3.update([[n3 - 1]]);
  }
  return m3.none();
};

// node_modules/compromise/src/3-three/coreference/compute/findPerson.js
var byGender = function(ppl, gender) {
  if (gender === "m") {
    return ppl.filter((m3) => !m3.presumedFemale().found);
  } else if (gender === "f") {
    return ppl.filter((m3) => !m3.presumedMale().found);
  }
  return ppl;
};
var getPerson = function(s3, gender) {
  let people = s3.people();
  people = byGender(people, gender);
  if (people.found) {
    return people.last();
  }
  people = s3.nouns("#Actor+");
  if (people.found) {
    return people.last();
  }
  if (gender === "f") {
    return findChained("(she|her|hers)", s3);
  }
  if (gender === "m") {
    return findChained("(he|him|his)", s3);
  }
  return s3.none();
};
var findPerson_default = getPerson;

// node_modules/compromise/src/3-three/coreference/compute/findThey.js
var getThey = function(s3) {
  let things = s3.nouns().isPlural();
  if (things.found) {
    return things.last();
  }
  let chain = findChained("(they|their|theirs)", s3);
  if (chain.found) {
    return chain;
  }
  return s3.none();
};
var findThey_default = getThey;

// node_modules/compromise/src/3-three/coreference/compute/index.js
var addReference = function(pron, m3) {
  if (m3 && m3.found) {
    let term = pron.docs[0][0];
    term.reference = m3.ptrs[0];
  }
};
var stepBack = function(m3, cb) {
  let s3 = m3.before();
  let res = cb(s3);
  if (res.found) {
    return res;
  }
  s3 = prevSentence(m3);
  res = cb(s3);
  if (res.found) {
    return res;
  }
  s3 = prevSentence(s3);
  res = cb(s3);
  if (res.found) {
    return res;
  }
  return m3.none();
};
var coreference = function(view) {
  let pronouns = view.match("(he|him|his|she|her|hers|they|their|theirs|it|its)");
  pronouns.forEach((pron) => {
    let res = null;
    if (pron.has("(he|him|his)")) {
      res = stepBack(pron, (m3) => findPerson_default(m3, "m"));
    } else if (pron.has("(she|her|hers)")) {
      res = stepBack(pron, (m3) => findPerson_default(m3, "f"));
    } else if (pron.has("(they|their|theirs)")) {
      res = stepBack(pron, findThey_default);
    }
    if (res && res.found) {
      addReference(pron, res);
    }
  });
};
var compute_default12 = coreference;

// node_modules/compromise/src/3-three/coreference/api/pronouns.js
var api19 = function(View2) {
  class Pronouns extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Pronouns";
    }
    refersTo() {
      return this.map((m3) => {
        if (!m3.found) {
          return m3.none();
        }
        let term = m3.docs[0][0];
        if (term.reference) {
          return m3.update([term.reference]);
        }
        return m3.none();
      });
    }
    update(pointer) {
      let m3 = new Pronouns(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  View2.prototype.pronouns = function(n3) {
    let m3 = this.match("#Pronoun");
    m3 = m3.getNth(n3);
    return new Pronouns(m3.document, m3.pointer);
  };
};
var pronouns_default = api19;

// node_modules/compromise/src/3-three/coreference/plugin.js
var plugin_default27 = {
  compute: { coreference: compute_default12 },
  api: pronouns_default
};

// node_modules/compromise/src/three.js
two_default.plugin(plugin_default18);
two_default.plugin(plugin_default27);
two_default.plugin(plugin_default19);
two_default.plugin(plugin_default20);
two_default.plugin(plugin_default21);
two_default.plugin(plugin_default22);
two_default.plugin(plugin_default23);
two_default.plugin(plugin_default24);
two_default.plugin(plugin_default25);
two_default.plugin(plugin_default26);
var three_default = two_default;

// syntaxHighlight.ts
function getAllDecosByLine(view) {
  const widgets = {};
  for (const visibleRange of view.visibleRanges) {
    const startLine = view.state.doc.lineAt(visibleRange.from).number;
    const endLine = view.state.doc.lineAt(visibleRange.to).number;
    for (let i3 = startLine; i3 <= endLine; i3++) {
      widgets[i3] = getDecosOnLine(view, i3);
    }
  }
  return widgets;
}
function getDecosOnLine(view, lineNumber) {
  const widgets = [];
  const line = view.state.doc.line(lineNumber);
  const docText = view.state.sliceDoc(line.from, line.to);
  const doc = three_default(docText);
  const wordsToHighlight = {};
  const adjectives = doc.adjectives();
  const nouns = doc.match("#Noun").not("#Pronoun").not("#Possessive");
  const adverbs = doc.adverbs();
  const verbs = doc.match("#Verb");
  const conjunctions = doc.conjunctions();
  wordsToHighlight["adjective"] = adjectives;
  wordsToHighlight["noun"] = nouns;
  wordsToHighlight["adverb"] = adverbs;
  wordsToHighlight["verb"] = verbs;
  wordsToHighlight["conjunction"] = conjunctions;
  const plugin5 = window.app.plugins.plugins["nl-syntax-highlighting"];
  for (const partOfSpeech of Object.keys(wordsToHighlight)) {
    const words = wordsToHighlight[partOfSpeech];
    for (const word of words.out("offset")) {
      const offset2 = word.offset;
      const start2 = offset2.start;
      const end2 = start2 + word.terms[0].offset.length;
      if (start2 === end2)
        continue;
      const truePartOfSpeech = word.text in plugin5.wordsToOverrideDict ? plugin5.wordsToOverrideDict[word.text] : partOfSpeech;
      widgets.push({ partOfSpeech: truePartOfSpeech, start: start2, end: end2 });
    }
  }
  return widgets;
}
function decosByLineToDecorationSet(view, decorationsByLine) {
  const allWidgets = [];
  for (const lineNumberStr of Object.keys(decorationsByLine)) {
    const lineNumber = parseInt(lineNumberStr);
    const widgets = decorationsByLine[lineNumber];
    const lineStart = view.state.doc.line(lineNumber).from;
    const offsetWidgets = widgets.map((decoSpec) => {
      return import_view.Decoration.mark({
        inclusive: true,
        attributes: {},
        class: decoSpec.partOfSpeech
      }).range(decoSpec.start + lineStart, decoSpec.end + lineStart);
    });
    allWidgets.push(...offsetWidgets);
  }
  return import_view.Decoration.set(allWidgets, true);
}
var NLSyntaxHighlightViewPlugin = import_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorationsByLine = getAllDecosByLine(view);
    this.decorations = decosByLineToDecorationSet(view, this.decorationsByLine);
  }
  update(update) {
    let shouldRegenerateAllDecorations = false;
    if (update.docChanged) {
      if (update.startState.doc.lines === update.state.doc.lines) {
        let changeCount = 0;
        let lineChangedNumber = 0;
        let singleCharacterInserted = true;
        update.changes.iterChangedRanges((fromA, toA, fromB, toB) => {
          changeCount += 1;
          if (changeCount > 1)
            singleCharacterInserted = false;
          if (!(fromA === toA && toB === fromB + 1))
            singleCharacterInserted = false;
          lineChangedNumber = update.view.state.doc.lineAt(toB).number;
        });
        if (singleCharacterInserted) {
          this.decorationsByLine[lineChangedNumber] = getDecosOnLine(update.view, lineChangedNumber);
        } else {
          shouldRegenerateAllDecorations = true;
        }
      } else {
        shouldRegenerateAllDecorations = true;
      }
    } else if (update.viewportChanged) {
      shouldRegenerateAllDecorations = true;
    }
    if (shouldRegenerateAllDecorations)
      this.decorationsByLine = getAllDecosByLine(update.view);
    this.decorations = decosByLineToDecorationSet(update.view, this.decorationsByLine);
  }
}, { decorations: (v2) => v2.decorations });

// settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  adjectiveEnabled: true,
  adjectiveColor: "#b97a0a",
  nounEnabled: true,
  nounColor: "#ce4924",
  adverbEnabled: true,
  adverbColor: "#c333a7",
  verbEnabled: true,
  verbColor: "#177eB8",
  conjunctionEnabled: true,
  conjunctionColor: "#01934e",
  classToApplyHighlightingTo: "",
  wordsToOverride: ""
};
var NLSyntaxHighlightSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin5) {
    super(app, plugin5);
    this.plugin = plugin5;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const adjectives = new import_obsidian.Setting(containerEl).setName("Adjectives");
    let adjectiveToggle;
    adjectives.addToggle((toggle) => {
      var _a, _b;
      adjectiveToggle = toggle.toggleEl;
      (_b = (_a = adjectiveToggle.parentElement) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.prepend(adjectiveToggle);
      toggle.setValue(this.plugin.settings.adjectiveEnabled).onChange(async (value) => {
        this.plugin.settings.adjectiveEnabled = value;
        await this.plugin.saveSettings();
        this.plugin.reloadStyle();
      });
    });
    adjectives.addColorPicker((component) => component.setValue(this.plugin.settings.adjectiveColor).onChange(async (value) => {
      this.plugin.settings.adjectiveColor = value;
      await this.plugin.saveSettings();
      this.plugin.reloadStyle();
    }));
    const nouns = new import_obsidian.Setting(containerEl).setName("Nouns");
    let nounToggle;
    nouns.addToggle((toggle) => {
      var _a, _b;
      nounToggle = toggle.toggleEl;
      (_b = (_a = nounToggle.parentElement) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.prepend(nounToggle);
      toggle.setValue(this.plugin.settings.nounEnabled).onChange(async (value) => {
        this.plugin.settings.nounEnabled = value;
        await this.plugin.saveSettings();
        this.plugin.reloadStyle();
      });
    });
    nouns.addColorPicker((component) => component.setValue(this.plugin.settings.nounColor).onChange(async (value) => {
      this.plugin.settings.nounColor = value;
      await this.plugin.saveSettings();
      this.plugin.reloadStyle();
    }));
    const adverbs = new import_obsidian.Setting(containerEl).setName("Adverbs");
    let adverbToggle;
    adverbs.addToggle((toggle) => {
      var _a, _b;
      adverbToggle = toggle.toggleEl;
      (_b = (_a = adverbToggle.parentElement) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.prepend(adverbToggle);
      toggle.setValue(this.plugin.settings.adverbEnabled).onChange(async (value) => {
        this.plugin.settings.adverbEnabled = value;
        await this.plugin.saveSettings();
        this.plugin.reloadStyle();
      });
    });
    adverbs.addColorPicker((component) => component.setValue(this.plugin.settings.adverbColor).onChange(async (value) => {
      this.plugin.settings.adverbColor = value;
      await this.plugin.saveSettings();
      this.plugin.reloadStyle();
    }));
    const verbs = new import_obsidian.Setting(containerEl).setName("Verbs");
    let verbToggle;
    verbs.addToggle((toggle) => {
      var _a, _b;
      verbToggle = toggle.toggleEl;
      (_b = (_a = verbToggle.parentElement) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.prepend(verbToggle);
      toggle.setValue(this.plugin.settings.verbEnabled).onChange(async (value) => {
        this.plugin.settings.verbEnabled = value;
        await this.plugin.saveSettings();
        this.plugin.reloadStyle();
      });
    });
    verbs.addColorPicker((component) => component.setValue(this.plugin.settings.verbColor).onChange(async (value) => {
      this.plugin.settings.verbColor = value;
      await this.plugin.saveSettings();
      this.plugin.reloadStyle();
    }));
    const conjunctions = new import_obsidian.Setting(containerEl).setName("Conjunctions");
    let conjunctionToggle;
    conjunctions.addToggle((toggle) => {
      var _a, _b;
      conjunctionToggle = toggle.toggleEl;
      (_b = (_a = conjunctionToggle.parentElement) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.prepend(conjunctionToggle);
      toggle.setValue(this.plugin.settings.conjunctionEnabled).onChange(async (value) => {
        this.plugin.settings.conjunctionEnabled = value;
        await this.plugin.saveSettings();
        this.plugin.reloadStyle();
      });
    });
    conjunctions.addColorPicker((component) => component.setValue(this.plugin.settings.conjunctionColor).onChange(async (value) => {
      this.plugin.settings.conjunctionColor = value;
      await this.plugin.saveSettings();
      this.plugin.reloadStyle();
    }));
    new import_obsidian.Setting(containerEl).setName("Words to override").setDesc("Occasionally, words may be misclassfied. Type words here to override their classification. Use the format word: part-of-speech, with each word separated by a new line. e.g. snowy: adjective").addTextArea((text) => text.setValue(this.plugin.settings.wordsToOverride).setPlaceholder(`snowy: adjective
cloud: noun`).onChange(async (value) => {
      this.plugin.settings.wordsToOverride = value;
      this.plugin.loadWordsToOverrideDict();
      this.plugin.reloadEditorExtensions();
      (0, import_obsidian.debounce)(() => {
        this.plugin.reloadEditorExtensions();
      }, 1e3);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("CSS class to apply syntax highlighting to").setDesc('If specified, the syntax highlighting will only be applied to notes with the "cssclass" property in their YAML equal to the specified value.').addText((text) => text.setValue(this.plugin.settings.classToApplyHighlightingTo).onChange(async (value) => {
      this.plugin.settings.classToApplyHighlightingTo = value;
      await this.plugin.saveSettings();
      this.plugin.reloadStyle();
    }));
  }
};

// main.ts
var NLSyntaxHighlightPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new NLSyntaxHighlightSettingTab(this.app, this));
    this.loadWordsToOverrideDict();
    this.extensions = [NLSyntaxHighlightViewPlugin.extension];
    this.registerEditorExtension(this.extensions);
    this.styleEl = document.head.createEl("style");
    this.reloadStyle();
  }
  onunload() {
    this.styleEl.remove();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  convertSettingsToStyle(settings) {
    let style = "";
    const partsOfSpeech = ["adjective", "noun", "adverb", "verb", "conjunction"];
    const enabled = [settings.adjectiveEnabled, settings.nounEnabled, settings.adverbEnabled, settings.verbEnabled, settings.conjunctionEnabled];
    const colors2 = [settings.adjectiveColor, settings.nounColor, settings.adverbColor, settings.verbColor, settings.conjunctionColor];
    for (let i3 = 0; i3 < partsOfSpeech.length; i3++) {
      if (enabled[i3]) {
        if (settings.classToApplyHighlightingTo.length > 0) {
          style = style.concat(`.${settings.classToApplyHighlightingTo} .${partsOfSpeech[i3]} { color: ${colors2[i3]} }
`);
        } else {
          style = style.concat(`.${partsOfSpeech[i3]} { color: ${colors2[i3]} }
`);
        }
      }
    }
    return style;
  }
  reloadStyle() {
    this.styleEl.textContent = this.convertSettingsToStyle(this.settings);
  }
  loadWordsToOverrideDict() {
    const dict = {};
    const lines = this.settings.wordsToOverride.split("\n");
    lines.forEach((val) => {
      const line = val.replaceAll(" ", "").split(":");
      if (line[1])
        dict[line[0]] = line[1];
    });
    this.wordsToOverrideDict = dict;
  }
  reloadEditorExtensions() {
    this.extensions.pop();
    this.app.workspace.updateOptions();
    this.extensions.push(NLSyntaxHighlightViewPlugin.extension);
    this.app.workspace.updateOptions();
  }
};
